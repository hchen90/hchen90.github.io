{"code":0,"data":{"title":"软件设计模式 - 结构型模式","content":"# 软件设计模式 - 结构型模式\n\n# 软件设计模式 - 结构型模式[ #](#软件设计模式---结构型模式)\n\n结构型模式介绍类和对象的组装方式，同时保持较大的灵活性和高效性。\n\n结构型模式包括：适配器，桥接，组合，装饰，外观，享元，代理。\n\n## 适配器模式（Adapter）[ #](#适配器模式adapter)\n\n适配器模式是为了解决不同接口之间的适配问题。\n\n适配器通常分为两类：对象适配器，类适配器。\n\n### 对象适配器[ #](#对象适配器)\n\n对象适配器是通过实现接口来做到适配的，如下：\n\n![Object Adapter](/post/softwaredesignpattern3/5f2239c668b3.png)\n\n示例代码：\n\ncppCopy\n\n```cpp\nclass DrawService {\n    // 绘图服务\npublic:\n    void paint(Graphics&) {\n        // 使用Graphics绘图\n    }\n    Graphics& getCanvasGraphics(canvas&) {\n        // 图形绘板转换\n    }\n};\n\nclass DrawInterface {\n    // 绘图适配器接口\nprotected:\n    void draw(canvas&) = 0;\n};\n\nclass DrawAdapter : public DrawInterface {\n    // 绘图适配器\nprotected:\n    void draw(canvas& c) { // 接口适配\n        auto g = service.getCanvasGraphics(c);\n        service.paint(g);\n    }\nprivate:\n    DrawService service;\n};\n```\n\n### 类适配器[ #](#类适配器)\n\n类适配器是通过面相对象编程的继承达到的，用于多继承方式实现。\n\n如图所示：\n\n![Class Adapter](/post/softwaredesignpattern3/7b312890a4c8.png)\n\n实例代码：\n\ncppCopy\n\n```cpp\nclass DrawGraphics {\n    // 图案绘制\npublic:\n    void draw(Graphics&) {\n        // 绘制函数\n    }\n};\n\nclass DrawService {\n    // 绘制服务\nprotected:\n    void paint(Graphics&) {\n        // 绘制\n    }\n    Graphics& getCanvasGraphics(canvas&) {\n        // 转换画板\n    }\n};\n\nclass DrawAdapter : public DrawGraphics, public DrawService {\n    // 绘制适配器\npublic:\n    void draw(canvas& c) {\n        auto g = getCanvasGraphics(c);\n        paint(g);\n    }\n};\n```\n\n## 桥接模式（Bridge）[ #](#桥接模式bridge)\n\n桥接模式是将抽象和实现分为两个独立的层次，将原本不同维度的继承方式改成组合方式。\n\n如下图所示：\n\n![Bridge](/post/softwaredesignpattern3/d48eba393b9c.png)\n\n示例代码：\n\ncppCopy\n\n```cpp\n// 画笔风格\n\nclass Style {\npublic:\n    void draw(Canvas&) = 0;\n};\n\nclass Pencil : public Style {\npublic:\n    void draw(Canvas&) {\n        // TODO: 铅笔绘制实现\n    }\n};\n\nclass Brush : public Style {\npublic:\n    void draw(Canvas&) {\n        // TODO: 画刷绘制实现\n    }\n};\n\nclass Pastel : public Style {\npublic:\n    void draw(Canvas&) {\n        // TODO: 蜡笔绘制实现\n    }\n};\n\n// 形状\nclass Square {\npublic:\n    void drawWithPen(Style& pen) {\n        pen.draw(this->getCanvas());\n    }\n};\n\nclass Circle {\npublic:\n    void drawWithPen(Style& pen) {\n        pen.draw(this->getCanvas());\n    }\n};\n```\n\n形状类只是抽象绘制层，可以绘制不同风格的图形，但是对于具体的绘制实现其实由不同风格的画笔来实现。\n\n## 组合模式（Composite）[ #](#组合模式composite)\n\n组合模式用于将对象组合成树状结构，通常这种模式的实现方式多见为“盒子”（Box）与“产品”（Item）的交互方式，盒子本身也是产品，盒子可以存放产品，从而产生递归嵌套的结构。\n\n结构如下：\n\n![Composite](/post/softwaredesignpattern3/4c391f951bae.png)\n\n示例代码：\n\ncppCopy\n\n```cpp\nclass Shape {\npublic:\n    void draw() = 0;\nprotected:\n    float x, y;\n};\n\nclass Circle : public Shape {\npublic:\n    void draw() {\n        // 绘制圆形\n    }\nprivate:\n    float radius;\n};\n\nclass Square : public Shape {\npublic:\n    void draw() {\n        // 绘制方块\n    }\nprivate:\n    float width, height;\n};\n\n// 组合图形\nclass CompoundShape : public Shape {\npublic:\n    void draw() {\n        // 迭代绘制所有子图形\n    }\nprivate:\n    std::vector<Shape> childs;\n};\n```\n\n## 装饰模式（Decorator）[ #](#装饰模式decorator)\n\n装饰器模式允许将对象放入包含某种行为的特殊对象，从而为原来的对象绑定特殊对象的新行为。\n\n结构如下：\n\n![Decorator](/post/softwaredesignpattern3/c0920326f4f1.png)\n\ncppCopy\n\n```cpp\nclass Shape {\npublic:\n    virtual draw() = 0;\n};\n\nclass Circle : public {\npublic:\n    void draw() {\n        // TODO: 绘制\n    }\nprivate:\n    float radius;\n};\n\n// 装饰器\nclass BrushDecorator : public Shape {\npublic:\n    BrushDecorator(Shape& s) {\n        // TODO: 设置画刷风格\n    }\n    void draw() {\n        // 绘制\n        Shape::draw();\n    }\n};\n\nclass PastelDecorator : public Shape {\npublic:\n    PastelDecorator(Shape& s) {\n        // TODO: 设置蜡笔风格\n    }\n    void draw() {\n        // 绘制\n        Shape::draw();\n    }\n};\n```\n\n使用装饰器模式，如下：\n\ncppCopy\n\n```cpp\nCircle circle;\n\nauto circleWithBrush = new BrushDecorator(circle);\nauto circleWithPastel = new PastelDecorator(circle);\nauto circleWithBrushPastel = new PastelDecorator(circleWithBrush); // 嵌套装饰\n\ncircleWithBrush.draw();\ncircleWithPastel.draw();\ncircleWithBrushPastel.draw();\n```\n\n## 外观模式（Facade）[ #](#外观模式facade)\n\n外观模式是为了给库/框架设计一套简单的接口，这样对外减少细节暴露，从而减少系统的耦合度。\n\n如下示例，设计了一种统一风格的徽章绘制模式：\n\n![Facade](/post/softwaredesignpattern3/eb503e9c579c.png)\n\n示例代码：\n\ncppCopy\n\n```cpp\nclass Shape {\npublic:\n    void draw(Canvas&) = 0;\n};\n\nclass CompoundShape : public Shape {\npublic:\n    void addChild(Shape& c) {\n        // 添加图形\n    }\n    void draw(Canvas&) {\n        // 绘制图形\n    }\nprivate:\n    std::vector<Shape> childs;\n};\n\nclass Brush {\npublic:\n    void setPen(Canvas&);\n};\n\nclass Background {\npublic:\n    void fill(Canvas&);\n};\n\nclass Badget {\npublic:\n    void drawBadget(Shape& s) {\n        // 绘制徽章\n        auto canvas = this->getCanvas();\n        assert(canvas != nullptr);\n        br.setPen(*canvas);\n        bg.fill(*canvas);\n        s.draw(*canvas);\n    }\nprivate:\n    Brush br;\n    Background bg;\n    CompundShape cshape;\n};\n```\n\n对于外部调用者来说，只需调用`drawBadget()`，将徽章复杂图形变量作为形式参数传入函数，即可完成各种徽章的绘制。\n\n## 享元模式（Flyweight）[ #](#享元模式flyweight)\n\n享元模式是通过共享对象状态，使得对象不必保存所有的状态，从而达到在内存中载入更多的对象。\n\n常见应用场景是游戏制作场景，游戏中最常见的元素是粒子系统，每一个粒子都有自己的坐标，颜色，状态等信息，如果每一个粒子对象都存储所有的信息，那么在实际游戏场景中将会对内存需求巨大，几十万个粒子就会导致系统内存被用完，从而导致OOM，为了解决这个问题，可以从对象的类来分析，提取其中的常量和变量，对于常量使用共享对象存储。\n\n如下：\n\n![Flyweight](/post/softwaredesignpattern3/977e46e42cd8.png)\n\n示例代码：\n\ncppCopy\n\n```cpp\nclass Background {};\n\nclass Color {};\n\nclass Flyweight {\npublic:\n    void draw() {\n        // 绘制粒子\n    }\nprivate:\n    Background bg;\n    Color cr;\n};\n\nclass FlyweightFactory {\npublic:\n    Flyweight* getFlyweight(state s) {\n        auto f = cache.find(s);\n        if (f != nullptr) return f;\n        return new Flyweight();\n    }\nprivate:\n    Cache cache;\n};\n```\n\n享元模式使用前还需要进行初始化，以便将常量对象存储到享元工厂的cache中。\n\ncppCopy\n\n```cpp\n// 初始化享元工厂\nauto particle1 = new Flyweight(1); // 静态粒子1\nauto particle2 = new Flyweight(2); // 静态粒子2\n// ...\n\nFlyweightFactory::getInstance().addFlyweight(particle1);\nFlyweightFactory::getInstance().addFlyweight(particle2);\n\nauto particle = FlyweightFactory::getInstance().getFlyweight(-1); // 普通动态粒子\n```\n\n## 代理模式（Proxy）[ #](#代理模式proxy)\n\n代理模式提供对对象访问的占位，控制对原始对象的访问，可以做到在外界对对象请求操作前后添加额外处理。\n\n还是以绘图案例为例，这里绘制的是图片，这些图片以tag为唯一名称存储在数据库中，每次绘制需要从数据库获取相应的图片，再进行绘制，但是，如果绘制的图形复杂，包含的图片较多的时候，绘制效率会很低，绘制界面就会出现绘制延迟的现象，根本原因是从数据库获取图片的累加时间太长了。所以解决这种问题，就要用到代理器的模式，如下：\n\n![Proxy](/post/softwaredesignpattern3/68bf559f3059.png)\n\n这里的代理器在获取到图片的时候，会对已经获取的图片做缓存，这样下次再次获取该图片，就可以立即返回该图片，从而大大减少绘制时间，使绘制效率变高。\n\n案例代码：\n\ncppCopy\n\n```cpp\nclass Image {\npublic:\n    std::vector<std::string> listImages() = 0;\n    std::vector<uint8_t> getImage(std::string&) = 0;\n};\n\nclass DBImage : public Image {\npublic:\n    std::vector<std::string> listImages() {\n        auto result = db.findAll();\n        // 数据库查询返回所有的图片的tag列表\n    };\n    std::vector<uint8_t> getImage(std::string&) {\n        // 返回对应tag的图片数据\n    };\nprivate:\n    DB db;\n};\n\nclass CachedImage : public Image {\npublic:\n    CachedImage(DBImage& dbi) {}\n    std::vector<std::string> listImages() {\n        auto result = cache.findAll(); // 缓存查找\n        if (!result.empty()) {\n            return result;\n        }\n        result = service.findAll(); // 原始服务查找\n        cache.store(result);\n        return result;\n    };\n    std::vector<uint8_t> getImage(std::string& tag) {\n        auto img = cache.find(tag); // 缓存查找图片\n        if (!img.empty()) {\n            return img;\n        }\n        img = service.find(tag); // 原始服务获取图片\n        cache.store(tag, img);\n        return img;\n    };\nprivate:\n    DBImage service;\n    Cache cache;\n};\n```\n\n实际使用时，直接调用代理器即可：\n\ncppCopy\n\n```cpp\nDBImage dbi(\"mongo://xxxx\");\nCachedImage ci(dbi);\n\nauto result = ci.listImages();\nauto image = ci.getImage(result[0]); // 第一个tag的图片\n```\n\n> CacheImage\n>\n> > CacheImage中使用的Cache，根据实际应用场景，可以是中间件存储，例如：Memcached，redis等。\n\n## MVC模式（MVC）[ #](#mvc模式mvc)\n\nMVC分别代表：Model-View-Controller，这种方式应用于程序的分层开发，减少数据，视图界面，和逻辑控制之间的耦合，使开发维护更加清晰。\n\n这种模式在传统的MFC开发框架中广泛使用。下面演示一个富文本编辑器的MVC设计。\n\n![MVC](/post/softwaredesignpattern3/816f2afd2731.png)\n\n代码如下：\n\ncppCopy\n\n```cpp\nclass Model {};\n\nclass View {};\n\nclass Controller {\npublic:\n    void setView() = 0;\n    void setModel() = 0;\n};\n\nclass Document : public Model {\npublic:\n    Document(Controller* ctrl) {\n        this->ctrl = ctrl;\n    }\nprivate:\n    Controller* ctrl;\n};\n\nclass RichEditCtrl : public Controller {\npublic:\n    void setView(View* v) {\n        this->view = v;\n    }\n    void setModel(Model* m) {\n        this->model = m;\n    }\nprivate:\n    View* view;\n    Model* model;\n};\n\nclass RichEditView : public View {\npublic:\n    View(Controller* ctrl) {\n        this->ctrl = ctrl;\n    }\nprivate:\n    Controller* ctrl;\n};\n```\n\n构造MVC时如下：\n\ncppCopy\n\n```cpp\nRichEditCtrl ctrl;\nRichEditView view(&ctrl);\nDocument doc(&ctrl);\nctrl.setView(&view);\nctrl.setModel(&doc);\n\n// 视图的更新通知控制器\nctrl.notify();\n// 控制器更新数据模型\ndoc.update();\n// 模型更新完后刷新视图\nview.refresh();\n```\n"}}