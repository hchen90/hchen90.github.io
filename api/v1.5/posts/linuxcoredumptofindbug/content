{"code":0,"data":{"title":"利用Linux的coredump机制快速定位程序BUG","content":"# 利用Linux的coredump机制快速定位程序BUG\n\n# 什么是coredump？[ #](#什么是coredump)\n\n**Coredump**是继承于UNIX系统的机制，它用于保存程序出错而崩溃时的栈，内存，PID，UID，GID，时间等等信息的快照，通常用于程序诊断和调试，**Coredump**的信息在计算机中一般保存三天左右（依系统设定而定），如果出错的程序BUG不及时查找，超过三天系统会吧这些**Coredump**删除。\n\n# 需要些什么工具？[ #](#需要些什么工具)\n\n一般来说，只需要objdump和gdb即可，诊断时源代码以原始为佳（core dumped时的未修改的代码）。\n\n# 案例分析[ #](#案例分析)\n\n下面是我展示的一个出错事例，供参考观摩。\n\n## 程序崩溃了[ #](#程序崩溃了)\n\n这个程序运行时，一点问题也没有，就是退出时有小概率的情况出现崩溃，这种最让人头疼，像这种隐蔽BUG，很多情形不会触发它，却在某个特殊条件下，它突然就发生了。总结为两难：\n\n* 难确定（是否发生）\n* 难定位\n\n见下图：\n\n![pic1](/post/linuxcoredumptofindbug/362a65b8f108.png)\n\n## 尝试用coredumpctl工具直接调试[ #](#尝试用coredumpctl工具直接调试)\n\n*coredumpctl*是systemd的工具之一，只要用的是这个系统服务的，应该都有，此工具使用非常简单，可以命令输入以获帮助：\n\nbashCopy\n\n```bash\ncoredumpctl --help\n```\n\n或者，也可以查看它的man文档。\n\n好了，言归正传，尝试输入命令以调试：\n\nbashCopy\n\n```bash\ncoredumpctl debug xxxx\n```\n\n> 上面的xxxx是程序文件名，关于该程序名，可以用`coredumpctl list`查看到\n\n出现如下图的结果：\n\n![pic2](/post/linuxcoredumptofindbug/6c64330d950e.png)\n\n这种情况就比较复杂了，可以看见`0x00007f77be94cf25 in ?? ()`这句，**Coredump**也不能在源代码确定具体出错的位置了，作为比较，我展示另一个例子：\n\n![pic3](/post/linuxcoredumptofindbug/71ba8acd8596.png)\n\n上图这个例子出错代码立马被**Coredump**断定出来，很显然执行这句代码时崩溃的：\n\ncppCopy\n\n```cpp\n*a = 0;\n```\n\n这句是我故意改错用于比较的，源代码是这样的：\n\ncppCopy\n\n```cpp\n\tbool input(string& filename, ...) {\n\t  cout << filename << endl;\n\t  int* a = 0;\n\t  *a = 0;\n\t  return true;\n\t}\n```\n\n好了，我们继续前面的`0x00007f77be94cf25 in ?? ()`这句，我们不能像前面这个立马断定，那该怎么办呢？\n\n## 用`coredumctl info`查看栈信息[ #](#用coredumctl-info查看栈信息)\n\n下面两张图展示了这个崩溃程序的栈信息。\n\n图一：\n\n![pic4](/post/linuxcoredumptofindbug/150a7f25d236.png)\n\n图二： ![pic5](/post/linuxcoredumptofindbug/a6ba03170bef.png)\n\n因为输出信息较宽，被我分成了两张图，注意图二中栈的调用列表，下面我们接着反汇编原始程序文件。\n\n## 反汇编程序文件[ #](#反汇编程序文件)\n\n反汇编原始崩溃程序文件时，不要忘记加`--source`参数，不然全是汇编代码查找效率就不是很高，即输入命令带反汇编：\n\nbashCopy\n\n```bash\nobjdump --source -d xxxx | less\n```\n\n图片展示：\n\n![pic6](/post/linuxcoredumptofindbug/9202c3c3e25b.png)\n\n> 同样，xxxx为程序文件名\n\n这时，我们可以在`less`中依次查找各个栈地址（见图二所述），转到那个从`libc`刚出来，在程序文件最先出错位置，即：`0x42ce8`的文件位置，错误立马被锁定位置（可以依次查找栈上面的地址，顺藤摸瓜，可以断定那是在给`list`进行`clear`操作），原来是C++的类析构函数在析构一个`list`时出的错误，继而判定这个错误实际上是个多线程引起的错误，因为程序中还有一个子线程也在释放操作，是主线程和子线程同时释放引起，对于释放资源，主/子线程没有加同步，从而导致时而正常，时而出错，加上一个最简单的同步机制，问题解决。\n"}}