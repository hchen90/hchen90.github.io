{"code":0,"data":{"title":"玩转自搭建 GitLab 社区版","content":"# 玩转自搭建 GitLab 社区版\n\n# 玩转自搭建 GitLab 社区版[ #](#玩转自搭建-gitlab-社区版)\n\n本文的自搭建是基于docker容器技术而实现的，其中包括`gitlab-ce`和`gitlab-runner`两个部分。\n\n## 什么是 GitLab[ #](#什么是-gitlab)\n\n**GitLab**是一个代码仓库管理系统（它是一套开源项目），使用 Git 作为代码管理工具，集成 Web 管理的服务，**GitLab**被广泛用于基于 Git 代码管理平台，在很多一些结构不是复杂的组织结构中都会优先使用它。\n\n## 它能做什么[ #](#它能做什么)\n\n**GitLab**是代码仓库管理系统，它实现了一个更加界面友好的交互方式来对项目代码进行管理，除此之外，它还可以集成CI/CD特性，通过部署 **GitLab-Runner** 来对项目代码进行持续集成和部署分发。\n\n功能很实用，可以满足常规的项目开发工作。\n\n> 对比一些大项目，其设计复杂，对于代码的管控也非常复杂，采取的管理手段也多样化，GitLab可能不一定适应这种场景，为此大多数的做法是仓库管理系统和CI/CD系统分离的结构，仓库管理系统有五花八门的，有自己开发的（或者基于其他的开源项目），而对于CI/CD系统一般都是采用Jenkins，其有更加丰富的成熟套件和流程方案。\n\n## 搭建步骤[ #](#搭建步骤)\n\n这里介绍我测试搭建这套系统的搭建步骤。\n\n### 搭建 GitLab 主框架[ #](#搭建-gitlab-主框架)\n\n在Docker镜像的主官网上，我们其实可以搜索到**GitLab**的镜像，所以我们很方便的使用Docker技术来部署我们需要的服务。\n\n![docker-gitlab-ce](/post/deploygitlabcerunner/530bd021d4e1.png)\n\n该镜像下有很多的`tags`，可以指定特定的版本，或者使用默认的最近版本。\n\n**GitLab**的管理系统搭建，我使用编写`docker-compose.yml`方式来部署的，注意添加服务的时候，设置的环境变量`GITLAB_OMNIBUS_CONFIG`，可以为服务启动传递启动参数。\n\n当仓库管理系统服务创建并启动后，我们就可以打开浏览器来访问自搭建部署的**GitLab**服务了，如下图所示：\n\n![login](/post/deploygitlabcerunner/e2e1519d6a0e.png)\n\n### 登录管理员账号[ #](#登录管理员账号)\n\n以上步骤之后，需要登录管理员的账号，来进一步对系统进行配置，管理员的用户名是`root`，而密码需要从容器里面去获取，我们也可以获取容器的IP，便于后面的设置使用，如下：\n\n![gitlab-ce-info](/post/deploygitlabcerunner/9442444b2afa.png)\n\n据此我们得到管理员的密码来登录系统。\n\n![admin-dashboard](/post/deploygitlabcerunner/1c87025556eb.png)\n\n系统登录后进入系统配置的页面，在此页面上，我们可以完成仓库管理系统的所有配置工作。\n\n> 我们弄这个GitLab绝对不是仅仅作为代码管理系统而用的，如果仅仅为了代码仓库管理，可以移步到`gogs`这些代码仓库管理系统，它速度快，简洁而且美观，很有Github的界面感。\n\n#### CI/CD环境部署配置[ #](#cicd环境部署配置)\n\n这是配置的重头戏了。\n\n当上面的步骤都差不多了，就要进行**GitLab-Runner**的部署，它是CI/CD的代理节点，我们可以在管理员界面下点开**Runner**查看可以用的列表：\n\n![runners](/post/deploygitlabcerunner/f6e0f2e2f440.png)\n\n上面啥也没有，我们需要弄一个代理机器作为节点，让它去跑**Runner**，为此我们需要在代理机器上安装**GitLab-Runner**，这是常规操作。\n\n但是，我只是测试一下GitLab的特性，把玩一下而已，所有不需要那么复杂，仍然可以通过部署Docker的**GitLab-Runner**服务的运行它，并把它注册到本地，这样为了便于解析IP，我需要调整一下Hosts文件的内容，增加一行解析：\n\nvbnetCopy\n\n```vbnet\n192.168.176.2 gitlab.me\n```\n\n上面的`192.168.176.2`，不一定和你的一样，需要和上面的容器内的IP对应，这样多个容器都可以正确解析到正确的IP上去。\n\n下面是注册 Runner （这里的`token`可以从上图的`Registration token`处复制过来），如图所示：\n\n![runner-register](/post/deploygitlabcerunner/53a51f2560c9.png)\n\n注册成功后，会在上面的Runners列表里面刷新出来。\n\n> 注意到，我这里的`executor`用的是`docker`，这样我可以用Docker镜像（gcc）来编译代码，这适合这种用Docker容器部署的情形，但是如果是直接把Runner安装在了实体机器上的，并且实体机器上已经存在开发环境，那么我们可以直接用`shell`方式来编译。如果是需要在代理节点上再次ssh登录远程机器来编译代码，那么`executor`就应该选用`ssh`的方式。具体使用哪种方式取决于实际环境。\n\n注册成功后，在 **Runners** 列表刷新出刚刚新加的**Runner**，如下图：\n\n![runner-list](/post/deploygitlabcerunner/d954e9363c1c.png)\n\n上图中，点击左边的链接可以看到 **Runner** 的详情：\n\n![runner-details](/post/deploygitlabcerunner/1e90dd45eba5.png)\n\n点击右边的铅笔，可以修改Runner的参数设定：\n\n![runner-enable-untag](/post/deploygitlabcerunner/5329eafbdd66.png)\n\n这里我把`Run untagged jobs`复选框勾上，并保存修改。\n\n到这里整个**Runner**的配置基本就完成了。\n\n> Runner还有更多的配置，详情可以参考官方文档介绍。\n\n### 创建普通用户帐号[ #](#创建普通用户帐号)\n\n接着我们打开一个隐私页面，进入登录界面，这次我们点击`Register now`来新建用户，填写完用户信息后，注册一个新的用户，然后需要管理员在用户管理界面上进行批准，批准通过后，刚注册的用户就可以正常登录系统了，如下图（图中的用户已经新建了一个仓库）：\n\n![user-projects](/post/deploygitlabcerunner/279ae5d2774b.png)\n\n该普通用户帐户是开发者，后面测试CI/CD系统将以该用户进行测试。\n\n#### 创建仓库[ #](#创建仓库)\n\n新建仓库非常简单，只需点击`New project`后，填写项目基本信息即可：\n\n![new-project](/post/deploygitlabcerunner/e89af7df63df.png)\n\n#### 设置仓库的 gitlab-ci[ #](#设置仓库的-gitlab-ci)\n\n设置仓库根目录下的`.gitlab-ci.yml`文件，添加流水线任务。\n\n我写的非常简单，`script`指定编译命令，`only`指定在哪一个分支下进行CI部署（我指定的是：main分支），然后`tags`和注册**Runner**的`tags`一一对应的。\n\n> 关于`gitlab-ci.yml`文件的更多细节可以参考[官方文档](https://docs.gitlab.com/ee/ci/yaml/gitlab_ci_yaml.html)。\n\n#### 提交代码并进行 CI 操作[ #](#提交代码并进行-ci-操作)\n\n当一切都准备妥当后，下面就是写代码，并提交到远程仓库的main分支下：\n\n![git-push](/post/deploygitlabcerunner/fc979b40e6df.png)\n\n刚提交了代码，系统上立即显示流水线就已经在更新了。\n\n![pipelines](/post/deploygitlabcerunner/94be700a77c7.png)\n\n可以点开正在执行的流水，查看任务细节：\n\n![pipeline-success](/post/deploygitlabcerunner/121b5fa098bf.png)\n\n至此，这个**GitLab**的基本配置，和它的CI/CD流水配置，以及使用也已经完成，这套代码管理系统的实用性，总体来说还算不错的。\n\n## 具体配置[ #](#具体配置)\n\n以下两个文件是我的测试配置，仅供参考。\n\n### 我的测试配置[ #](#我的测试配置)\n\n`.gitlab-ci.yml`配置如下：\n\nyamlCopy\n\n```yaml\nstages:\n  - build\n\nbuild source:\n  stage: build\n  tags:\n    - linux\n  script:\n    - gcc -o main main.c\n  only:\n    - main\n  interruptible: true\n```\n\n`docker-compose.yml`配置如下：\n\nyamlCopy\n\n```yaml\nversion: \"3.0\"\n\nservices:\n  gitlab-web:\n    image: gitlab/gitlab-ce\n    restart: always\n    hostname: 'gitlab.me'\n    environment:\n      GITLAB_OMNIBUS_CONFIG: |\n        external_url 'http://gitlab.me:2080/'\n    ports:\n      - '2080:2080'\n      - '2443:443'\n    volumes:\n      - ./gitlab/config:/etc/gitlab\n      - ./gitlab/logs:/var/log/gitlab\n      - ./gitlab/data:/var/opt/gitlab\n    networks:\n      - gitlab\n\n  gitlab-runner:\n    image: gitlab/gitlab-runner:alpine\n    restart: always\n    depends_on:\n      - gitlab-web\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - ./gitlab/gitlab-runner:/etc/gitlab-runner\n    networks:\n      - gitlab\n\nnetworks:\n  gitlab:\n    name: gitlab-network\n```\n\n### 我遇到的坑[ #](#我遇到的坑)\n\n> 可能会碰到的坑：\n>\n> 1. `docker-compose.yml`文件中设置环境变量`GITLAB_OMNIBUS_CONFIG`中的`external_url`，如果域名带端口，docker的服务监听会绑定到该端口上；\n> 2. `gitlab-runner`的配置（config.toml），`runner.docker`节区下添加`network_mode`为`gitlab-network`以对应`docker-compose.yml`\n\n## 链接[ #](#链接)\n\n[how-to-install-gitlab-using-docker-compose](https://www.czerniga.it/2021/11/14/how-to-install-gitlab-using-docker-compose/)\n"}}