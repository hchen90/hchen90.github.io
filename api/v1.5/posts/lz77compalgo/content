{"code":0,"data":{"title":"LZ77压缩算法","content":"# LZ77压缩算法\n\n# LZ77算法简介[ #](#lz77算法简介)\n\nLZ77算法是一种无损压缩算法，最早由两位以色列人于1977发表，它是一种典型的字典型压缩算法，目前几乎大多数的无损压缩算法都是基于这个LZ77算法，也就是在其基础上优化修改，此算法可以称得上是无损压缩算法界的鼻祖了。\n\n> 参考维基百科[lz77](https://en.wikipedia.org/wiki/LZ77_and_LZ78)\n\n# 算法逻辑[ #](#算法逻辑)\n\nLZ77的算法核心就是一个滑动窗口，在滑动窗口里面搜索重复字节，并将匹配到的字节串用更短的字节串方式表示出来。\n\n这里涉及到几个要素：\n\n* 滑动窗口缓冲区\n* 滑窗的前部区域\n* 滑窗的已编码区域\n\n## 编码流程[ #](#编码流程)\n\n编码步骤：\n\n1. 首先分配一块缓冲区域用来处理数据\n2. 初始的前部区域为空\n3. 初始的已编码区域也为空\n4. 加载的字节流到前部区域，是否最后一个字节，是则进行第8步，否则继续第5步\n5. 在已编码区域寻找匹配字节串，如果找到进行第6步，否则进行第7步\n6. 将匹配到的第一个字节的相对位置和长度，标记到已编码区域中，继续第4步\n7. 将前部区域的字节直接拷贝到已编码区域，继续第4步\n8. 编码结束\n\n编码图示：\n\n当滑动窗口还没有处理数据时：\n\n![stepprecomp](/post/lz77compalgo/444d473374ac.png)\n\n当滑动窗口开始处理数据时：\n\n![stepcomp](/post/lz77compalgo/bbe2cf390348.png)\n\n当滑动窗口正在处理数据时：\n\n![stepcomping](/post/lz77compalgo/c2b4e19aa15f.png)\n\n当数据快要处理完时：\n\n![stepcompfin](/post/lz77compalgo/a2b9a5ac780a.png)\n\n整个过程如同字节流在这个滑动窗口的黑盒子里面流动过一样，然后，它被加工的数据是已经压缩的数据了。\n\n> 数据编码中，会涉及到如何标记数据，在lz77算法中是用2-3个字节来表示的，即：如果有两个自己是'\\0'，则表示它是一个直译字节，是直接拷贝过来的字节，这两个'\\0'后面的字节就是原始字节；否则，这两个字节是表示当前字节处应该填充的字节串应该在的相对位置和长度（你甚至可以为你自己的lz77编码器自定义数据标记方式）。\n\n## 解码流程[ #](#解码流程)\n\n解码的过程是编码过程的逆过程。\n\n解码步骤：\n\n1. 字节流是否是最后字节，是则进行第5步，否则进行第2步\n\n2. 从字节流获取两个字节，如果是`\\0x00\\0x00`则进行第3步，否则进行第4步\n\n3. 将`\\0x00\\0x00`后面的一个字节复制到输出缓存区域，继续加载字节流，继续第1步\n\n4. 从两个字节的编码中得到在滑动窗口的相对偏移和内容长度，把偏移处的内容拷贝到当前输出缓存，继续第1步\n\n5. 解码结束\n\n> 上面的输出缓存区域是指在字节处理位置处理过后的字节流存放的缓存区域就是输出缓存\n\n解码图示：\n\n滑动窗口还没有输入数据的时候：\n\n![stepuncomp](/post/lz77compalgo/327cac22a173.png)\n\n滑动窗口开始处理数据的时候：\n\n![stepuncomp](/post/lz77compalgo/0f3c09c33bfb.png)\n\n数据在滑动窗口中处理：\n\n![stepuncomping](/post/lz77compalgo/44818fe4e513.png)\n\n数据快要处理完的时候：\n\n![stepuncompfin](/post/lz77compalgo/a0e2f344a5e9.png)\n\n# 源码实现[ #](#源码实现)\n\n辅助函数：\n\ncCopy\n\n```c\nunsigned int search_maxlen_p( unsigned char**  pt, \\\n                              unsigned char* head, \\\n                              unsigned char* tail, \\\n                              unsigned char* end)\n{\n  unsigned char* tmp = *pt;\n  unsigned int leng = 0, i;\n\n  for(tmp;tmp >= head;tmp--){\n    if(tmp[0] == tail[0]){\n      for(i = 0;(i < ((1 << LENGTHBITS) - 1)) && (&tmp[i] > head) && (&tmp[i] < tail) && (&tail[i] < end) && (tmp[i] == tail[i]);i++);\n      if(i > leng){\n        leng = i;\n        *pt = tmp;\n      }\n    }\n  }\n  return leng;\n}\n```\n\n编码实现：\n\ncCopy\n\n```c\nint lz77_encode(FILE* in,FILE* out)\n{\n  unsigned char* buf = 0,* head = 0,* tail = 0;\n  long size = 0;\n\n  if(! in || ! out)return 1;\n\n  get_filesize(in,size); // get file size.\n  if(size <= 0)return 1;\n\n  buf = (unsigned char*)malloc(size* sizeof(unsigned char)); // allocate memory.\n  if(! buf)return 1;\n\n  if(fread(buf,sizeof(unsigned char),size,in) == size){\n    head = tail = buf;\n    fputc((size >> 24) & 0xff,out);\n    fputc((size >> 16) & 0xff,out);\n    fputc((size >>  8) & 0xff,out);\n    fputc((size >>  0) & 0xff,out);\n\n    for(;;){ // loop block.\n      head = tail - WINDOWSIZE;\n      if(buf  > head)head = buf;\n      if(tail > buf + size - 1)break;\n      if(tail > head){\n        unsigned char* pt = tail - 1;\n        unsigned int bytes = 0;\n        bytes = search_maxlen_p(&pt,head,tail,buf + size);\n        // search maximal matched bytes and position.\n        if(bytes > 0){\n          unsigned char chars[2] = {0};\n          chars[0] = (unsigned char)(( (tail - pt) >> LENGTHBITS) & 0xff);\n          chars[1] = (unsigned char)((((tail - pt) << LENGTHBITS) + bytes) & 0xff);\n          fputc(chars[0],out);\n          fputc(chars[1],out);\n          //fprintf(stderr,\"{%d - %d}\",tail - pt,bytes);\n          tail += bytes;\n        } else {\n          fputc(0,out);\n          fputc(0,out);\n          fputc(*tail,out);\n          tail++;\n        }\n      } else {\n        fputc(0,out);\n        fputc(0,out);\n        fputc(*tail,out);\n        tail++;\n      }\n    }\n\n  }\n\n  free(buf);\n  return 0;\n}\n```\n\n解码实现：\n\ncCopy\n\n```c\nint lz77_decode(FILE* in,FILE* out)\n{\n  unsigned char* nbuf = 0,* ori_buf = 0,* head = 0,* tail = 0;\n  long ori_size = 0,nsize = 0;\n\n  if(! in || ! out)return 1;\n\n  get_filesize(in,nsize); // get file size.\n  if(nsize <= 0)return 1;\n\n  ori_size  = (fgetc(in) & 0xff) << 24;\n  ori_size += (fgetc(in) & 0xff) << 16;\n  ori_size += (fgetc(in) & 0xff) <<  8;\n  ori_size += (fgetc(in) & 0xff) <<  0;\n  if(ori_size <= 0)return 1;\n\n  nbuf = (unsigned char*)malloc(nsize* sizeof(unsigned char));\n  if(! nbuf)return 1;\n\n  ori_buf = (unsigned char*)malloc(ori_size* sizeof(unsigned char));\n  if(ori_buf){\n    head = tail = ori_buf; // store head and tail of slide-window.\n\n    if(fread(nbuf,sizeof(unsigned char),nsize,in) == (nsize - 4)){\n      unsigned char* pt  = nbuf;\n\n      for(;;){\n        if(pt >= (nbuf + nsize - 4))break;\n        if(! pt[0] && ! pt[1] ){ // \\0\\0\\?\n          tail[0] = pt[2];\n          tail++;\n          pt += 3;\n        } else { // \\?\\?\n          unsigned int offset = 0,length = 0,i;\n          offset  =  pt[0] << LENGTHBITS;\n          offset += (pt[1] >> LENGTHBITS) & 0x0f;\n          length  =  pt[1] & 0x0f;\n          //fprintf(stderr,\"{%d - %d}\",offset,length);\n          for(i = 0;i < length;i++){\n            tail[i] = ((unsigned char*)(tail - offset))[i];\n          }\n          tail += length;\n          pt += 2;\n        }\n      }\n      fwrite(ori_buf,sizeof(unsigned char),ori_size,out);\n    }\n\n    free(ori_buf);\n  }\n\n  free(nbuf);\n  return 0;\n}\n```\n\n# 算法分析[ #](#算法分析)\n\n在分析此算法压缩的数据效率如何时，可以看到和数据的内容有关，若重复率比较高，而且间隔距离短的内容，可以得到比较理想的压缩率，但是对于重复率低的内容就不一定能达到理想的压缩率，最差的情况就是，要压缩的内容刚刚好在滑动窗口大小的缓存都没有重复内容，那么压缩出来的数据不仅没有变小，而且增大到原来的3倍。\n\n下图中的数据可以看到前面部分的非重复的数据就有许多的`\"\\0x00\\0x00\"`开头的直译复制过来的数据，这种数据过多就会导致压缩效率低下。\n\n![hexdat](/post/lz77compalgo/0ae608b93872.png)\n\n一般来说，用LZ77算法压缩过的数据，为了抵消上面的劣势，可以将用LZ77压缩的数据再用哈夫曼编码再次编码，这样输出的数据压缩效率就高一些了。\n\n链接：[Github上的代码](https://github.com/hchen90/lz77)\n"}}