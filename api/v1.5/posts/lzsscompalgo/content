{"code":0,"data":{"title":"LZSS压缩算法","content":"# LZSS压缩算法\n\n# LZSS算法简介[ #](#lzss算法简介)\n\nLZSS算法是LZ77算法的改良版，由James A. Storer和Thomas Szymacski于1982年发表在ACM杂志上。LZSS算法充分地利用了位的标记，从而使得压缩效率相比较于LZ77而言，有了显著提高。\n\n> 参考维基百科[lzss](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski)\n\n# 算法逻辑[ #](#算法逻辑)\n\n在看本篇博文之前，需要知道LZ77算法的大体流程，如果不清楚可以点击[这里](/2018/03/31/lz77compalgo)浏览。\n\nLZSS算法和LZ77算法的编码/解码流程逻辑是一致的，区别在于数据编码标记上，这里详细叙述一下LZSS的数据编码标记，可以看到它这种方式是如何显著提高压缩效率的。\n\n在LZSS算法的数据编码里面有一个重要概念，就是：数据分组。\n\n一个字节由8位组成，因此可以用一个字节来标记后面的至少8字节是否存在压缩编码，而不用`\\0x00\\0x00`的前缀来区分是否被压缩，从而节省了大量的`\\0x00\\0x00`前缀空间开销。\n\n数据分组标记方式：\n\n![databits](/post/lzsscompalgo/9c651b397128.png)\n\n> 由此看见，这种数据分组的方式，最坏的情况下，只会每8个字节增加一个字节的额外空间开销，比起每个字节另外需要2个字节的空间开销而言，效率大幅提升。\n\n# 源码实现[ #](#源码实现)\n\n辅助函数：\n\ncCopy\n\n```c\nunsigned int search_maxlen_p( unsigned char**  pt, \\\n                              unsigned char* head, \\\n                              unsigned char* tail, \\\n                              unsigned char* end)\n{\n  unsigned char* tmp = *pt;\n  unsigned int leng = 0, i;\n\n  for(tmp;tmp >= head;tmp--){\n    if(tmp[0] == tail[0]){\n      for(i = 0;(i < ((1 << LENGTHBITS) + 1)) && (&tmp[i] > head) && (&tmp[i] < tail) && (&tail[i] < end) && (tmp[i] == tail[i]);i++);\n      if(i > leng){\n        leng = i;\n        *pt = tmp;\n      }\n    }\n  }\n  return leng;\n}\n```\n\n编码实现：\n\ncCopy\n\n```c\nint lzss_encode(FILE* in,FILE* out)\n{\n  unsigned char* buf = 0,* head = 0,* tail = 0;\n  long size = 0;\n\n  if(! in || ! out)return 1;\n\n  get_filesize(in,size);\n  if(size <= 0)return 1;\n\n  buf = (unsigned char*)malloc(size* sizeof(unsigned char));\n  if(! buf)return 1;\n\n  if(fread(buf,sizeof(unsigned char),size,in) == size){\n    unsigned int  np      =  1 ,control_count = 0;\n    unsigned char suf[17] = {0}; // 2*8 + 1\n\n    fputc((size >> 24) & 0xff,out);\n    fputc((size >> 16) & 0xff,out);\n    fputc((size >>  8) & 0xff,out);\n    fputc((size >>  0) & 0xff,out);\n\n    head = tail = buf;\n\n    for(;;){\n      head = tail - WINDOWSIZE;\n      if(head < buf)head = buf;\n\n      if(control_count >= 8){\n        put_bytes(suf,np,out);\n        memset(suf,0,sizeof(suf));\n        np = 1;\n        control_count = 1;\n      } else {\n        control_count++;\n      }\n\n      if(tail > buf + size - 1)break;\n\n      if(head < tail){\n        unsigned int bytes = 0;\n        unsigned char* pt = tail - 1;\n        bytes = search_maxlen_p(&pt,head,tail,buf + size);\n        if(bytes > 2){ // if find a pattern more than 2 bytes, save its offset-length.\n          suf[0]  <<= 1;\n          suf[0]   |= OFFLENFLAG;\n          suf[np++] = (unsigned char)(( (tail - pt) >> LENGTHBITS) & 0xff);\n          suf[np++] = (unsigned char)((((tail - pt) << LENGTHBITS) + bytes - 2) & 0xff);\n          tail += bytes;\n        } else {\n          suf[0]  <<= 1;\n          suf[np++] = tail[0];\n          tail++;\n        }\n      } else {\n        suf[0]  <<= 1;\n        suf[np++] = tail[0];\n        tail++;\n      }\n\n    }\n\n    for(control_count;control_count <= 8;control_count++)suf[0] <<= 1; // must keep highest bit is aligned to first byte.\n    put_bytes(suf,np,out);\n  }\n\n  free(buf);\n\n  return 0;\n}\n```\n\n解码实现：\n\ncCopy\n\n```c\nint lzss_decode(FILE* in,FILE* out)\n{\n  unsigned char* in_buffer = 0,* out_buffer = 0,* head = 0,* tail = 0;\n  long in_size = 0,out_size = 0;\n\n  if(! in || ! out)return 1;\n\n  get_filesize(in,in_size);\n  if(in_size <= 0)return 1;\n\n  out_size  = (fgetc(in) & 0xff) << 24;\n  out_size += (fgetc(in) & 0xff) << 16;\n  out_size += (fgetc(in) & 0xff) <<  8;\n  out_size += (fgetc(in) & 0xff) <<  0;\n  if(out_size <= 0)return 1;\n\n  in_buffer = (unsigned char*)malloc(sizeof(unsigned char)* in_size);\n  if(! in_buffer)return 1;\n\n  out_buffer = (unsigned char*)malloc(sizeof(unsigned char)* out_size);\n  if(out_buffer){\n    if(fread(in_buffer,sizeof(unsigned char),in_size,in) == in_size - 4){\n      unsigned int  control_count = 0;\n      unsigned char control_flags = 0;\n      unsigned char*           pt = (unsigned char*)in_buffer;\n\n      head  = tail  = out_buffer;\n      control_flags = pt[0];\n      pt++;\n\n      for(;;){\n        if(pt >= (in_buffer + in_size - 4))break;\n\n        if(control_count >= 8){\n          control_flags = pt[0];\n          pt++;\n          control_count = 1;\n        } else {\n          control_count++;\n        }\n\n        if(control_flags >> 7){ // offset-length.\n          unsigned int offset = 0,length = 0,i;\n          offset  =  pt[0] << LENGTHBITS;\n          offset += (pt[1] >> LENGTHBITS) & 0x0f;\n          length  = (pt[1] & 0x0f) + 2;\n          for(i = 0;i < length;i++){\n            tail[i] = ((unsigned char*)(tail - offset))[i];\n          }\n          tail += length;\n          pt += 2;\n          control_flags <<= 1;\n        } else { // literal.\n          tail[0] = pt[0];\n          tail++;\n          pt++;\n          control_flags <<= 1;\n        }\n      }\n      fwrite(out_buffer,sizeof(unsigned char),out_size,out);\n\n    }\n    free(out_buffer);\n  }\n\n  free(in_buffer);\n\n  return 0;\n}\n```\n\n# 算法分析[ #](#算法分析)\n\n经过LZSS压缩的数据，已经算得上很不错的了，可见下图的十六进制展示：\n\n![hexdat](/post/lzsscompalgo/6db6b2ec019e.png)\n\n但是，这里面的数据还有进一步空间优化，可以使用LZ77算法博文里面提到的哈夫曼编码进一步编码，就可以得到理想的压缩效果。\n\n链接：[Github上的代码](https://github.com/hchen90/lzss)\n"}}