{"code":0,"data":{"title":"软件设计模式 - 行为模式","content":"# 软件设计模式 - 行为模式\n\n# 软件设计模式 - 行为模式[ #](#软件设计模式---行为模式)\n\n行为模式负责对象之间的高效沟通和职责委派。\n\n行为模式包括：责任链，命令，迭代器，中介者，备忘录，观察者，状态，策略，模版方法，访问者。\n\n## 责任链模式（Chain of Responsibility/CoR）[ #](#责任链模式chain-of-responsibilitycor)\n\n责任链模式允许你将请求沿着处理者链进行传递。每个节点上的处理者收到请求后，可对请求进行处理，或者将请求继续传递给链上的下个处理者。\n\n例如：\n\n![CoR](/post/softwaredesignpattern4/3bd87b0f387e.png)\n\n这里只是两级责任链。\n\n示例代码：\n\ncppCopy\n\n```cpp\nclass Handler {\npublic:\n    void handle() = 0;\n};\n\nclass BasicHandler : public Handler {\npublic:\n    void handle() {\n        // TODO: 进行第一级必要处理\n        if (okay && next != nullptr) {\n            next(); // 转上级责任链节点处理\n        }\n    }\n    void setNext(Handler& hdr) {\n        next = hdr\n    }\nprivate:\n    Handler next;\n};\n\nclass SecondHandler : public Handler {\npublic:\n    void handle() {\n        // TODO: 进行必要处理\n    }\n    // 最后一级不必设置next\n    // void setNext(Handler& hdr) {\n    //     next = hdr\n    // }\nprivate:\n    // Handler next;\n};\n```\n\n## 命令模式（Command）[ #](#命令模式command)\n\n命令模式将请求转换成包含与请求相关的所有信息的独立对象，并且对象存放在队列中，队列元素可以进行撤销操作。\n\n这里以编辑器软件的设计为例，如下：\n\n![Command](/post/softwaredesignpattern4/864e9e18f296.png)\n\n示例代码：\n\ncppCopy\n\n```cpp\nclass Command {\npublic:\n    void execute() = 0;\n};\n\n// 打开文件\nclass OpenCommand : public Command {\npublic:\n    void execute() {\n        // 进行打开文件操作\n    }\n};\n\n// 保存文件\nclass SaveCommand : public Command {\npublic:\n    void execute() {\n        // 进行保存文件操作\n    }\n};\n\n// 打印文件\nclass PrintCommand : public Command {\npublic:\n    void execute() {\n        // 进行文件打印的操作\n    }\n};\n```\n\n此外还需要一个命令队列机制：\n\ncppCopy\n\n```cpp\n// 命令队列\nclass CommandQueue {\npublic:\n    void push(Command&) {\n        // 命令入列\n    }\n    Command pop() {\n        // 命令出列\n    }\n};\n```\n\n命令队列用于存储命令，并且队列的进出使用一定的调度算法：\n\ncppCopy\n\n```cpp\nCommandQueue cq(10);\n\n// 可以根据具体的调度方式，这里使用定时器来调度\nwhile (true) {\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    auto cmd = cq.pop();\n    cmd.execute();\n}\n```\n\n如果要进行撤销操作，只需推出队列元素不用执行即可：\n\ncppCopy\n\n```cpp\ncq.pop();\n```\n\n如果创建菜单打开操作，只需要如下：\n\ncppCopy\n\n```cpp\nauto openCmd = new OpenCommand();\nauto menuOpen = new Menu(\"Open\");\nmenuOpen.action = [openCmd](){\n    cq.push(openCmd); // 发送打开命令进入队列\n};\n```\n\n## 迭代器模式（Iterator）[ #](#迭代器模式iterator)\n\n迭代器模式的目的是为了不暴露集合的底层的前提下，让外部仍然可以遍历集合中的所有元素。\n\n结构如下：\n\n![Iterator](/post/softwaredesignpattern4/bab81b954a9e.png)\n\n首先定义一个集合：\n\ncppCopy\n\n```cpp\n// 迭代器\nclass Iterator {\npublic:\n    Iterator next() = 0;\n};\n\nclass Item : public Iterator {\npublic:\n    Item next() {\n        // 下一个元素\n    }\n};\n\n// 迭代器集合\nclass IteratorCollection {\npublic:\n    Iterator create(Iterator) = 0;\n    Iterator begin() = 0;\n    Iterator end() = 0;\n};\n\nclass Collection : public IteratorCollection {\npublic:\n    Iterator create(Iterator) {\n        // 建立一个迭代器\n    }\n    Iterator begin() {\n        // 返回第一个迭代器\n    }\n    Iterator end() {\n        // 返回最后一个迭代器\n    }\n};\n```\n\n迭代器集合构造可以如下：\n\ncppCopy\n\n```cpp\nCollection collection;\nItem empty;\nfirst = collection.create(empty);\nsecond = collection.create(first);\nthird = collection.create(second);\n```\n\n对于迭代器集合的构造，方式多样，可以如上面通过函数逐个构造，也可以通过构造函数进行构造。\n\ncppCopy\n\n```cpp\nCollection collection([1,2,3,4,5,6,7,8]);\n```\n\n使用迭代器集合来访问迭代器元素：\n\ncppCopy\n\n```cpp\nfor (auto it = collection.begin(); it != collection.end(); it = it.next()) {\n    // 访问迭代器元素it\n}\n```\n\n## 中介者模式（Mediator）[ #](#中介者模式mediator)\n\n中介者模式是为了减少对象之间混乱无序的依赖关系，该模式会限制对象之间的直接交互，而是使用一个中介对象作为交互者。\n\n假设在一个表单UI交互设计的场景下，用户可以填写姓名，出生日期，性别等信息，每一栏信息的更新也会触发其他UI栏目的元素变化，例如：填写完出生日期会触发表单中年龄更新，如果所有的UI控件元素之间直接交互来更新，那么这将导致最终的混乱。如果使用中介者就可以避免这种混乱的发生。\n\n![Mediator](/post/softwaredesignpattern4/1decbdf92c84.png)\n\n如上图，更改出生日期后，更新年龄，使用中介者就避免了直接调用导致的混乱。\n\ncppCopy\n\n```cpp\nclass Mediator {\npublic:\n    void notify(int type, std::string param) = 0;\n    bool registerObject() = 0;\n};\n\nclass UserInformation {\npublic:\n    void notify(int type, std::string param) {\n        // 根据type不同，通知不同的对象进行UI更新\n    }\n    bool registerObject() {\n        // 注册UI对象\n    }\nprivate:\n    std::vector<UIObject> objects;\n};\n```\n\n使用时，内存环境维持一个唯一的用户信息，这样定义：\n\ncppCopy\n\n```cpp\nUserInformation info;\ninfo.registerObject(userNameLabel);\ninfo.registerObject(birthLabel);\ninfo.registerObject(ageLabel);\n// ...\n```\n\n用户触发了UI控件的值修改：\n\ncppCopy\n\n```cpp\ninfo.notify(123, \"1975-02-12\"); // 假设123为更新出生日期的事件，参数是更新后的日期\n```\n\n## 备忘录模式（Memento）[ #](#备忘录模式memento)\n\n备忘录模式允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态.\n\n在编辑器软件中一般都支持操作的撤销与恢复，实现如下：\n\n![Memento](/post/softwaredesignpattern4/adea908520cc.png)\n\n如图中，文档打开时由一个初始原发器构成，下一步的快照基于该原发器，以此类推，然后，快照由一个快照列表构成来存储管理，代码如下：\n\ncppCopy\n\n```cpp\nclass Memento {\npublic:\n    void restore() = 0;\n};\n\nclass Originator {\npublic:\n    Memento* save() = 0;\n};\n\nclass Snapshot : public Memento {\npublic:\n    Snapshot(Memento* m, int s) {\n        originator = m;\n        state = s;\n        // 存储操作状态\n    }\n    void restore() {\n        // 恢复操作状态\n    }\n};\n\nclass Initial : public Originator {\npublic:\n    void setState(int state) {\n        this->state = state;\n    }\n    Memento* save() {\n        return Snapshot(this, state);\n    }\nprivate:\n    int state;\n};\n```\n\n定义管理器，用于管理快照，创建和恢复快照：\n\ncppCopy\n\n```cpp\nstd::vector<Snapshot*> snapshots;\n// 初始原发器\nInitial init;\ninit.setState(0);\n// 保存快照\nSnapshot* s1 = new Snapshot(init, 1);\nsnapshots.push_back(s1);\n// 恢复快照\nauto s = snapshots.pop_back();\ns->restore();\n```\n\n## 观察者模式（Observer）[ #](#观察者模式observer)\n\n观察者模式是一种发布订阅机制，允许当对象状态发生改变时，通知多个其他的“观察”对象。\n\n这里以代码编辑器为例，代码编辑器不仅是文本编辑器，同时支持基于代码文本的语法加亮，自动缩进，括号自动匹配等功能。\n\n![Observer](/post/softwaredesignpattern4/9d980a98bd2d.png)\n\n代码实现如下：\n\ncppCopy\n\n```cpp\nclass EventListener {\npublic:\n    void update() = 0;\n};\n\nclass Highlight : public EventListener {\npublic:\n    void update() {\n        // 更新语法高亮\n    }\n};\n\nclass AutoIndent : public EventListener {\npublic:\n    void update() {\n        // 更新自动缩进\n    }\n};\n\nclass AutoBracket : public EventListener {\npublic:\n    void update() {\n        // 更新括号匹配\n    }\n};\n\nclass EventManager {\npublic:\n    void subscribe(int type, EventListener* listener) {\n        auto it = listeners[type];\n        if (it == nullptr) {\n            it = initListenerList(); // 初始化监听者列表\n            listeners.insert(std::make_pair(type, it));\n        }\n        it->push_back(listener); // 添加监听者\n    }\n    void unsubscribe(int type, EventListener* listener) {\n        auto it = listeners[type];\n        if (it == nullptr) return;\n        if (find_if(it, listener)) { // 查找监听者\n            it = remove_if(it, listener); // 删除\n            listeners[type] = it;\n        }\n    }\n    void notify(int type, DataFrame* data) {\n        // 遍历所有监听该事件的监听者并发送通知\n        auto it = listeners[type];\n        if (it == nullptr) return;\n        for (l := it->begin(); l != it->end(); l = l->next()) {\n            l->update(); // 通知事件\n        }\n    }\nprivate:\n    std::map<int, ListenerList*> listeners;\n};\n\nclass Editor {\npublic:\n    Editor() {}\nprivate:\n    EventManager eventMgr;\n};\n```\n\n## 状态模式（State）[ #](#状态模式state)\n\n状态模型是指一个对象的状态发生变化后，它的行为也会发生改变。其主要思想是有限状态机的原理。\n\n空调恒温系统是一个最简单的状态机，如下图：\n\n![State Machine](/post/softwaredesignpattern4/7a92462341cc.png)\n\n对于状态模型的类定义如下：\n\n![State](/post/softwaredesignpattern4/daa6b086d079.png)\n\n代码如下：\n\ncppCopy\n\n```cpp\nclass AirConditionerState {\npublic:\n    AirConditionerState() {\n        // 初始化状态转换表\n        transits.insert(compound(STATE_START, SYM_RDY), STATE_ON);\n        transits.insert(compound(STATE_ON, SYM_BELOW), STATE_WAIT);\n        // ...\n    }\n    void transit(int cur) { // 转换函数\n        auto sym = cur > 26 ? SYM_ABOVE : SYM_BELOW;\n        auto key = compound(state, sym);\n        auto val = transits.find(key);\n        state = val;\n    }\nprivate:\n    int state;\n    std::map<int, int> transits;\n\n    inline int compound(int state, int symbol) {\n        return state | (symbol << 16);\n    }\n};\n```\n\n每次调用时，只需将当前的温度作为`transit()`函数的参数传入，函数会根据状态和符号在状态表中切换状态。\n\n> 状态机原理\n>\n> > 状态机原理是由符号表，状态表，转移函数，以及开始和结束，简单可以用一句话以概括：状态机通过符号表的符号在转移函数上切换状态表中的不同状态。状态机分为有穷状态机和无穷状态机，无穷状态机的状态表大小不同于有穷状态机，无穷状态机可存在无限个状态。有穷状态机在编译技术的词法分析和构造形式化语法分析都会用到。\n\n## 策略模式（Strategy）[ #](#策略模式strategy)\n\n策略模式能够实现一种算法自定义的功能。例如，如果现在有一款软件支持机器学习，为了使用它，我们需要进行模型选择并加以训练，以用于后续的实际预测。这里的模型即可以抽象化为策略，对于不同的模型选择，即为对不同的策略选择。\n\n![Strategy](/post/softwaredesignpattern4/efdffe0eb9a6.png)\n\n代码实现：\n\ncppCopy\n\n```cpp\nclass Strategy {\npublic:\n    void train() = 0;\n    void predict() = 0;\n};\n\nclass LinearRegression : public Strategy {\npublic:\n    void train() {\n        // 线性回归训练\n    }\n    void predict() {\n        // 线性回归预测\n    }\n};\n\nclass DecisionTree : public Strategy {\npublic:\n    void train() {\n        // 决策树训练\n    }\n    void predict() {\n        // 决策树预测\n    }\n};\n\nclass Forest : public Strategy {\npublic:\n    void train() {\n        // 森林训练\n    }\n    void predict() {\n        // 森林预测\n    }\n};\n\nclass NeuralNetwork : public Strategy {\npublic:\n    void train() {\n        // 神经网络训练\n    }\n    void predict() {\n        // 神经网络预测\n    }\n};\n\nclass AIDecision {\npublic:\n    void setStrategy(Strategy* s) {\n        strategy = s;\n        scheduleTrain();\n    }\n    void decisionPredict() {\n        strategy->predict();\n    }\nprivate:\n    Strategy* strategy;\n};\n```\n\n调用者使用，如下：\n\ncppCopy\n\n```cpp\nAIDecision ai;\n\n// 使用神经网络模型的策略进行预测\nauto stra = new NeuralNetwork();\nai.setStrategy(stra);\nai.decisionPredict();\n```\n\n## 模版方法模式（Template Method）[ #](#模版方法模式template-method)\n\n模版方法是在超类中定义一套算法框架，继承该超类的子类可以在不修改结构的情况下重写算法的特定步骤。\n\n例如，编辑器软件中，可以将基本操作方法设计为超类，但是对于不同类型的文件处理方式，子类可以重写方法实现特定文件的操作。\n\n![Template Method](/post/softwaredesignpattern4/11d0af43cb52.png)\n\n代码如下：\n\ncppCopy\n\n```cpp\nclass BasicEditor {\npublic:\n    void open() {\n        // 打开文件\n    }\n    void load() {\n        // 加载文件数据\n    }\n    void close() {\n        // 关闭文件\n    }\n    void save() {\n        // 保存文件\n    }\n    void find() {\n        // 查找文件\n    }\n    void undo() {\n        // 恢复\n    }\n    void redo() {\n        // 重做\n    }\n    void goto_() {\n        // 光标偏移\n    }\n    void select() {\n        // 文本选择\n    }\n};\n\nclass RtfEditor : public BasicEditor {\npublic:\n    void load() {\n        // 富文本数据加载\n    }\n};\n\nclass DocEditor : public BasicEditor {\npublic:\n    void load() {\n        // Doc文档加载\n    }\n};\n\nclass PdfEditor : public BasicEditor {\npublic:\n    void load() {\n        // Pdf文档数据加载\n    }\n    void save() {\n        // 不支持保存，Pdf只支持查看，不能更改\n    }\n    void undo() {\n        // 不支持保存，Pdf只支持查看，不能更改\n    }\n    void redo() {\n        // 不支持保存，Pdf只支持查看，不能更改\n    }\n};\n```\n\n## 访问者模式（Visitor）[ #](#访问者模式visitor)\n\n访问者模式是把算法和访问对象隔离开来的方式。\n\n这种方式下，访问对象不需要任何更新，同时可以达到对象属性访问能力。\n\n![Visitor](/post/softwaredesignpattern4/a8db09ca9457.png)\n\n上图中，实现的是通过访问者模式从应用程序的菜单和工具栏获取图标图片的示例。\n\ncppCopy\n\n```cpp\nclass CtrlItem {\npublic:\n    Image* image() = 0;\n};\n\nclass ToolbarItem : public CtrlItem {\npublic:\n    Image* image() {\n        // 返回图标图片\n    }\n};\n\nclass MenuItem : public CtrlItem {\npublic:\n    Image* image() {\n        // 返回图标图片\n    }\n};\n\nclass Visitor {\npublic:\n    Image* visit(ToolbarItem*) = 0;\n    Image* visit(MenuItem*) = 0;\n};\n\nclass ImageVisitor : public Visitor {\npublic:\n    Image* visit(ToolbarItem* item) {\n        return item->image();\n    }\n    Image* visit(MenuItem* item) {\n        return item->image();\n    }\n};\n```\n\n使用访问者模式如下：\n\ncppCopy\n\n```cpp\nToolbarItem* item1 = new ToolbarItem(\"a.png\");\nToolbarItem* item2 = new ToolbarItem(\"b.png\");\nMenuItem* item3 = new MenuItem(\"c.png\");\n\nImageVisitor visitor;\nauto image1 = visitor.visit(item1);\nauto image2 = visitor.visit(item2);\nauto image3 = visitor.visit(item3);\n```\n"}}