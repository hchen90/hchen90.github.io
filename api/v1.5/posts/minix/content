{"code":0,"data":{"title":"如何将处于虚拟机中的MINIX系统中的文件复制到实体机的LINUX系统中来","content":"# 如何将处于虚拟机中的MINIX系统中的文件复制到实体机的LINUX系统中来\n\n## 问题来源[ #](#问题来源)\n\n直接在虚拟机MINIX中阅读它的源代码，十分不便，修改调试做移植也非常困难，如果将MINIX系统中的部分源代码拷贝到实体机LINUX中，在LINUX系统中进行修改调试将会非常方便。\n\n然而，MINIX系统是一种比较基本的系统，不能像vmware中使用Windows类系统那样，直接给它装VMTools（因为缺失XWindows，虽然理论上可以给MINIX装个XWindows，但是，太麻烦，而且仅仅为了几个源代码，有点大途小用）。因为vmware的磁盘文件（`.vmdk`）不是原始的磁盘数据文件，而且，vmware对据如MINIX这些生僻系统的文件系统的识别性不是太理想，造成用vmware无法挂载MINIX系统到实体主机上，仍然复制不到虚拟机中的MINIX的文件。\n\n所以，我选择使用qemu，qemu的磁盘是原始数据文件，可以在LINUX直接挂载到系统文件树上（只要LINUX能够识别这个文件系统）。\n\n## 软件和系统准备[ #](#软件和系统准备)\n\n* MINIX系统：`minix_R3.2.0-116fcea.iso`\n* QEMU: `qemu-system-i386`\n\n## 步骤[ #](#步骤)\n\n下载好MINIX的ISO文件，在LINUX中启动qemu，把MINIX装好，命令如下:\n\nbashCopy\n\n```bash\nqemu-system-i386 -enable-kvm -sdl -cdrom minix_R3.2.0-116fcea.iso -hda minix.img\n```\n\n> 如果还没有准备minix.img的磁盘镜像，可以用`qemu-img create minix.img 2G`，或`touch minix.img && truncate minix.img --size=2G`，来生成它。\n\nMINIX装好后，还需要准备一个备用的虚拟磁盘镜像，假如为`a.img`。这个磁盘就是用来存储需要的代码文件的，磁盘镜像创建好了以后，不要急着在LINUX中对它分区格式化等，这个操作应该在虚拟机中的MINIX系统里来完成。\n\n当`minix.img`和`a.img`都准备好后，就可以再启动虚拟机来拷贝文件了：\n\nbashCopy\n\n```bash\nqemu-system-i386 -enable-kvm -sdl -hda minix.img -hdb a.img\n```\n\n> 这里的`minix.img`是通过上一步，已经在里面装好了MINIX系统了。\n\nQEMU虚拟机开启后，进入MINIX系统，输入`root`来登录，到了MINIX系统中，因为MINIX的设备组织方式和LINUX系统有所不同，它的磁盘格式通常为据如`c0d0p0`等这样的形式，第一个'c'表示'Controller'，数字表示序号，第三个'd'表示'Disk'，后面的'p'表示'Partition'，还有's'表示'Subpartition'，可以用`man dev`来查看一下，里面介绍的很详细。\n\n可以用`df`来判断系统的minix.img所占的是哪个磁盘，这时，虽然`a.img`已经连到了MINIX系统，但是还没有找到它在哪。首先，排除minix.img所占的哪个盘，假定为`c0d0`，这种已经挂载了的盘，若用`mount`来挂载的话，会显示忙而无法挂载，其中光驱一般是`c0d2`盘，可以试一试挂载`c0d1`盘，如下：\n\nbashCopy\n\n```bash\nmount /dev/c0d1 /mnt\n```\n\n注意它报出的是什么错误，如果显示为不存在的设备或地址的错误，就接着试下一个，比如`c0d3`，直到有个不再报这个错误的磁盘，依照上面的假设，这里要除掉`c0d0`和`c0d2`，假如`c0d1`不报这个不存在设备或地址的错误，那就说明`a.img`就是这个设备。\n\n在MINIX中，用`fdisk`来给它分区，如下：\n\nbashCopy\n\n```bash\nfdisk /dev/c0d1\n```\n\n在fdisk工具中，可以用`c`命令来修改分区信息，修改好后，用`w`命令来保存这些分区信息到`a.img`的镜像上。\n\n`a.img`被分区好后，还要用`mkfs`来进行文件系统的格式化，**注意，这里一定要选择用`ext2`的文件格式，因为`ext2`在MINIX和LINUX中，都能较好的支持**，命令如下：\n\nbashCopy\n\n```bash\n/sbin/mkfs.ext2 /dev/c0d1\n```\n\n而后，`c0d1`就变成了可以挂载的设备了，可以用mount来挂载:\n\nbashCopy\n\n```bash\nmount /dev/c0d1 /mnt\n```\n\n挂载后，转到`/mnt`目录，把自己要复制的文件，全部拷贝到这里。完了以后，卸载挂载点，关虚拟机。\n\n现在，回到了LINUX系统中，`a.img`已经有刚才拷贝的文件了，我们只需要把`a.img`当作设备来进行挂载即可：\n\nbashCopy\n\n```bash\nsudo mount -t ext2 a.img /mnt\n```\n\n> 普通用户前面加`sudo`来升权，root用户无需加`sudo`。\n\n再转到`/mnt`中，文件是不是都在这。\n\n> 这个方法，是QEMU的文件复制通用方法，前提是虚拟机系统和实体主机系统都支持一种相同的文件系统，然后用这个共同的文件系统来作为传输媒介。\n"}}