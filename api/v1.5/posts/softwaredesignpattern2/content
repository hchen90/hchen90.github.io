{"code":0,"data":{"title":"软件设计模式 - 创建型模式","content":"# 软件设计模式 - 创建型模式\n\n# 软件设计模式 - 创建型模式[ #](#软件设计模式---创建型模式)\n\n创建型模式分为：工厂方法，抽象工厂，生成器，原型，单例。\n\n## 工厂方法模式（Factory Method）[ #](#工厂方法模式factory-method)\n\n工厂方法模式是**一种在父类声明方法，在子类实例化该对象的方法**。在C++中通常以虚函数形式来表示，在其他语言，例如Java中则是抽象函数来表示。\n\n工厂方法模式中更加关注目标“产品”本身，一般使用统一的接口来实例化对象的属性。\n\n例如一个图形绘制的场景应用，对于夫类，我们只关注高层次需求（图形的绘制），这里的对应为图形，结构如下：\n\n![Factory Method - Graphics](/post/softwaredesignpattern2/7f1ca2472da5.png)\n\n定义代码如下：\n\ncppCopy\n\n```cpp\nclass Graphics {\n    // 抽象夫类\nprotected:\n    virtual void paint() = 0;\n};\n```\n\n夫类（图形类）是一个抽象的高层次类，我们如果绘制不同的具体图形，可以这样定义：\n\ncppCopy\n\n```cpp\nclass Triangle : public Graphics {\n    // 绘制三角形的类\nprotected:\n    void paint() override {\n        // TODO: 绘制三角形\n    }\n};\n\nclass Circle : public Graphics {\n    // 绘制圆形的类\nprotected:\n    void paint() override {\n        // TODO: 绘制圆形\n    }\n};\n```\n\n这样以来，如果我们要绘制圆形，即可声明一个`Circle`类的对象，调用通用的`paint()`即可完成圆的图形绘制，其他各种不同的图形的绘制都是如此，从而大大降低了理解成本，我们只需关注“产品”即可（圆`Circle`）。\n\n## 抽象工厂模式（Abstract Factory）[ #](#抽象工厂模式abstract-factory)\n\n抽象工厂是一种**无需指定具体要实例化的类的方法**，它关注的是构造对象的不同“风格”，通常一个工厂可以构造大于一个的不同“产品”。\n\n举例如下，仍然以上面的绘图为例，不过现在我们要绘制特殊风格的图形，它们有的是刷子，有的是铅笔，有的是蜡笔，或者是混色器，结构如下：\n\n![Abstract Factory - Graphics](/post/softwaredesignpattern2/61bbb9c0a974.png)\n\n这里定义了四种风格的图形绘制工厂，每种工厂使用通过的接口绘制不同的图形（可以构造三种不同的“产品”）。\n\n代码定义如下：\n\ncppCopy\n\n```cpp\nclass GraphicsFactory {\n    // 夫类\nprotected:\n    virtual void paintTriangle() = 0;\n    virtual void paintCircle() = 0;\n    virtual void paintSquare() = 0;\n};\n\nclass BrushFactory {\n    // 刷子绘制工厂\nprotected:\n    void paintTriangle() override {\n        // TODO: 绘制三角形\n    }\n    void paintCircle() override {\n        // TODO: 绘制圆形\n    }\n    void paintSquare() override {\n        // TODO: 绘制方块\n    }\n};\n\nclass PencilFactory {\n    // 铅笔绘制工厂\nprotected:\n    void paintTriangle() override {\n        // TODO: 绘制三角形\n    }\n    void paintCircle() override {\n        // TODO: 绘制圆形\n    }\n    void paintSquare() override {\n        // TODO: 绘制方块\n    }\n};\n\nclass PastelFactory {\n    // 蜡笔绘制工厂\nprotected:\n    void paintTriangle() override {\n        // TODO: 绘制三角形\n    }\n    void paintCircle() override {\n        // TODO: 绘制圆形\n    }\n    void paintSquare() override {\n        // TODO: 绘制方块\n    }\n};\n\nclass BlendFactory {\n    // 混色器绘制工厂\nprotected:\n    void paintTriangle() override {\n        // TODO: 绘制三角形\n    }\n    void paintCircle() override {\n        // TODO: 绘制圆形\n    }\n    void paintSquare() override {\n        // TODO: 绘制方块\n    }\n};\n```\n\n这样以来，我们要铅笔风格地绘制三角形，则无需在关注三角形类，其他类似。\n\ncppCopy\n\n```cpp\nPencilFactory pFactory;\npFactory.paintTriangle(); // 铅笔绘制三角形\npFactory.paintCircle(); // 铅笔绘制圆形\nBrushFactory bFactory;\nbFactory.paintCircle(); // 刷子绘制圆形\nbFactory.paintSquare(); // 刷子绘制方块\n```\n\n## 生成器模式（Builder）[ #](#生成器模式builder)\n\n生成器模式是**一种分步创建复杂对象的方法**，它允许我们灵活定制化地创建对象的各个组成部分。\n\n生成器的构造模式是繁复地调用各个接口进行特定的初始化工作，用以设置对象的属性变量，初始化完了之后，再调用一个生成函数（`build()`），产生目标对象。\n\n以绘图为例：\n\n![Builder - Graphics](/post/softwaredesignpattern2/cd999fa23714.png)\n\n这里定义了三种绘制风格，使用生成器时，只需初始化特定的风格图形，最后调用生成接口（`paint()`），即可绘制出目标图形。\n\n代码如下：\n\ncppCopy\n\n```cpp\nclass Builder {\n    Builder& triangleBrush() {\n        // TODO: 添加刷子绘制三角形\n        return *this;\n    }\n    Builder& circleBrush() {\n        // TODO: 添加刷子绘制圆形\n        return *this;\n    }\n    Builder& squareBrush() {\n        // TODO: 添加刷子绘制方块\n        return *this;\n    }\n\n    Builder& trianglePencil() {\n        // TODO: 添加铅笔绘制三角形\n        return *this;\n    }\n    Builder& circlePencil() {\n        // TODO: 添加铅笔绘制圆形\n        return *this;\n    }\n    Builder& squarePencil() {\n        // TODO: 添加铅笔绘制方块\n        return *this;\n    }\n\n    Builder& trianglePastel() {\n        // TODO: 添加蜡笔绘制三角形\n        return *this;\n    }\n    Builder& circlePastel() {\n        // TODO: 添加蜡笔绘制圆形\n        return *this;\n    }\n    Builder& squarePastel() {\n        // TODO: 添加蜡笔绘制方块\n        return *this;\n    }\n\n    void paint() {\n        // TODO: 生成函数\n    }\n};\n```\n\n如果需要绘制复杂图形，使用生成器模式，可以这样：\n\ncppCopy\n\n```cpp\nBuilder builder;\nbuilder.circlePastel() // 初始化圆形\n       .squareBrush() // 初始化方块\n       .trianglePencil() // 初始化三角形\n       .paint() // 生成\n```\n\n## 原型模式（Prototype）[ #](#原型模式prototype)\n\n一般来说，对象是通过类的定义来获取的，但是如果我们不知道类，只是想**通过对象来克隆一个新的对象**，并延用对象的一些属性，这种方式就是原型模式。\n\n注意到，对象的克隆可以屏蔽类的复杂细节问题，对象的克隆可以是公有的属性方法或变量，也可以是保护的或私有的属性方法和变量，这样克隆才可以把原来的对象属性最大可能复制出去。\n\n![Prototype - Graphics](/post/softwaredesignpattern2/3716ab58195a.png)\n\n实例代码如下：\n\ncppCopy\n\n```cpp\nclass ShapeGraphics {\n    // 形状\npublic:\n    ShapeGraphics() : mX(0), mY(0), mColor(0) {}\n    ShapeGraphics(int x, int y, int cr)\n        : mX(x), mY(y), mColor(cr)\n    {}\n    ShapeGraphics(const ShapeGraphics& shape) {\n        this->mX = shape.mX;\n        this->mY = shape.mY;\n        this->mColor = shape.mColor;\n    }\n    virtual ShapeGraphics* clone() = 0;\nprivate:\n    int mX, mY, mColor;\n};\n\nclass CircleGraphics : public ShapeGraphics {\n    // 圆形\npublic:\n    CircleGraphics(const CircleGraphics& source)\n        : ShapeGraphics(source)\n    {\n        this.mRadius = source.mRadius;\n    }\n    ShapeGraphics* clone() {\n        return new CircleGraphics(*this);\n    }\nprivate:\n    int mRadius;\n};\n\nclass TriangleGraphics : public ShapeGraphics {\n    // 三角形\npublic:\n    TriangleGraphics(const TriangleGraphics& source)\n        : ShapeGraphics(source)\n    {\n        this->mA = source.mA;\n        this->mB = source.mB;\n        this->mC = source.mC;\n    }\n    ShapeGraphics* clone() {\n        return new TriangleGraphics(*this);\n    }\nprivate:\n    int mA, mB, mC;\n};\n\nclass SquareGraphics : public ShapeGraphics {\n    // 方块\npublic:\n    SquareGraphics(const SquareGraphics& source)\n        : ShapeGraphics(source)\n    {\n        this->mWidth = source.mWidth;\n        this->mHeight = source.mHeight;\n    }\n    ShapeGraphics* clone() {\n        return new SquareGraphics(*this);\n    }\nprivate:\n    int mWidth, mHeight;\n};\n```\n\n使用原型模式进行构造对象，代码用法如下：\n\ncppCopy\n\n```cpp\nclass CustomShape : public ShapeGraphics {\n    CustomShape() : ShapeGraphics(10, 10, 0xff00) {}\n    ShapeGraphics* clone() {\n        return new CustomShape(*this);\n    }\n};\n\nCustomShape shape; // 坐标（10,10），颜色 0xff00\nauto newshape = shape.clone(); // 克隆形状\nSquareGraphics square(*newshape); // 构造一个基于newshape克隆体属性的对象\nauto newsquare = square.clone(); // 新的克隆体方块，拥有square的属性\n```\n\n## 单例模式（Singleton）[ #](#单例模式singleton)\n\n单例是一种特殊的构造模式，它构造的对象在运行时只存在一个全局实例。\n\n单例通常用于中心控制，集中配置的地方，这样满足信息一致性，调控一致性等问题。\n\n实例代码如下：\n\ncppCopy\n\n```cpp\nclass Singleton {\n    // 单例\npublic:\n    static Singleton& getInstance() {\n        // 声明类的静态变量\n        static Singleton inst;\n        return inst;\n    }\nprivate:\n    Singleton() {}\n};\n```\n\n上面定义了一个单例类，它是无法用类实例化的，而是通过静态变量和函数来达到对象获取和声明的功能。\n\n使用方法如下：\n\ncppCopy\n\n```cpp\nauto inst = Singleton::getInstance(); // 获取单例\n```\n"}}