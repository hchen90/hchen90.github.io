<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/283bb1ed86b49fd2.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/09ec4099fb721b31.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/09dfadb69bdaa005.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/54b9acc791aa599c.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-ede82f7d0ae11dac.js"/><script src="/_next/static/chunks/4bd1b696-299743f5624cdabe.js" async=""></script><script src="/_next/static/chunks/684-481501000630d05e.js" async=""></script><script src="/_next/static/chunks/main-app-338894f2f2966ee4.js" async=""></script><script src="/_next/static/chunks/766-f505dbd3efffaa4c.js" async=""></script><script src="/_next/static/chunks/226-13d4d3f1fc18ceb6.js" async=""></script><script src="/_next/static/chunks/app/layout-07bb40856ea7a35b.js" async=""></script><script src="/_next/static/chunks/874-e909718850e7282e.js" async=""></script><script src="/_next/static/chunks/734-02ba314a893e68e9.js" async=""></script><script src="/_next/static/chunks/47-c7e96c4c4bac7987.js" async=""></script><script src="/_next/static/chunks/app/post/%5Bid%5D/page-203b57796d94b5ec.js" async=""></script><title>高级语言内存管理那些事：C++、Go 与 Rust 的对决</title><meta name="description" content="HCHEN90 博客"/><link rel="alternate" type="application/atom+xml" href="https://hchen90.top/atom.xml"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="antialiased relative"><div class="fixed top-4 right-4 z-50"><a href="https://github.com/hchen90" target="_blank" rel="noopener noreferrer" class="flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300" title="Visit my GitHub profile"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a></div><div class="min-h-screen relative"><div class="fixed top-0 left-0 h-1 bg-blue-500 z-50 transition-all duration-300" style="width:0%"></div><button class="fixed bottom-24 right-8 p-3 rounded-full bg-blue-600 hover:bg-blue-700 text-white shadow-lg transition-opacity duration-300 z-50 opacity-0 pointer-events-none" aria-label="Back to top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"></path></svg></button><div class="main-content transition-all duration-300"><div class="max-w-4xl mx-auto px-4 py-8"><div class="mb-8"><a class="text-blue-500 hover:underline mb-4 inline-block" href="/">← 返回首页</a></div><article><header class="mb-8"><h1 class="text-4xl font-bold mb-4">高级语言内存管理那些事：C++、Go 与 Rust 的对决</h1><div class="text-gray-500 mb-4">2024年4月21日</div></header><div class="markdown-content"><h1 id="高级语言内存管理那些事cgo-与-rust-的对决">高级语言内存管理那些事：C++、Go 与 Rust 的对决<a aria-hidden="true" tabindex="-1" href="#高级语言内存管理那些事cgo-与-rust-的对决"><span class="anchor-link"> #</span></a></h1>
<p>高级语言C++，Go，和Rust，是三种典型不同的内存管理风格的语言，它的风格也间接展示高级语言的发展历程，其中重要一项就是内存管理的变化。</p>
<h2 id="一前言为什么内存管理很重要">一、前言：为什么内存管理很重要<a aria-hidden="true" tabindex="-1" href="#一前言为什么内存管理很重要"><span class="anchor-link"> #</span></a></h2>
<p>内存管理是高级编程语言的基石，它影响程序的性能，安全和稳定。</p>
<ul>
<li>性能问题：编制不良的程序会申请大量的内存，但是却很少使用，导致实际使用的内存利用率很低，这样的程序会导致性能问题。</li>
<li>安全问题：安全性问题主要是申请的内存没有恰当释放引起的，然后引用它的指针被其他值覆盖，导致它指向的内存，以后永远不会被访问，这种问题较内存泄露，内存泄露的内存区域可以被插入恶意代码用以攻击，从而导致安全性问题。</li>
<li>稳定问题：高级语言中惯用变量（指针变量）来引用一块内存空间，如果这块内存空间已经释放，但是引用它的变量还继续引用去使用，将会触发内存管理异常，这属于使用悬空指针的现象。</li>
</ul>
<p>这三个问题是高级语言发展中，遇到过的问题。</p>
<p>对于C++，Go，和Rust语言，三种语言使用不同的内存管理策略：</p>
<ul>
<li>手动管理：C++使用手动管理，开发者需要更高的技能去做这一项事务。</li>
<li>垃圾回收：Go语言的内存申请和回收是由它的运行时（Runtime）调度进行的，开发者不需要处理内存管理的事项，但是它的运行时调度器在做内存回收事项，所以也会耗费一些资源。</li>
<li>所有权系统：Rust的方式别具一格，它使用编译期检查机制，使内存问题从代码层杜绝，但是它引入了更高级别的抽象机制，学习曲线较陡一些。</li>
</ul>
<h2 id="二c手动与智能指针的艺术">二、C++：手动与智能指针的艺术<a aria-hidden="true" tabindex="-1" href="#二c手动与智能指针的艺术"><span class="anchor-link"> #</span></a></h2>
<p>C++语言是一门古老的语言，一直至今还是一个目前至关重要的语言，但是C++也在不断地发展，有新的版本更迭，所以对于C++来说，可以把它看做传统手动管理方式和现代管理方式。</p>
<h3 id="传统手动管理内存">传统手动管理内存<a aria-hidden="true" tabindex="-1" href="#传统手动管理内存"><span class="anchor-link"> #</span></a></h3>
<p>这种方式其实就是C语言的风格，只不过C++中通常用<code>new</code>和<code>delete</code>关键字来申请和释放内存（类似于C直接调用内存管理函数）。</p>
<p>可见，在这种方式下，每处申请内存<code>new</code>获取的对象，在哪里释放<code>delete</code>，要保证能够被释放，并且不能被重复释放，所以编程上要特别注意这些。但是程序往往是复杂的，这种手动方式，会导致非常容易出错，心智负担也非常的重。</p>
<p>例如如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">alloc_int</span><span class="hljs-params">()</span> </span>{
  Int* i = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int</span>(); <span class="hljs-comment">// 直接堆中开辟内存</span>
  <span class="hljs-built_in">assert</span>(i != <span class="hljs-literal">NULL</span>);
  <span class="hljs-keyword">return</span> &#x26;(i->integer); <span class="hljs-comment">// 引用对象元素地址，i成为悬空指针</span>
}

<span class="hljs-type">int</span> n = *<span class="hljs-built_in">alloc_int</span>();
<span class="hljs-comment">// 可见在这里，alloc_int()函数中内存申请的Int类型的对象，是无法被释放了，函数虽然返回了一个指针，但是仅仅是对象元素的指针，智能用于获取元素值</span>

<span class="hljs-type">int</span>* p = <span class="hljs-built_in">alloc_int</span>();
<span class="hljs-comment">// 如果直接获取元素指针</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// 程序出现异常</span>
<span class="hljs-comment">// 这里的p指向的仅仅是对象元素的地址，是不可释放的，可以释放的是对象的指针，但是对象指针没有返回</span>

<span class="hljs-comment">// 这里再定义一个函数</span>
<span class="hljs-function">Int* <span class="hljs-title">alloc_int</span><span class="hljs-params">()</span> </span>{
  Int* i = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Int</span>(); <span class="hljs-comment">// 直接堆中开辟内存</span>
  <span class="hljs-built_in">assert</span>(i != <span class="hljs-literal">NULL</span>);
  <span class="hljs-keyword">return</span> i; <span class="hljs-comment">// 对象指针</span>
}

Int* p = <span class="hljs-built_in">alloc_int</span>();
<span class="hljs-comment">// 如果申请了，用完不释放p，是有问题的</span>
<span class="hljs-keyword">delete</span> p; <span class="hljs-comment">// 这样释放就没有问题了</span>
</code></pre></div>
<p>这样导致程序员要自己做到<code>new</code>和<code>delete</code>的一一对应，如果程序流程复杂，那么就需要去分析这些流程走向了，检查在不同分支流程上，释放都能满足一一对应的关系。</p>
<h3 id="现代管理内存">现代管理内存<a aria-hidden="true" tabindex="-1" href="#现代管理内存"><span class="anchor-link"> #</span></a></h3>
<p>现代C++内存管理起于C++0x标准，很多现代C++也是基于这个标准的，当然如果要用更现代的特性，那么就要基于更现代的标准了。现代C++引入了一个重要概念：<strong>智能指针</strong>，它实际上是利用RAII（Resource Acquisition Is Initialization）机制。</p>
<p>下面分别介绍三大智能指针：</p>
<ul>
<li><code>unique_ptr</code>:这是独占所有权的智能指针。</li>
<li><code>shared_ptr</code>:这是共享所有权的智能指针，对象内部引入计数管理生命周期。</li>
<li><code>weak_ptr</code>:这是观察者智能指针，主要用于解决循环引用的问题。</li>
</ul>
<p>C++的指针引入了归属者抽象概念，通过归属者来管理内存，从而避免内存泄露和不当释放的问题，大大缓解了手动管理内存的痛点。这种方式提供了语言级别的高度灵活性，但是需要开发人员具备丰富经验和严谨态度。</p>
<p>以下示例三种智能指针的使用，首先演示unique智能指针和shared共享智能指针：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> {
<span class="hljs-keyword">public</span>:
  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>{}
};

<span class="hljs-comment">// 演示unique智能指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testUnique</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// 创建一个unique_ptr智能指针</span>
  std::unique_ptr&#x3C;Test> uPtr1 = std::<span class="hljs-built_in">make_unique</span>&#x3C;Test>();

  <span class="hljs-comment">// 这里可以像普通指针一样使用智能指针</span>
  uPtr1-><span class="hljs-built_in">doSomething</span>();

  <span class="hljs-comment">// 因为unique智能指针是独占的，只能进行所有者转移操作</span>
  std::unique_ptr&#x3C;Test> uPtr2 = std::<span class="hljs-built_in">move</span>(uPtr1);

  <span class="hljs-comment">// uPtr1此时已经不再有效了</span>
  <span class="hljs-built_in">assert</span>(uPtr1 == <span class="hljs-literal">nullptr</span>);

  <span class="hljs-comment">// 和上次调用相同</span>
  uPtr2-><span class="hljs-built_in">doSomething</span>();
}

<span class="hljs-comment">// 演示shared智能指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testShared</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// 创建一个shared_ptr智能指针</span>
  std::shared_ptr&#x3C;Test> sPtr1 = std::<span class="hljs-built_in">make_shared</span>&#x3C;Test>();
  
  <span class="hljs-comment">// 像普通指针一样使用</span>
  sPtr1-><span class="hljs-built_in">doSomething</span>();
  
  <span class="hljs-comment">// 复制指针，引用计数加1</span>
  std::shared_ptr&#x3C;Test> sPtr2 = sPtr1;
  
  <span class="hljs-comment">// 这里再次调用这个函数，如果在函数里面更新了对象状态，那么它也会到sPtr1的，因为是共享的对象</span>
  sPtr2-><span class="hljs-built_in">doSomething</span>();
  
  <span class="hljs-comment">// 作用域示例</span>
  {
    <span class="hljs-comment">// 再复制一次</span>
    std::shared_ptr&#x3C;Test> sPtr3 = sPtr1;
    
    <span class="hljs-comment">// 使用共享对象</span>
    sPtr3-><span class="hljs-built_in">doSomething</span>();
    
    <span class="hljs-comment">// 退出作用域后，sPtr3指向的对象引用计数会减少1</span>
  }
  
  <span class="hljs-comment">// 退出作用域，sPtr2, sPtr1也会触发计数减1，当计数变为0时，对象就会自动释放</span>
}
</code></pre></div>
<p>以上也简单演示了shared共享智能指针，下面看一看复杂情况下的shared共享智能指针，而这时weak智能指针就要发挥它的作用了。</p>
<p>对于weak指针的作用，主要是用于解决在shared共享智能指针中遇到的问题，示例如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span> {
<span class="hljs-keyword">public</span>:
  std::shared_ptr&#x3C;T2> sPtr;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> {
<span class="hljs-keyword">public</span>:
  std::shared_ptr&#x3C;T1> sPtr;
};

<span class="hljs-comment">// 演示weak智能指针</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testWeak1</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// weak指针是用于解决shared指针的问题的</span>
  
  <span class="hljs-comment">// 创建两个共享智能指针</span>
  std::shared_ptr&#x3C;T1> sPtr1 = std::<span class="hljs-built_in">make_shared</span>&#x3C;T1>(); <span class="hljs-comment">// 计数1</span>
  std::shared_ptr&#x3C;T2> sPtr2 = std::<span class="hljs-built_in">make_shared</span>&#x3C;T2>(); <span class="hljs-comment">// 计数1</span>
  
  <span class="hljs-comment">// 让他们互相引用</span>
  sPtr1->sPtr = sPtr2; <span class="hljs-comment">// 计数2</span>
  sPtr2->sPtr = sPtr1; <span class="hljs-comment">// 计数2</span>
  
  <span class="hljs-comment">// 运行到这里退出函数，将导致内存泄露，因为sPtr1和sPtr2的引用计数全部是1，标记为对象还在被使用</span>
  <span class="hljs-comment">// 整体释放流程如下：</span>
  <span class="hljs-comment">// 栈中的sPtr1创建 (1) -> 被sPtr2引用 (2) -> 栈中的sPtr1析构 (1)</span>
  <span class="hljs-comment">// 栈中的sPtr2创建 (1) -> 被sPtr1引用 (2) -> 栈中的sPtr2析构 (1)</span>
}


<span class="hljs-comment">// 下面是一个修正版本，演示weak智能指针使用</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">T3</span> {
<span class="hljs-keyword">public</span>:
  std::shared_ptr&#x3C;T3> sPtr;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">T4</span> {
<span class="hljs-keyword">public</span>:
  std::weak_ptr&#x3C;T3> sPtr; <span class="hljs-comment">// 引用但不计数</span>
};

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testWeak2</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-comment">// 创建两个共享智能指针</span>
  std::shared_ptr&#x3C;T3> sPtr1 = std::<span class="hljs-built_in">make_shared</span>&#x3C;T3>();
  std::shared_ptr&#x3C;T4> sPtr2 = std::<span class="hljs-built_in">make_shared</span>&#x3C;T4>();
  
  <span class="hljs-comment">// 让他们互相引用</span>
  sPtr1->sPtr = sPtr2; <span class="hljs-comment">// 正常计数</span>
  sPtr2->sPtr = sPtr1; <span class="hljs-comment">// weak智能指针，不增加计数</span>
  
  <span class="hljs-comment">// 运行到这里退出函数，所以内存都会释放</span>
  <span class="hljs-comment">// 整体释放流程如下：</span>
  <span class="hljs-comment">// 栈中的sPtr1创建 (1) -> 被sPtr2观察，不引用 (1) -> 栈中的sPtr1析构 (0)</span>
  <span class="hljs-comment">// 栈中的sPtr2创建 (1) -> 被sPtr1引用 (2) -> sPtr1析构销毁 (1) -> 栈中的sPtr2析构 (0)</span>
}
</code></pre></div>
<blockquote>
<p>weak智能指针对象访问问题</p>
<p>因为weak智能指针的对象是不能保证对象释放可以访问（没有被释放），通常需要结合<code>lock()</code>函数来使用，如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> sp = sPtr1->sPtr.<span class="hljs-built_in">lock</span>()) {
    <span class="hljs-comment">// sp 是一个 shared_ptr&#x3C;T2></span>
    <span class="hljs-comment">// 可以安全使用</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// 说明 T2 已经被销毁</span>
}
</code></pre></div>
</blockquote>
<p>可以看出C++的智能指针虽然缓解了手动内存的管理问题，但是引入的拥有者管理生命周期，尤其涉及复杂场景的，例如循环引用，似乎还是比较麻烦的，需要在代码层面"别出心裁"地进行设计和编码。</p>
<h2 id="三gogc-垃圾回收程序员的福音">三、Go：GC 垃圾回收，程序员的福音？<a aria-hidden="true" tabindex="-1" href="#三gogc-垃圾回收程序员的福音"><span class="anchor-link"> #</span></a></h2>
<p>Go的内存管理核心是自动垃圾回收（Garbage Collection），主要通过调度运行时定期扫描，对于不再引用的内存块，进行自动回收。</p>
<blockquote>
<p>类似的GC垃圾回收机制，在其他高级语言也有，例如Java和Python，这种存在运行时的状态虚拟机的，基本都是通过GC来管理内存。</p>
</blockquote>
<p>对于GC内存管理的编程方式，开发者对于内存管理的心智负担较小，几乎所有的内存都可以被GC很好地管理，开发者只需要专注于业务逻辑即可。但是GC也有它的不好的地方，首先是它的性能开销，每次的GC调度都会消耗CPU资源，对象越多这种开销也会随之变大，而且GC的调度是随机的，如果程序对于实时性敏感，那么对于Go来说，那就是不适应的（例如游戏引擎就不适合Go去开发）。</p>
<p>下面举例说明这些问题：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">go</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-go"><span class="hljs-comment">// 这个函数每隔一秒打印游戏引擎的状态</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">logEngineEveryPeriod</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">for</span> {
    fmt.Printf(<span class="hljs-string">"[%v] engine status: %v"</span>, time.Now(), engine.GetStatus())
    time.Sleep(time.Millisecond * <span class="hljs-number">100</span>)
  }
}

<span class="hljs-comment">// 这个函数分配大量内存</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allocImage</span><span class="hljs-params">()</span></span> *Image {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">// 演示函数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testGo</span><span class="hljs-params">()</span></span> {
  <span class="hljs-comment">// 协程后台异步运行</span>
  <span class="hljs-keyword">go</span> logEngineEverySecond()
  
  <span class="hljs-keyword">for</span> sp := <span class="hljs-keyword">range</span> sprites {
    img := allocImage()
    sp.FitImage(img)
  }
}
</code></pre></div>
<p>上面的代码，首先有一个明显的问题，那就是<code>logEngineEveryPeriod()</code>无法完成它的任务，因为内存的分配管理，会导致GC花费的时间变长，它的日志打印会变得延迟，这样就无法保证它一定每隔100毫秒。</p>
<blockquote>
<p>最近版本Go对于GC导致延迟问题，进行了很多优化，目前从表现来看，已经非常出色了，只要不是对延迟非常敏感的任务，基本上都是可以胜任的。</p>
</blockquote>
<p>除了GC会导致延迟问题，Go内存管理看起来就是完美的吗？答案并非如此。</p>
<p><strong>Go语言仍然存在内存泄露</strong>，只不过它的表现形式不一样罢了，主要分为两种：</p>
<ol>
<li>
<p>全局对象持有引用导致的内存泄露</p>
<p>这种类型最常见，其本质是：一个生命周期很长（甚至贯穿整个程序）的对象，意外地引用了一个生命周期本应很短的对象。GC 在扫描时，发现这个短期对象仍然被长期对象引用，便认为它“活”着，从而无法回收。</p>
<p>示例如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">go</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-go"><span class="hljs-comment">// 一个全局缓存，模拟内存泄露</span>
<span class="hljs-keyword">var</span> cache = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>][]<span class="hljs-type">byte</span>)

<span class="hljs-comment">// 申请一块内存</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getData</span><span class="hljs-params">(id <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">byte</span> {
	<span class="hljs-comment">// 每次调用，都向缓存中添加一个大的字节切片</span>
	data := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>) <span class="hljs-comment">// 1MB</span>
	cache[id] = data
	<span class="hljs-keyword">return</span> data
}

<span class="hljs-comment">// 演示函数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demoGlobalRef</span><span class="hljs-params">()</span></span> {
  <span class="hljs-comment">// 迭代调用，内存分配使用</span>
  <span class="hljs-keyword">for</span> item := <span class="hljs-keyword">range</span> GetAllItems() {
    <span class="hljs-comment">// 申请一块内存</span>
    mem := getData(item.GetIndex())
    <span class="hljs-comment">// 使用内存，并打印结果</span>
    item.UseMemory(mem)
    item.PrintResult()
  }
}
</code></pre></div>
<p>在上面的<code>demoGlobalRef</code>函数中，随着<code>item</code>不停地迭代调用，被公共<code>cache</code>引用的逐渐增多，导致内存不停上涨，一直到最后，内存被打爆，服务终止退出。</p>
</li>
<li>
<p>不当使用 <code>slice</code> 导致的内存保留</p>
<p>这是另一个微妙但常见的内存泄露场景。当从一个大的 <code>slice</code> 中截取（<code>slice</code>）出一个小的 <code>slice</code> 时，如果原始的大 <code>slice</code> 仍然在内存中，那么即使小的 <code>slice</code> 不再被引用，它所依赖的底层数组也不会被 GC 回收。</p>
<p>示例代码如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">go</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-go"><span class="hljs-comment">// 返回一个大的 slice</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createBigSlice</span><span class="hljs-params">()</span></span> []<span class="hljs-type">byte</span> {
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">10</span>) <span class="hljs-comment">// 10MB</span>
}

<span class="hljs-comment">// 错误的方式：从大 slice 中截取</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFirstNBytesWrong</span><span class="hljs-params">()</span></span> []<span class="hljs-type">byte</span> {
	bigSlice := createBigSlice()
	<span class="hljs-comment">// 返回一个小的 slice，但其底层数组仍是 bigSlice 的大数组</span>
	<span class="hljs-keyword">return</span> bigSlice[:<span class="hljs-number">1024</span>]
}

<span class="hljs-comment">// 正确的方式：复制一份数据</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFirstNBytesCorrect</span><span class="hljs-params">()</span></span> []<span class="hljs-type">byte</span> {
	bigSlice := createBigSlice()
	<span class="hljs-comment">// 创建一个新的、小 size 的切片</span>
	smallSlice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)
	<span class="hljs-comment">// 将数据复制过去，让 bigSlice 不再被引用</span>
	<span class="hljs-built_in">copy</span>(smallSlice, bigSlice)
	<span class="hljs-keyword">return</span> smallSlice
}

<span class="hljs-comment">// 演示函数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demoSlice</span><span class="hljs-params">()</span></span> {
  <span class="hljs-comment">// 这里获取的slice是有内存泄露的</span>
  leakedSlice := getFirstNBytesWrong()
  
  <span class="hljs-comment">// 这里的slice是没问题的</span>
  correctSlice := getFirstNBytesCorrect()
}
</code></pre></div>
<p>上述中，可以看出如果直接从大数组中去子集切片来返回，那么这个大数组还是被引用的，是不会被GC回收的，如果要提高内存使用效率，减少内存开支，就有必要新建小数组切片，然后使用<code>copy</code>复制需要的内容到小数组切片中，然后作为返回值，这样大数组就不会被引用，就可以被GC回收了。</p>
</li>
</ol>
<h2 id="四rust所有权系统内存安全的终极答案">四、Rust：所有权系统，内存安全的终极答案<a aria-hidden="true" tabindex="-1" href="#四rust所有权系统内存安全的终极答案"><span class="anchor-link"> #</span></a></h2>
<p>可以看出C++的智能指针方式，需要开发者务必小心谨慎，这也代理了许多的心理负担，Go的负担一下子就没了，但是它依赖GC，也就附带GC而来的缺陷，此外也要注意变量引用问题，否则也会导致内存不能释放的问题，看起来似乎没有完美的方案。</p>
<p>其实是有完美的解决方案的，那就是Rust的内存管理方式。Rust的核心思想是<strong>编译期检查</strong>，<strong>零运行时开销</strong>，它引入了三大规则：</p>
<ol>
<li><strong>所有权 (Ownership)：</strong> 每个值都有一个所有者。</li>
<li><strong>移动 (Move)：</strong> 所有者离开作用域，值被销毁。</li>
<li><strong>借用 (Borrowing)：</strong> 可以通过<strong>可变借用</strong>或<strong>不可变借用</strong>来访问数据，但不能同时存在。</li>
</ol>
<p>它这套方式算是借鉴了C++的智能指针的核心设计思想，但是同时它把其推向了更加极致的境界。可以看见C++的智能指针是一种事后补救措施（历史原因），而Rust是事前预防的措施，它将这种所有权设计成强制性，并推广到所有的类型，从根本杜绝问题。</p>
<p>以下代码示例它的这种内存管理机制：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">rust</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-rust"><span class="hljs-comment">// 一个简单的函数，展示所有权转移</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">take_ownership</span>(some_string: <span class="hljs-type">String</span>) { <span class="hljs-comment">// some_string 获取了所有权</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I own this string: {}"</span>, some_string);
} <span class="hljs-comment">// some_string 离开作用域，其内存被自动释放</span>

<span class="hljs-comment">// 一个函数，展示借用</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">borrow_and_print</span>(some_string: &#x26;<span class="hljs-type">String</span>) { <span class="hljs-comment">// some_string 是一个不可变借用</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I'm borrowing this string: {}"</span>, some_string);
} <span class="hljs-comment">// some_string 离开作用域，借用结束</span>

<span class="hljs-comment">// 一个函数，展示可变借用</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">borrow_and_change</span>(some_string: &#x26;<span class="hljs-keyword">mut</span> <span class="hljs-type">String</span>) { <span class="hljs-comment">// some_string 是一个可变借用</span>
    some_string.<span class="hljs-title function_ invoke__">push_str</span>(<span class="hljs-string">" and I was changed!"</span>);
} <span class="hljs-comment">// some_string 离开作用域，借用结束</span>

<span class="hljs-comment">// 演示函数</span>
<span class="hljs-keyword">fn</span> <span class="hljs-title function_">demo_rust_mem</span>() {
  <span class="hljs-comment">// --- 1. 所有权示例 ---</span>
  <span class="hljs-keyword">let</span> <span class="hljs-variable">s1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"hello world"</span>); <span class="hljs-comment">// s1 拥有 "hello world" 的所有权</span>
  
  <span class="hljs-keyword">let</span> <span class="hljs-variable">s2</span> = s1; <span class="hljs-comment">// 所有权从 s1 移动(move)到 s2</span>
  <span class="hljs-comment">// 在这一点之后，s1 不再有效！编译器会报错</span>
  <span class="hljs-comment">// println!("s1 is: {}", s1); // 编译错误！value borrowed here after move</span>
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"s2 is: {}"</span>, s2);
  
  <span class="hljs-comment">// 调用函数，所有权被转移</span>
  <span class="hljs-keyword">let</span> <span class="hljs-variable">s3</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"take me away"</span>);
  <span class="hljs-title function_ invoke__">take_ownership</span>(s3);
  <span class="hljs-comment">// println!("s3 is: {}", s3); // 编译错误！s3 的所有权已被转移</span>
  
  <span class="hljs-comment">// --- 2. 借用示例 ---</span>
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n--- 借用示例 ---"</span>);
  <span class="hljs-keyword">let</span> <span class="hljs-variable">s4</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"this is a borrowed string"</span>);
  <span class="hljs-title function_ invoke__">borrow_and_print</span>(&#x26;s4); <span class="hljs-comment">// s4 的借用被传递</span>
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"s4 is still valid after borrowing: {}"</span>, s4); <span class="hljs-comment">// 借用结束后，s4 仍然有效</span>

  <span class="hljs-comment">// --- 3. 可变借用示例 ---</span>
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n--- 可变借用示例 ---"</span>);
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s5</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"I am mutable"</span>);
  <span class="hljs-title function_ invoke__">borrow_and_change</span>(&#x26;<span class="hljs-keyword">mut</span> s5);
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"s5 has been changed: {}"</span>, s5);
  
  <span class="hljs-comment">// --- 4. 借用冲突示例 ---</span>
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"\n--- 借用冲突示例 ---"</span>);
  <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">s6</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">"I have multiple references"</span>);

  <span class="hljs-comment">// 允许多个不可变借用</span>
  <span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &#x26;s6;
  <span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &#x26;s6;
  <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} and {}"</span>, r1, r2);
  
  <span class="hljs-comment">// 但是，在不可变借用之后，不允许可变借用</span>
  <span class="hljs-comment">// let r3 = &#x26;mut s6; // 编译错误！cannot borrow as mutable...</span>

  <span class="hljs-comment">// --- 5. 悬空指针（编译器会阻止） ---</span>
  <span class="hljs-comment">// 下面的函数无法编译，因为它会返回一个悬空引用</span>
  <span class="hljs-comment">// fn dangle() -> &#x26;String {</span>
  <span class="hljs-comment">//     let s = String::from("dangling"); // s 在这里被创建</span>
  <span class="hljs-comment">//     &#x26;s // 返回 s 的引用</span>
  <span class="hljs-comment">// } // s 在这里离开作用域并被销毁，其引用变成悬空指针！</span>
  <span class="hljs-comment">// 编译器会报错：`s` does not live long enough</span>
}
</code></pre></div>
<p>可以看出，Rust通过这种所有权机制管理内存，在编译阶段就把可能引发内存问题的逻辑给杜绝了，保障了内存的安全性，同时这种方式不依赖GC，效率更高。</p>
<h2 id="五综合对比与选择指南">五、综合对比与选择指南<a aria-hidden="true" tabindex="-1" href="#五综合对比与选择指南"><span class="anchor-link"> #</span></a></h2>
<p>结合三种语言的内存管理机制来比较。C++适用于对性能有极致的要求，另外如果要对底层硬件的控制，C++语言是必要的，但是使用C++就会引入复杂的系统编程。对于Go来说，适用于时间不敏感，例如高并发网络服务，后端服务开发，以及快速迭代的业务系统，它相比于C++和Rust来说，语法更加容易入手，相对简单。但是如果要开发的系统对于内存安全性有很高要求，同时又要保证很高的性能，那么Rust将是一个不错的选项，例如证券交易类系统，还有嵌入式系统，以及操作系统都是可以适用的。</p>
<p>总的来说，不同语言有不同的内存管理方案，没有最好的方案，只有最适合的特定项目的方案。不过随着行业发展，内存安全是编程语言的重要发展方向，Rust的所有权模式将是一个新颖的思路。</p></div><div class="mt-12 pt-6 border-t border-gray-200 dark:border-gray-700"><a class="text-blue-500 hover:underline" href="/">← 返回所有文章列表</a></div><div class="mt-8 pt-4 border-t border-gray-200 dark:border-gray-700 text-center text-gray-500 text-sm">© 2013 – 2025 陈祥</div></article></div></div></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-ede82f7d0ae11dac.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n4:I[415,[\"766\",\"static/chunks/766-f505dbd3efffaa4c.js\",\"226\",\"static/chunks/226-13d4d3f1fc18ceb6.js\",\"177\",\"static/chunks/app/layout-07bb40856ea7a35b.js\"],\"default\"]\n5:I[9243,[\"766\",\"static/chunks/766-f505dbd3efffaa4c.js\",\"226\",\"static/chunks/226-13d4d3f1fc18ceb6.js\",\"177\",\"static/chunks/app/layout-07bb40856ea7a35b.js\"],\"\"]\n8:I[9665,[],\"MetadataBoundary\"]\na:I[9665,[],\"OutletBoundary\"]\nd:I[4911,[],\"AsyncMetadataOutlet\"]\nf:I[9665,[],\"ViewportBoundary\"]\n11:I[6614,[],\"\"]\n:HL[\"/_next/static/css/283bb1ed86b49fd2.css\",\"style\"]\n:HL[\"/_next/static/css/09ec4099fb721b31.css\",\"style\"]\n:HL[\"/_next/static/css/09dfadb69bdaa005.css\",\"style\"]\n:HL[\"/_next/static/css/54b9acc791aa599c.css\",\"style\"]\n6:T4a2,\n          function copyCode(button) {\n            // Find the code element within the same wrapper\n            const codeWrapper = button.closest('.code-block-wrapper');\n            if (!codeWrapper) return;\n            \n            const codeElement = codeWrapper.querySelector('code');\n            if (!codeElement) return;\n            \n            // Get the text content\n            const text = codeElement.textContent;\n            \n            // Use the clipboard API to copy the text\n            navigator.clipboard.writeText(text).then(() =\u003e {\n              // Update the button state to show \"Copied!\"\n              button.setAttribute('data-copy-state', 'copied');\n              const buttonText = button.querySelector('.copy-button-text');\n              if (buttonText) buttonText.textContent = 'Copied!';\n              \n              // Reset after 2 seconds\n              setTimeout(() =\u003e {\n                button.setAttribute('data-copy-state', 'copy');\n                if (buttonText) buttonText.textContent = 'Copy';\n              }, 2000);\n            }).catch(err =\u003e {\n              console.error('Failed to copy text: ', err);\n            });\n          }\n          "])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ppQBZ_hjs78de-RY41wpR\",\"p\":\"\",\"c\":[\"\",\"post\",\"advlangmemmanagement\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"post\",{\"children\":[[\"id\",\"advlangmemmanagement\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/283bb1ed86b49fd2.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09ec4099fb721b31.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09dfadb69bdaa005.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased relative\",\"children\":[[\"$\",\"div\",null,{\"className\":\"fixed top-4 right-4 z-50\",\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/hchen90\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"className\":\"flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300\",\"title\":\"Visit my GitHub profile\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":\"24\",\"height\":\"24\",\"viewBox\":\"0 0 24 24\",\"fill\":\"currentColor\",\"children\":[\"$\",\"path\",null,{\"d\":\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"}]}]}]}],[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"$L4\",null,{}],[\"$\",\"$L5\",null,{\"id\":\"code-copy\",\"children\":\"$6\"}]]}]}]]}],{\"children\":[\"post\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"id\",\"advlangmemmanagement\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/54b9acc791aa599c.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"GhKigCv3NECX0MdcU-NpO\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:\"$Sreact.suspense\"\n13:I[4911,[],\"AsyncMetadata\"]\n9:[\"$\",\"$12\",null,{\"fallback\":null,\"children\":[\"$\",\"$L13\",null,{\"promise\":\"$@14\"}]}]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script><script>self.__next_f.push([1,"15:I[9543,[\"874\",\"static/chunks/874-e909718850e7282e.js\",\"734\",\"static/chunks/734-02ba314a893e68e9.js\",\"47\",\"static/chunks/47-c7e96c4c4bac7987.js\",\"457\",\"static/chunks/app/post/%5Bid%5D/page-203b57796d94b5ec.js\"],\"default\"]\n16:T8652,"])</script><script>self.__next_f.push([1,"\u003ch1 id=\"高级语言内存管理那些事cgo-与-rust-的对决\"\u003e高级语言内存管理那些事：C++、Go 与 Rust 的对决\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#高级语言内存管理那些事cgo-与-rust-的对决\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e高级语言C++，Go，和Rust，是三种典型不同的内存管理风格的语言，它的风格也间接展示高级语言的发展历程，其中重要一项就是内存管理的变化。\u003c/p\u003e\n\u003ch2 id=\"一前言为什么内存管理很重要\"\u003e一、前言：为什么内存管理很重要\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#一前言为什么内存管理很重要\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e内存管理是高级编程语言的基石，它影响程序的性能，安全和稳定。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e性能问题：编制不良的程序会申请大量的内存，但是却很少使用，导致实际使用的内存利用率很低，这样的程序会导致性能问题。\u003c/li\u003e\n\u003cli\u003e安全问题：安全性问题主要是申请的内存没有恰当释放引起的，然后引用它的指针被其他值覆盖，导致它指向的内存，以后永远不会被访问，这种问题较内存泄露，内存泄露的内存区域可以被插入恶意代码用以攻击，从而导致安全性问题。\u003c/li\u003e\n\u003cli\u003e稳定问题：高级语言中惯用变量（指针变量）来引用一块内存空间，如果这块内存空间已经释放，但是引用它的变量还继续引用去使用，将会触发内存管理异常，这属于使用悬空指针的现象。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这三个问题是高级语言发展中，遇到过的问题。\u003c/p\u003e\n\u003cp\u003e对于C++，Go，和Rust语言，三种语言使用不同的内存管理策略：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e手动管理：C++使用手动管理，开发者需要更高的技能去做这一项事务。\u003c/li\u003e\n\u003cli\u003e垃圾回收：Go语言的内存申请和回收是由它的运行时（Runtime）调度进行的，开发者不需要处理内存管理的事项，但是它的运行时调度器在做内存回收事项，所以也会耗费一些资源。\u003c/li\u003e\n\u003cli\u003e所有权系统：Rust的方式别具一格，它使用编译期检查机制，使内存问题从代码层杜绝，但是它引入了更高级别的抽象机制，学习曲线较陡一些。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"二c手动与智能指针的艺术\"\u003e二、C++：手动与智能指针的艺术\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#二c手动与智能指针的艺术\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eC++语言是一门古老的语言，一直至今还是一个目前至关重要的语言，但是C++也在不断地发展，有新的版本更迭，所以对于C++来说，可以把它看做传统手动管理方式和现代管理方式。\u003c/p\u003e\n\u003ch3 id=\"传统手动管理内存\"\u003e传统手动管理内存\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#传统手动管理内存\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e这种方式其实就是C语言的风格，只不过C++中通常用\u003ccode\u003enew\u003c/code\u003e和\u003ccode\u003edelete\u003c/code\u003e关键字来申请和释放内存（类似于C直接调用内存管理函数）。\u003c/p\u003e\n\u003cp\u003e可见，在这种方式下，每处申请内存\u003ccode\u003enew\u003c/code\u003e获取的对象，在哪里释放\u003ccode\u003edelete\u003c/code\u003e，要保证能够被释放，并且不能被重复释放，所以编程上要特别注意这些。但是程序往往是复杂的，这种手动方式，会导致非常容易出错，心智负担也非常的重。\u003c/p\u003e\n\u003cp\u003e例如如下：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003ecpp\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e* \u003cspan class=\"hljs-title\"\u003ealloc_int\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  Int* i = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eInt\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 直接堆中开辟内存\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eassert\u003c/span\u003e(i != \u003cspan class=\"hljs-literal\"\u003eNULL\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u0026#x26;(i-\u003einteger); \u003cspan class=\"hljs-comment\"\u003e// 引用对象元素地址，i成为悬空指针\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e n = *\u003cspan class=\"hljs-built_in\"\u003ealloc_int\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 可见在这里，alloc_int()函数中内存申请的Int类型的对象，是无法被释放了，函数虽然返回了一个指针，但是仅仅是对象元素的指针，智能用于获取元素值\u003c/span\u003e\n\n\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e* p = \u003cspan class=\"hljs-built_in\"\u003ealloc_int\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 如果直接获取元素指针\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e p; \u003cspan class=\"hljs-comment\"\u003e// 程序出现异常\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 这里的p指向的仅仅是对象元素的地址，是不可释放的，可以释放的是对象的指针，但是对象指针没有返回\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 这里再定义一个函数\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003eInt* \u003cspan class=\"hljs-title\"\u003ealloc_int\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  Int* i = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eInt\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 直接堆中开辟内存\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eassert\u003c/span\u003e(i != \u003cspan class=\"hljs-literal\"\u003eNULL\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e i; \u003cspan class=\"hljs-comment\"\u003e// 对象指针\u003c/span\u003e\n}\n\nInt* p = \u003cspan class=\"hljs-built_in\"\u003ealloc_int\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 如果申请了，用完不释放p，是有问题的\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003edelete\u003c/span\u003e p; \u003cspan class=\"hljs-comment\"\u003e// 这样释放就没有问题了\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e这样导致程序员要自己做到\u003ccode\u003enew\u003c/code\u003e和\u003ccode\u003edelete\u003c/code\u003e的一一对应，如果程序流程复杂，那么就需要去分析这些流程走向了，检查在不同分支流程上，释放都能满足一一对应的关系。\u003c/p\u003e\n\u003ch3 id=\"现代管理内存\"\u003e现代管理内存\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#现代管理内存\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e现代C++内存管理起于C++0x标准，很多现代C++也是基于这个标准的，当然如果要用更现代的特性，那么就要基于更现代的标准了。现代C++引入了一个重要概念：\u003cstrong\u003e智能指针\u003c/strong\u003e，它实际上是利用RAII（Resource Acquisition Is Initialization）机制。\u003c/p\u003e\n\u003cp\u003e下面分别介绍三大智能指针：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eunique_ptr\u003c/code\u003e:这是独占所有权的智能指针。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eshared_ptr\u003c/code\u003e:这是共享所有权的智能指针，对象内部引入计数管理生命周期。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eweak_ptr\u003c/code\u003e:这是观察者智能指针，主要用于解决循环引用的问题。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eC++的指针引入了归属者抽象概念，通过归属者来管理内存，从而避免内存泄露和不当释放的问题，大大缓解了手动管理内存的痛点。这种方式提供了语言级别的高度灵活性，但是需要开发人员具备丰富经验和严谨态度。\u003c/p\u003e\n\u003cp\u003e以下示例三种智能指针的使用，首先演示unique智能指针和shared共享智能指针：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003ecpp\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eTest\u003c/span\u003e {\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e:\n  \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edoSomething\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{}\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 演示unique智能指针\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestUnique\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 创建一个unique_ptr智能指针\u003c/span\u003e\n  std::unique_ptr\u0026#x3C;Test\u003e uPtr1 = std::\u003cspan class=\"hljs-built_in\"\u003emake_unique\u003c/span\u003e\u0026#x3C;Test\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 这里可以像普通指针一样使用智能指针\u003c/span\u003e\n  uPtr1-\u003e\u003cspan class=\"hljs-built_in\"\u003edoSomething\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-comment\"\u003e// 因为unique智能指针是独占的，只能进行所有者转移操作\u003c/span\u003e\n  std::unique_ptr\u0026#x3C;Test\u003e uPtr2 = std::\u003cspan class=\"hljs-built_in\"\u003emove\u003c/span\u003e(uPtr1);\n\n  \u003cspan class=\"hljs-comment\"\u003e// uPtr1此时已经不再有效了\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eassert\u003c/span\u003e(uPtr1 == \u003cspan class=\"hljs-literal\"\u003enullptr\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 和上次调用相同\u003c/span\u003e\n  uPtr2-\u003e\u003cspan class=\"hljs-built_in\"\u003edoSomething\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 演示shared智能指针\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestShared\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 创建一个shared_ptr智能指针\u003c/span\u003e\n  std::shared_ptr\u0026#x3C;Test\u003e sPtr1 = std::\u003cspan class=\"hljs-built_in\"\u003emake_shared\u003c/span\u003e\u0026#x3C;Test\u003e();\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 像普通指针一样使用\u003c/span\u003e\n  sPtr1-\u003e\u003cspan class=\"hljs-built_in\"\u003edoSomething\u003c/span\u003e();\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 复制指针，引用计数加1\u003c/span\u003e\n  std::shared_ptr\u0026#x3C;Test\u003e sPtr2 = sPtr1;\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 这里再次调用这个函数，如果在函数里面更新了对象状态，那么它也会到sPtr1的，因为是共享的对象\u003c/span\u003e\n  sPtr2-\u003e\u003cspan class=\"hljs-built_in\"\u003edoSomething\u003c/span\u003e();\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 作用域示例\u003c/span\u003e\n  {\n    \u003cspan class=\"hljs-comment\"\u003e// 再复制一次\u003c/span\u003e\n    std::shared_ptr\u0026#x3C;Test\u003e sPtr3 = sPtr1;\n    \n    \u003cspan class=\"hljs-comment\"\u003e// 使用共享对象\u003c/span\u003e\n    sPtr3-\u003e\u003cspan class=\"hljs-built_in\"\u003edoSomething\u003c/span\u003e();\n    \n    \u003cspan class=\"hljs-comment\"\u003e// 退出作用域后，sPtr3指向的对象引用计数会减少1\u003c/span\u003e\n  }\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 退出作用域，sPtr2, sPtr1也会触发计数减1，当计数变为0时，对象就会自动释放\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e以上也简单演示了shared共享智能指针，下面看一看复杂情况下的shared共享智能指针，而这时weak智能指针就要发挥它的作用了。\u003c/p\u003e\n\u003cp\u003e对于weak指针的作用，主要是用于解决在shared共享智能指针中遇到的问题，示例如下：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003ecpp\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eT2\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eT1\u003c/span\u003e {\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e:\n  std::shared_ptr\u0026#x3C;T2\u003e sPtr;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eT2\u003c/span\u003e {\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e:\n  std::shared_ptr\u0026#x3C;T1\u003e sPtr;\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 演示weak智能指针\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestWeak1\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// weak指针是用于解决shared指针的问题的\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 创建两个共享智能指针\u003c/span\u003e\n  std::shared_ptr\u0026#x3C;T1\u003e sPtr1 = std::\u003cspan class=\"hljs-built_in\"\u003emake_shared\u003c/span\u003e\u0026#x3C;T1\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 计数1\u003c/span\u003e\n  std::shared_ptr\u0026#x3C;T2\u003e sPtr2 = std::\u003cspan class=\"hljs-built_in\"\u003emake_shared\u003c/span\u003e\u0026#x3C;T2\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 计数1\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 让他们互相引用\u003c/span\u003e\n  sPtr1-\u003esPtr = sPtr2; \u003cspan class=\"hljs-comment\"\u003e// 计数2\u003c/span\u003e\n  sPtr2-\u003esPtr = sPtr1; \u003cspan class=\"hljs-comment\"\u003e// 计数2\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 运行到这里退出函数，将导致内存泄露，因为sPtr1和sPtr2的引用计数全部是1，标记为对象还在被使用\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 整体释放流程如下：\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 栈中的sPtr1创建 (1) -\u003e 被sPtr2引用 (2) -\u003e 栈中的sPtr1析构 (1)\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 栈中的sPtr2创建 (1) -\u003e 被sPtr1引用 (2) -\u003e 栈中的sPtr2析构 (1)\u003c/span\u003e\n}\n\n\n\u003cspan class=\"hljs-comment\"\u003e// 下面是一个修正版本，演示weak智能指针使用\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eT3\u003c/span\u003e {\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e:\n  std::shared_ptr\u0026#x3C;T3\u003e sPtr;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eT4\u003c/span\u003e {\n\u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e:\n  std::weak_ptr\u0026#x3C;T3\u003e sPtr; \u003cspan class=\"hljs-comment\"\u003e// 引用但不计数\u003c/span\u003e\n};\n\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestWeak2\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e \u003c/span\u003e{\n  \u003cspan class=\"hljs-comment\"\u003e// 创建两个共享智能指针\u003c/span\u003e\n  std::shared_ptr\u0026#x3C;T3\u003e sPtr1 = std::\u003cspan class=\"hljs-built_in\"\u003emake_shared\u003c/span\u003e\u0026#x3C;T3\u003e();\n  std::shared_ptr\u0026#x3C;T4\u003e sPtr2 = std::\u003cspan class=\"hljs-built_in\"\u003emake_shared\u003c/span\u003e\u0026#x3C;T4\u003e();\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 让他们互相引用\u003c/span\u003e\n  sPtr1-\u003esPtr = sPtr2; \u003cspan class=\"hljs-comment\"\u003e// 正常计数\u003c/span\u003e\n  sPtr2-\u003esPtr = sPtr1; \u003cspan class=\"hljs-comment\"\u003e// weak智能指针，不增加计数\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 运行到这里退出函数，所以内存都会释放\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 整体释放流程如下：\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 栈中的sPtr1创建 (1) -\u003e 被sPtr2观察，不引用 (1) -\u003e 栈中的sPtr1析构 (0)\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 栈中的sPtr2创建 (1) -\u003e 被sPtr1引用 (2) -\u003e sPtr1析构销毁 (1) -\u003e 栈中的sPtr2析构 (0)\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cblockquote\u003e\n\u003cp\u003eweak智能指针对象访问问题\u003c/p\u003e\n\u003cp\u003e因为weak智能指针的对象是不能保证对象释放可以访问（没有被释放），通常需要结合\u003ccode\u003elock()\u003c/code\u003e函数来使用，如下：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003ecpp\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-cpp\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003eauto\u003c/span\u003e sp = sPtr1-\u003esPtr.\u003cspan class=\"hljs-built_in\"\u003elock\u003c/span\u003e()) {\n    \u003cspan class=\"hljs-comment\"\u003e// sp 是一个 shared_ptr\u0026#x3C;T2\u003e\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e// 可以安全使用\u003c/span\u003e\n} \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 说明 T2 已经被销毁\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e可以看出C++的智能指针虽然缓解了手动内存的管理问题，但是引入的拥有者管理生命周期，尤其涉及复杂场景的，例如循环引用，似乎还是比较麻烦的，需要在代码层面\"别出心裁\"地进行设计和编码。\u003c/p\u003e\n\u003ch2 id=\"三gogc-垃圾回收程序员的福音\"\u003e三、Go：GC 垃圾回收，程序员的福音？\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#三gogc-垃圾回收程序员的福音\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eGo的内存管理核心是自动垃圾回收（Garbage Collection），主要通过调度运行时定期扫描，对于不再引用的内存块，进行自动回收。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e类似的GC垃圾回收机制，在其他高级语言也有，例如Java和Python，这种存在运行时的状态虚拟机的，基本都是通过GC来管理内存。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e对于GC内存管理的编程方式，开发者对于内存管理的心智负担较小，几乎所有的内存都可以被GC很好地管理，开发者只需要专注于业务逻辑即可。但是GC也有它的不好的地方，首先是它的性能开销，每次的GC调度都会消耗CPU资源，对象越多这种开销也会随之变大，而且GC的调度是随机的，如果程序对于实时性敏感，那么对于Go来说，那就是不适应的（例如游戏引擎就不适合Go去开发）。\u003c/p\u003e\n\u003cp\u003e下面举例说明这些问题：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003ego\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 这个函数每隔一秒打印游戏引擎的状态\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003elogEngineEveryPeriod\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e {\n    fmt.Printf(\u003cspan class=\"hljs-string\"\u003e\"[%v] engine status: %v\"\u003c/span\u003e, time.Now(), engine.GetStatus())\n    time.Sleep(time.Millisecond * \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e)\n  }\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 这个函数分配大量内存\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003eallocImage\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e *Image {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 演示函数\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003etestGo\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 协程后台异步运行\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ego\u003c/span\u003e logEngineEverySecond()\n  \n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e sp := \u003cspan class=\"hljs-keyword\"\u003erange\u003c/span\u003e sprites {\n    img := allocImage()\n    sp.FitImage(img)\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e上面的代码，首先有一个明显的问题，那就是\u003ccode\u003elogEngineEveryPeriod()\u003c/code\u003e无法完成它的任务，因为内存的分配管理，会导致GC花费的时间变长，它的日志打印会变得延迟，这样就无法保证它一定每隔100毫秒。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e最近版本Go对于GC导致延迟问题，进行了很多优化，目前从表现来看，已经非常出色了，只要不是对延迟非常敏感的任务，基本上都是可以胜任的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e除了GC会导致延迟问题，Go内存管理看起来就是完美的吗？答案并非如此。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eGo语言仍然存在内存泄露\u003c/strong\u003e，只不过它的表现形式不一样罢了，主要分为两种：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e全局对象持有引用导致的内存泄露\u003c/p\u003e\n\u003cp\u003e这种类型最常见，其本质是：一个生命周期很长（甚至贯穿整个程序）的对象，意外地引用了一个生命周期本应很短的对象。GC 在扫描时，发现这个短期对象仍然被长期对象引用，便认为它“活”着，从而无法回收。\u003c/p\u003e\n\u003cp\u003e示例如下：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003ego\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 一个全局缓存，模拟内存泄露\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e cache = \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003emap\u003c/span\u003e[\u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e][]\u003cspan class=\"hljs-type\"\u003ebyte\u003c/span\u003e)\n\n\u003cspan class=\"hljs-comment\"\u003e// 申请一块内存\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egetData\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(id \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e)\u003c/span\u003e\u003c/span\u003e []\u003cspan class=\"hljs-type\"\u003ebyte\u003c/span\u003e {\n\t\u003cspan class=\"hljs-comment\"\u003e// 每次调用，都向缓存中添加一个大的字节切片\u003c/span\u003e\n\tdata := \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e([]\u003cspan class=\"hljs-type\"\u003ebyte\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 1MB\u003c/span\u003e\n\tcache[id] = data\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e data\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 演示函数\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edemoGlobalRef\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 迭代调用，内存分配使用\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e item := \u003cspan class=\"hljs-keyword\"\u003erange\u003c/span\u003e GetAllItems() {\n    \u003cspan class=\"hljs-comment\"\u003e// 申请一块内存\u003c/span\u003e\n    mem := getData(item.GetIndex())\n    \u003cspan class=\"hljs-comment\"\u003e// 使用内存，并打印结果\u003c/span\u003e\n    item.UseMemory(mem)\n    item.PrintResult()\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e在上面的\u003ccode\u003edemoGlobalRef\u003c/code\u003e函数中，随着\u003ccode\u003eitem\u003c/code\u003e不停地迭代调用，被公共\u003ccode\u003ecache\u003c/code\u003e引用的逐渐增多，导致内存不停上涨，一直到最后，内存被打爆，服务终止退出。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e不当使用 \u003ccode\u003eslice\u003c/code\u003e 导致的内存保留\u003c/p\u003e\n\u003cp\u003e这是另一个微妙但常见的内存泄露场景。当从一个大的 \u003ccode\u003eslice\u003c/code\u003e 中截取（\u003ccode\u003eslice\u003c/code\u003e）出一个小的 \u003ccode\u003eslice\u003c/code\u003e 时，如果原始的大 \u003ccode\u003eslice\u003c/code\u003e 仍然在内存中，那么即使小的 \u003ccode\u003eslice\u003c/code\u003e 不再被引用，它所依赖的底层数组也不会被 GC 回收。\u003c/p\u003e\n\u003cp\u003e示例代码如下：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003ego\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-go\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 返回一个大的 slice\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003ecreateBigSlice\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e []\u003cspan class=\"hljs-type\"\u003ebyte\u003c/span\u003e {\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e([]\u003cspan class=\"hljs-type\"\u003ebyte\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e*\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 10MB\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 错误的方式：从大 slice 中截取\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egetFirstNBytesWrong\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e []\u003cspan class=\"hljs-type\"\u003ebyte\u003c/span\u003e {\n\tbigSlice := createBigSlice()\n\t\u003cspan class=\"hljs-comment\"\u003e// 返回一个小的 slice，但其底层数组仍是 bigSlice 的大数组\u003c/span\u003e\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e bigSlice[:\u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e]\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 正确的方式：复制一份数据\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003egetFirstNBytesCorrect\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e []\u003cspan class=\"hljs-type\"\u003ebyte\u003c/span\u003e {\n\tbigSlice := createBigSlice()\n\t\u003cspan class=\"hljs-comment\"\u003e// 创建一个新的、小 size 的切片\u003c/span\u003e\n\tsmallSlice := \u003cspan class=\"hljs-built_in\"\u003emake\u003c/span\u003e([]\u003cspan class=\"hljs-type\"\u003ebyte\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1024\u003c/span\u003e)\n\t\u003cspan class=\"hljs-comment\"\u003e// 将数据复制过去，让 bigSlice 不再被引用\u003c/span\u003e\n\t\u003cspan class=\"hljs-built_in\"\u003ecopy\u003c/span\u003e(smallSlice, bigSlice)\n\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e smallSlice\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 演示函数\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title\"\u003edemoSlice\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 这里获取的slice是有内存泄露的\u003c/span\u003e\n  leakedSlice := getFirstNBytesWrong()\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 这里的slice是没问题的\u003c/span\u003e\n  correctSlice := getFirstNBytesCorrect()\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e上述中，可以看出如果直接从大数组中去子集切片来返回，那么这个大数组还是被引用的，是不会被GC回收的，如果要提高内存使用效率，减少内存开支，就有必要新建小数组切片，然后使用\u003ccode\u003ecopy\u003c/code\u003e复制需要的内容到小数组切片中，然后作为返回值，这样大数组就不会被引用，就可以被GC回收了。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"四rust所有权系统内存安全的终极答案\"\u003e四、Rust：所有权系统，内存安全的终极答案\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#四rust所有权系统内存安全的终极答案\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e可以看出C++的智能指针方式，需要开发者务必小心谨慎，这也代理了许多的心理负担，Go的负担一下子就没了，但是它依赖GC，也就附带GC而来的缺陷，此外也要注意变量引用问题，否则也会导致内存不能释放的问题，看起来似乎没有完美的方案。\u003c/p\u003e\n\u003cp\u003e其实是有完美的解决方案的，那就是Rust的内存管理方式。Rust的核心思想是\u003cstrong\u003e编译期检查\u003c/strong\u003e，\u003cstrong\u003e零运行时开销\u003c/strong\u003e，它引入了三大规则：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e所有权 (Ownership)：\u003c/strong\u003e 每个值都有一个所有者。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e移动 (Move)：\u003c/strong\u003e 所有者离开作用域，值被销毁。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e借用 (Borrowing)：\u003c/strong\u003e 可以通过\u003cstrong\u003e可变借用\u003c/strong\u003e或\u003cstrong\u003e不可变借用\u003c/strong\u003e来访问数据，但不能同时存在。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e它这套方式算是借鉴了C++的智能指针的核心设计思想，但是同时它把其推向了更加极致的境界。可以看见C++的智能指针是一种事后补救措施（历史原因），而Rust是事前预防的措施，它将这种所有权设计成强制性，并推广到所有的类型，从根本杜绝问题。\u003c/p\u003e\n\u003cp\u003e以下代码示例它的这种内存管理机制：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003erust\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-rust\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 一个简单的函数，展示所有权转移\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etake_ownership\u003c/span\u003e(some_string: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e// some_string 获取了所有权\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"I own this string: {}\"\u003c/span\u003e, some_string);\n} \u003cspan class=\"hljs-comment\"\u003e// some_string 离开作用域，其内存被自动释放\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 一个函数，展示借用\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eborrow_and_print\u003c/span\u003e(some_string: \u0026#x26;\u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e// some_string 是一个不可变借用\u003c/span\u003e\n    \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"I'm borrowing this string: {}\"\u003c/span\u003e, some_string);\n} \u003cspan class=\"hljs-comment\"\u003e// some_string 离开作用域，借用结束\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 一个函数，展示可变借用\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eborrow_and_change\u003c/span\u003e(some_string: \u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e) { \u003cspan class=\"hljs-comment\"\u003e// some_string 是一个可变借用\u003c/span\u003e\n    some_string.\u003cspan class=\"hljs-title function_ invoke__\"\u003epush_str\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\" and I was changed!\"\u003c/span\u003e);\n} \u003cspan class=\"hljs-comment\"\u003e// some_string 离开作用域，借用结束\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 演示函数\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edemo_rust_mem\u003c/span\u003e() {\n  \u003cspan class=\"hljs-comment\"\u003e// --- 1. 所有权示例 ---\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003es1\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"hello world\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// s1 拥有 \"hello world\" 的所有权\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003es2\u003c/span\u003e = s1; \u003cspan class=\"hljs-comment\"\u003e// 所有权从 s1 移动(move)到 s2\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 在这一点之后，s1 不再有效！编译器会报错\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// println!(\"s1 is: {}\", s1); // 编译错误！value borrowed here after move\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"s2 is: {}\"\u003c/span\u003e, s2);\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 调用函数，所有权被转移\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003es3\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"take me away\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_ invoke__\"\u003etake_ownership\u003c/span\u003e(s3);\n  \u003cspan class=\"hljs-comment\"\u003e// println!(\"s3 is: {}\", s3); // 编译错误！s3 的所有权已被转移\u003c/span\u003e\n  \n  \u003cspan class=\"hljs-comment\"\u003e// --- 2. 借用示例 ---\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n--- 借用示例 ---\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003es4\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"this is a borrowed string\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_ invoke__\"\u003eborrow_and_print\u003c/span\u003e(\u0026#x26;s4); \u003cspan class=\"hljs-comment\"\u003e// s4 的借用被传递\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"s4 is still valid after borrowing: {}\"\u003c/span\u003e, s4); \u003cspan class=\"hljs-comment\"\u003e// 借用结束后，s4 仍然有效\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// --- 3. 可变借用示例 ---\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n--- 可变借用示例 ---\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003es5\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"I am mutable\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_ invoke__\"\u003eborrow_and_change\u003c/span\u003e(\u0026#x26;\u003cspan class=\"hljs-keyword\"\u003emut\u003c/span\u003e s5);\n  \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"s5 has been changed: {}\"\u003c/span\u003e, s5);\n  \n  \u003cspan class=\"hljs-comment\"\u003e// --- 4. 借用冲突示例 ---\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"\\n--- 借用冲突示例 ---\"\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003emut \u003c/span\u003e\u003cspan class=\"hljs-variable\"\u003es6\u003c/span\u003e = \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e::\u003cspan class=\"hljs-title function_ invoke__\"\u003efrom\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"I have multiple references\"\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 允许多个不可变借用\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003er1\u003c/span\u003e = \u0026#x26;s6;\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003er2\u003c/span\u003e = \u0026#x26;s6;\n  \u003cspan class=\"hljs-built_in\"\u003eprintln!\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"{} and {}\"\u003c/span\u003e, r1, r2);\n  \n  \u003cspan class=\"hljs-comment\"\u003e// 但是，在不可变借用之后，不允许可变借用\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// let r3 = \u0026#x26;mut s6; // 编译错误！cannot borrow as mutable...\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// --- 5. 悬空指针（编译器会阻止） ---\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 下面的函数无法编译，因为它会返回一个悬空引用\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// fn dangle() -\u003e \u0026#x26;String {\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e//     let s = String::from(\"dangling\"); // s 在这里被创建\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e//     \u0026#x26;s // 返回 s 的引用\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// } // s 在这里离开作用域并被销毁，其引用变成悬空指针！\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 编译器会报错：`s` does not live long enough\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e可以看出，Rust通过这种所有权机制管理内存，在编译阶段就把可能引发内存问题的逻辑给杜绝了，保障了内存的安全性，同时这种方式不依赖GC，效率更高。\u003c/p\u003e\n\u003ch2 id=\"五综合对比与选择指南\"\u003e五、综合对比与选择指南\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#五综合对比与选择指南\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e结合三种语言的内存管理机制来比较。C++适用于对性能有极致的要求，另外如果要对底层硬件的控制，C++语言是必要的，但是使用C++就会引入复杂的系统编程。对于Go来说，适用于时间不敏感，例如高并发网络服务，后端服务开发，以及快速迭代的业务系统，它相比于C++和Rust来说，语法更加容易入手，相对简单。但是如果要开发的系统对于内存安全性有很高要求，同时又要保证很高的性能，那么Rust将是一个不错的选项，例如证券交易类系统，还有嵌入式系统，以及操作系统都是可以适用的。\u003c/p\u003e\n\u003cp\u003e总的来说，不同语言有不同的内存管理方案，没有最好的方案，只有最适合的特定项目的方案。不过随着行业发展，内存安全是编程语言的重要发展方向，Rust的所有权模式将是一个新颖的思路。\u003c/p\u003e"])</script><script>self.__next_f.push([1,"7:[\"$\",\"$L15\",null,{\"postData\":{\"id\":\"advlangmemmanagement\",\"contentHtml\":\"$16\",\"title\":\"高级语言内存管理那些事：C++、Go 与 Rust 的对决\",\"date\":\"$D2024-04-20T20:14:02.000Z\",\"updated\":\"$D2024-04-20T20:14:02.000Z\",\"categories\":[\"随笔\"],\"tags\":[\"C++\",\"Rust\",\"Go\"]}}]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"14:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"高级语言内存管理那些事：C++、Go 与 Rust 的对决\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"HCHEN90 博客\"}],[\"$\",\"link\",\"2\",{\"rel\":\"alternate\",\"type\":\"application/atom+xml\",\"href\":\"https://hchen90.top/atom.xml\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]],\"error\":null,\"digest\":\"$undefined\"}\ne:{\"metadata\":\"$14:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>