<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/283bb1ed86b49fd2.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/09ec4099fb721b31.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/09dfadb69bdaa005.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/54b9acc791aa599c.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-ede82f7d0ae11dac.js"/><script src="/_next/static/chunks/4bd1b696-299743f5624cdabe.js" async=""></script><script src="/_next/static/chunks/684-481501000630d05e.js" async=""></script><script src="/_next/static/chunks/main-app-338894f2f2966ee4.js" async=""></script><script src="/_next/static/chunks/766-f505dbd3efffaa4c.js" async=""></script><script src="/_next/static/chunks/226-13d4d3f1fc18ceb6.js" async=""></script><script src="/_next/static/chunks/app/layout-c0c1784047774695.js" async=""></script><script src="/_next/static/chunks/874-e909718850e7282e.js" async=""></script><script src="/_next/static/chunks/734-02ba314a893e68e9.js" async=""></script><script src="/_next/static/chunks/47-b8631d93eb2d4d4a.js" async=""></script><script src="/_next/static/chunks/app/post/%5B...id%5D/page-deb68fe2aa3692cd.js" async=""></script><title>JNI函数调用之线程安全问题</title><meta name="description" content="HCHEN90 博客"/><link rel="alternate" type="application/atom+xml" href="https://hchen90.top/atom.xml"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="antialiased relative"><div class="fixed top-4 right-4 z-50"><a href="https://github.com/hchen90" target="_blank" rel="noopener noreferrer" class="flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300" title="Visit my GitHub profile"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a></div><div class="min-h-screen relative"><div class="fixed top-0 left-0 h-1 bg-blue-500 z-50 transition-all duration-300" style="width:0%"></div><button class="fixed bottom-24 right-8 p-3 rounded-full bg-blue-600 hover:bg-blue-700 text-white shadow-lg transition-opacity duration-300 z-50 opacity-0 pointer-events-none" aria-label="Back to top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"></path></svg></button><div class="main-content transition-all duration-300"><div class="max-w-4xl mx-auto px-4 py-8"><div class="mb-8"><a class="text-blue-500 hover:underline mb-4 inline-block" href="/">← 返回首页</a></div><article><header class="mb-8"><h1 class="text-4xl font-bold mb-4">JNI函数调用之线程安全问题</h1><div class="text-gray-500 mb-4">2021年11月30日</div></header><div class="markdown-content"><h1 id="jni-开发是什么">JNI 开发是什么<a aria-hidden="true" tabindex="-1" href="#jni-开发是什么"><span class="anchor-link"> #</span></a></h1>
<p>因本人以前工作中做过此类工作，再加上老同事的疑问，所以，今天抽出时间来探讨一下JNI的开发问题和特定细节（调用的线程安全问题），其实这种JNI层调用和任何其他语言调用C/C++层结构都差不多，比如说CGO，其涉及到Golang和C/C++层的调用，很多方面都存在类似之处。</p>
<p>JNI开发是使用Java提供的本地化接口，比如C/C++（也可以是其他语言），允许Java虚拟机里面的已经编译的代码和外界的本地化代码进行交互。</p>
<blockquote>
<p>因为Java是推崇平台可移植性的，本地化代码看起来破坏了可移植性，但是很多时候却是不可避免的，因为很多时候Java是无法实现一些比较底层功能的。</p>
</blockquote>
<h1 id="jni开发需要哪些工具">JNI开发需要哪些工具<a aria-hidden="true" tabindex="-1" href="#jni开发需要哪些工具"><span class="anchor-link"> #</span></a></h1>
<p>在我的机器里面是安装的OpenJDK11和GCC11，运行平台是Linux环境，为了提高编码效率，我使用的是VSCode，外加Java插件，CMake插件和C++插件。</p>
<p>这里列举一下工具链：</p>
<ul>
<li>OpenJDK 11</li>
<li>GCC 11</li>
<li>CMake 3.21</li>
<li>VSCode 最新版</li>
</ul>
<p>截图：</p>
<p><img src="/post/jnithreadsafe/8025a99f2589.png" alt="vscode"></p>
<blockquote>
<p>关于OpenJDK为何找不到javah，可以参考<a href="http://openjdk.java.net/jeps/313">这里</a>，意思就是javah已经被移除了，现在可以通过javac来完成同样的操作：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">javac -cp . -h abc MyCls.java
</code></pre></div>
<p>以上假设在当前目录的MyCls.java存在本地调用，它会在当前目录下创建一个abc目录，并且写入C++层的JNI调用头文件，你只需要在写一个和之对应的C++源代码即可。</p>
</blockquote>
<h1 id="术语解释">术语解释<a aria-hidden="true" tabindex="-1" href="#术语解释"><span class="anchor-link"> #</span></a></h1>
<p>其实<strong>线程安全</strong>是什么意思都可以通过搜索找到，也许你已经知道什么意思，不过这里不妨碍我再叙述一遍：</p>
<p>线程安全是指某个函数在多线程的环境下被多次调用时，能够使得多线程的每个调用者都可以得到自己想要的正确结果。</p>
<h1 id="主要因素">主要因素<a aria-hidden="true" tabindex="-1" href="#主要因素"><span class="anchor-link"> #</span></a></h1>
<p>产生线程安全问题的原因是因为<strong>函数调用需要对公共变量进行修改</strong></p>
<p>这会涉及到四种情形：</p>
<ul>
<li>静态Java本地调用改C++层的公共数据</li>
<li>静态Java本地调用改Java层的公共数据</li>
<li>动态Java本地调用改C++层的公共数据</li>
<li>动态Java本地调用改Java层的公共数据</li>
</ul>
<p>所以说只要涉及到公共数据都会产生线程安全的问题。</p>
<blockquote>
<p>至于什么是静态/动态Java本地调用？区别就是对应本地调用是否被static修饰，修饰者属于类的调用，否则属于被申请的对象的调用，与之分别对应静态/动态调用。</p>
<p>还有C++/Java层公共数据是什么？C++层的公共数据就是C++里面全局可以访问的变量，而这里的Java层公共变量指的是用C++访问/修改在Java类或者Java对象中的公共变量。</p>
</blockquote>
<h1 id="实例操作">实例操作<a aria-hidden="true" tabindex="-1" href="#实例操作"><span class="anchor-link"> #</span></a></h1>
<p>以下我写了一个demo用于阐述JNI调用的线程安全的问题。</p>
<h2 id="java部分">Java部分<a aria-hidden="true" tabindex="-1" href="#java部分"><span class="anchor-link"> #</span></a></h2>
<p>java部分的代码写得很简单，声明了几个本地JNI接口，并在main中调用之：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">java</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCls</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> {
    <span class="hljs-keyword">if</span> (loadLibrary()) {
      sayHello();

      <span class="hljs-type">ConSt</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConSt</span>();

      threadSafe(st); <span class="hljs-comment">// 只要传进的st唯一即可达到线程安全的要求</span>

      System.out.println(mySafeInt);
      System.out.println(st.mInt);

      System.out.printf(<span class="hljs-string">"unsafe int:%d\n"</span>, threadUnsafe());

      <span class="hljs-type">MyCls</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCls</span>();
      obj.threadUnsafe2();
      System.out.printf(<span class="hljs-string">"unsafe int:%d\n"</span>, obj.myUnsafeInt);
    }
  }

  <span class="hljs-comment">// 加载c动态库</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">loadLibrary</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">try</span> {
      System.loadLibrary(<span class="hljs-string">"abc"</span>);
    } <span class="hljs-keyword">catch</span>(SecurityException e) {
      e.printStackTrace();
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">catch</span>(UnsatisfiedLinkError e) {
      e.printStackTrace();
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">mySafeInt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">myUnsafeInt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 本地化接口</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadSafe</span><span class="hljs-params">(ConSt st)</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">threadUnsafe</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 使用了C++层的公共变量，且没有加锁机制</span>
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">threadUnsafe2</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 使用了Java层的公共变量，且没有加锁机制</span>
}
</code></pre></div>
<p>上面的主体部分就是这三个本地调用的使用，<code>threadSafe()</code>实际上可以拆开成两个函数的，注意下面的C++部分的代码，为了省事，我把写在一块了。</p>
<p><code>threadSafe()</code>是线程安全的在任意调用次数后，都会返回正确的结果，而下面的<code>threadUnsafe()</code>和<code>threadUnsafe2()</code>则不是线程安全的，在很多线程执行时会得到混乱的结果。</p>
<h2 id="cc部分">C/C++部分<a aria-hidden="true" tabindex="-1" href="#cc部分"><span class="anchor-link"> #</span></a></h2>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">c++</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-c++">std::mutex mu_thread_safe;

<span class="hljs-comment">/*
 * Class:     MyCls
 * Method:    threadSafe
 * Signature: (LConSt;)V
 */</span>
<span class="hljs-function">JNIEXPORT <span class="hljs-type">void</span> JNICALL <span class="hljs-title">Java_MyCls_threadSafe</span>
  <span class="hljs-params">(JNIEnv *env, jclass clz, jobject cons_st)</span> </span>{
    <span class="hljs-comment">// -- 1 -- 使用C++的互斥锁来阻塞操作，这样可以保证线程安全</span>
    jfieldID _fieldId = env-><span class="hljs-built_in">GetStaticFieldID</span>(clz, <span class="hljs-string">"mySafeInt"</span>, <span class="hljs-string">"J"</span>); <span class="hljs-comment">// 获得类中的静态成员变量</span>

    mu_thread_safe.<span class="hljs-built_in">lock</span>();
    env-><span class="hljs-built_in">SetStaticLongField</span>(clz, _fieldId, <span class="hljs-number">12345</span>); <span class="hljs-comment">// 这里通过互斥锁来达到线程安全</span>
    mu_thread_safe.<span class="hljs-built_in">unlock</span>();

    <span class="hljs-comment">// -- 2 -- 通过形式参数形式传递变量进入，只要保证形参不同即可线程安全</span>
    jclass _cs_clz = env-><span class="hljs-built_in">FindClass</span>(<span class="hljs-string">"ConSt"</span>);
    <span class="hljs-built_in">assert</span>(_cs_clz != <span class="hljs-literal">nullptr</span>);
    jfieldID _cs_fieldId = env-><span class="hljs-built_in">GetFieldID</span>(_cs_clz, <span class="hljs-string">"mInt"</span>, <span class="hljs-string">"J"</span>);
    env-><span class="hljs-built_in">SetLongField</span>(cons_st, _cs_fieldId, <span class="hljs-number">12345</span>);
  }

<span class="hljs-comment">/*
 * Class:     MyCls
 * Method:    threadUnsafe
 * Signature: ()V
 */</span>
<span class="hljs-function">JNIEXPORT jint JNICALL <span class="hljs-title">Java_MyCls_threadUnsafe</span>
  <span class="hljs-params">(JNIEnv *, jclass)</span> </span>{
    <span class="hljs-comment">// -- 3 -- 在C++层存储公共数据，并进行改写不加锁，不是线程安全的</span>
    <span class="hljs-type">static</span> <span class="hljs-type">int</span> _unsafe_int = <span class="hljs-number">0</span>;
    _unsafe_int++; <span class="hljs-comment">// 这里不加任何互斥锁机制</span>
    <span class="hljs-keyword">return</span> _unsafe_int;
  }

<span class="hljs-comment">/*
 * Class:     MyCls
 * Method:    threadUnsafe2
 * Signature: ()V
 */</span>
<span class="hljs-function">JNIEXPORT <span class="hljs-type">void</span> JNICALL <span class="hljs-title">Java_MyCls_threadUnsafe2</span>
  <span class="hljs-params">(JNIEnv *env, jobject obj)</span> </span>{
    <span class="hljs-comment">// -- 4 -- 或者C++层操作的公共数据是在java层的变量，亦不加锁，也不是线程安全的</span>
    jclass _clz = env-><span class="hljs-built_in">FindClass</span>(<span class="hljs-string">"MyCls"</span>);
    <span class="hljs-built_in">assert</span>(_clz != <span class="hljs-literal">nullptr</span>);
    jfieldID fieldId = env-><span class="hljs-built_in">GetFieldID</span>(_clz, <span class="hljs-string">"myUnsafeInt"</span>, <span class="hljs-string">"J"</span>);
    <span class="hljs-built_in">assert</span>(fieldId != <span class="hljs-literal">nullptr</span>);
    jlong myUnsafeInt = env-><span class="hljs-built_in">GetLongField</span>(obj, fieldId) + <span class="hljs-number">1</span>;
    env-><span class="hljs-built_in">SetLongField</span>(obj, fieldId, myUnsafeInt);
  }
</code></pre></div>
<p>以上四处标识中，第一个函数<code>threadSafe()</code>处，通过C++的互斥锁来对公共变量修改是一种方案，但是它对于大量并发的操作而言，效率低下，因为它是互斥线性化的，所以一般推荐第二处标识的方案，它让用户传递一个自定义的类型对象，C++层就对这个对象进行修改，调用者负责它传递的对象唯一，那么对于大量的并发操作而言，得到的结果也必然是正确的。</p>
<p>对于第三处和第四处是线程安全要求下不能满足的反例，第三处是没有对C++层公共数据添加加锁机制，而第四处是和第三处类似的，不同之处在于它的修改是在Java代码里的变量。</p>
<blockquote>
<p>关于GetFiledID()的第四个参数<code>sign</code>是什么意思？它是Java代码对这个函数的表述，可以参照下面这张图（还是从别人的那里截图过来的），更多详情可以查找官方文档。</p>
<p><img src="/post/jnithreadsafe/327d2bc302b0.png" alt="sign"></p>
</blockquote>
<h1 id="总结">总结<a aria-hidden="true" tabindex="-1" href="#总结"><span class="anchor-link"> #</span></a></h1>
<p>保证线程安全的要求是对<strong>公共资源</strong>恰当使用，最好不要用公共资源，让调用者传递参数值作为修改变量来使用，效果最佳。</p>
<p>链接：
demo<a href="src.tar.gz">下载</a></p></div><div class="mt-12 pt-6 border-t border-gray-200 dark:border-gray-700"><a class="text-blue-500 hover:underline" href="/">← 返回所有文章列表</a></div><div class="mt-8 pt-4 border-t border-gray-200 dark:border-gray-700 text-center text-gray-500 text-sm">© 2013 – 2025 陈祥</div></article></div></div></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-ede82f7d0ae11dac.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n4:I[415,[\"766\",\"static/chunks/766-f505dbd3efffaa4c.js\",\"226\",\"static/chunks/226-13d4d3f1fc18ceb6.js\",\"177\",\"static/chunks/app/layout-c0c1784047774695.js\"],\"default\"]\n5:I[9243,[\"766\",\"static/chunks/766-f505dbd3efffaa4c.js\",\"226\",\"static/chunks/226-13d4d3f1fc18ceb6.js\",\"177\",\"static/chunks/app/layout-c0c1784047774695.js\"],\"\"]\n8:I[9665,[],\"MetadataBoundary\"]\na:I[9665,[],\"OutletBoundary\"]\nd:I[4911,[],\"AsyncMetadataOutlet\"]\nf:I[9665,[],\"ViewportBoundary\"]\n11:I[6614,[],\"\"]\n:HL[\"/_next/static/css/283bb1ed86b49fd2.css\",\"style\"]\n:HL[\"/_next/static/css/09ec4099fb721b31.css\",\"style\"]\n:HL[\"/_next/static/css/09dfadb69bdaa005.css\",\"style\"]\n:HL[\"/_next/static/css/54b9acc791aa599c.css\",\"style\"]\n6:T4a2,\n          function copyCode(button) {\n            // Find the code element within the same wrapper\n            const codeWrapper = button.closest('.code-block-wrapper');\n            if (!codeWrapper) return;\n            \n            const codeElement = codeWrapper.querySelector('code');\n            if (!codeElement) return;\n            \n            // Get the text content\n            const text = codeElement.textContent;\n            \n            // Use the clipboard API to copy the text\n            navigator.clipboard.writeText(text).then(() =\u003e {\n              // Update the button state to show \"Copied!\"\n              button.setAttribute('data-copy-state', 'copied');\n              const buttonText = button.querySelector('.copy-button-text');\n              if (buttonText) buttonText.textContent = 'Copied!';\n              \n              // Reset after 2 seconds\n              setTimeout(() =\u003e {\n                button.setAttribute('data-copy-state', 'copy');\n                if (buttonText) buttonText.textContent = 'Copy';\n              }, 2000);\n            }).catch(err =\u003e {\n              console.error('Failed to copy text: ', err);\n            });\n          }\n          "])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"bvXmrLIJiTuq5pCczDHLW\",\"p\":\"\",\"c\":[\"\",\"post\",\"jnithreadsafe\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"post\",{\"children\":[[\"id\",\"jnithreadsafe\",\"c\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/283bb1ed86b49fd2.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09ec4099fb721b31.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09dfadb69bdaa005.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased relative\",\"children\":[[\"$\",\"div\",null,{\"className\":\"fixed top-4 right-4 z-50\",\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/hchen90\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"className\":\"flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300\",\"title\":\"Visit my GitHub profile\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":\"24\",\"height\":\"24\",\"viewBox\":\"0 0 24 24\",\"fill\":\"currentColor\",\"children\":[\"$\",\"path\",null,{\"d\":\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"}]}]}]}],[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"$L4\",null,{}],[\"$\",\"$L5\",null,{\"id\":\"code-copy\",\"children\":\"$6\"}]]}]}]]}],{\"children\":[\"post\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"id\",\"jnithreadsafe\",\"c\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/54b9acc791aa599c.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"_0Er3fhfP14pp6aAe1ORJ\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:\"$Sreact.suspense\"\n13:I[4911,[],\"AsyncMetadata\"]\n9:[\"$\",\"$12\",null,{\"fallback\":null,\"children\":[\"$\",\"$L13\",null,{\"promise\":\"$@14\"}]}]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script><script>self.__next_f.push([1,"15:I[9543,[\"874\",\"static/chunks/874-e909718850e7282e.js\",\"734\",\"static/chunks/734-02ba314a893e68e9.js\",\"47\",\"static/chunks/47-b8631d93eb2d4d4a.js\",\"925\",\"static/chunks/app/post/%5B...id%5D/page-deb68fe2aa3692cd.js\"],\"default\"]\n16:T36eb,"])</script><script>self.__next_f.push([1,"\u003ch1 id=\"jni-开发是什么\"\u003eJNI 开发是什么\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#jni-开发是什么\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e因本人以前工作中做过此类工作，再加上老同事的疑问，所以，今天抽出时间来探讨一下JNI的开发问题和特定细节（调用的线程安全问题），其实这种JNI层调用和任何其他语言调用C/C++层结构都差不多，比如说CGO，其涉及到Golang和C/C++层的调用，很多方面都存在类似之处。\u003c/p\u003e\n\u003cp\u003eJNI开发是使用Java提供的本地化接口，比如C/C++（也可以是其他语言），允许Java虚拟机里面的已经编译的代码和外界的本地化代码进行交互。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e因为Java是推崇平台可移植性的，本地化代码看起来破坏了可移植性，但是很多时候却是不可避免的，因为很多时候Java是无法实现一些比较底层功能的。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"jni开发需要哪些工具\"\u003eJNI开发需要哪些工具\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#jni开发需要哪些工具\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e在我的机器里面是安装的OpenJDK11和GCC11，运行平台是Linux环境，为了提高编码效率，我使用的是VSCode，外加Java插件，CMake插件和C++插件。\u003c/p\u003e\n\u003cp\u003e这里列举一下工具链：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eOpenJDK 11\u003c/li\u003e\n\u003cli\u003eGCC 11\u003c/li\u003e\n\u003cli\u003eCMake 3.21\u003c/li\u003e\n\u003cli\u003eVSCode 最新版\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e截图：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/post/jnithreadsafe/8025a99f2589.png\" alt=\"vscode\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关于OpenJDK为何找不到javah，可以参考\u003ca href=\"http://openjdk.java.net/jeps/313\"\u003e这里\u003c/a\u003e，意思就是javah已经被移除了，现在可以通过javac来完成同样的操作：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003ejavac -cp . -h abc MyCls.java\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e以上假设在当前目录的MyCls.java存在本地调用，它会在当前目录下创建一个abc目录，并且写入C++层的JNI调用头文件，你只需要在写一个和之对应的C++源代码即可。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"术语解释\"\u003e术语解释\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#术语解释\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e其实\u003cstrong\u003e线程安全\u003c/strong\u003e是什么意思都可以通过搜索找到，也许你已经知道什么意思，不过这里不妨碍我再叙述一遍：\u003c/p\u003e\n\u003cp\u003e线程安全是指某个函数在多线程的环境下被多次调用时，能够使得多线程的每个调用者都可以得到自己想要的正确结果。\u003c/p\u003e\n\u003ch1 id=\"主要因素\"\u003e主要因素\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#主要因素\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e产生线程安全问题的原因是因为\u003cstrong\u003e函数调用需要对公共变量进行修改\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这会涉及到四种情形：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e静态Java本地调用改C++层的公共数据\u003c/li\u003e\n\u003cli\u003e静态Java本地调用改Java层的公共数据\u003c/li\u003e\n\u003cli\u003e动态Java本地调用改C++层的公共数据\u003c/li\u003e\n\u003cli\u003e动态Java本地调用改Java层的公共数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e所以说只要涉及到公共数据都会产生线程安全的问题。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e至于什么是静态/动态Java本地调用？区别就是对应本地调用是否被static修饰，修饰者属于类的调用，否则属于被申请的对象的调用，与之分别对应静态/动态调用。\u003c/p\u003e\n\u003cp\u003e还有C++/Java层公共数据是什么？C++层的公共数据就是C++里面全局可以访问的变量，而这里的Java层公共变量指的是用C++访问/修改在Java类或者Java对象中的公共变量。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"实例操作\"\u003e实例操作\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#实例操作\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e以下我写了一个demo用于阐述JNI调用的线程安全的问题。\u003c/p\u003e\n\u003ch2 id=\"java部分\"\u003eJava部分\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#java部分\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003ejava部分的代码写得很简单，声明了几个本地JNI接口，并在main中调用之：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003ejava\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-java\"\u003e\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyCls\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003epublic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003emain\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(String[] args)\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (loadLibrary()) {\n      sayHello();\n\n      \u003cspan class=\"hljs-type\"\u003eConSt\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003est\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eConSt\u003c/span\u003e();\n\n      threadSafe(st); \u003cspan class=\"hljs-comment\"\u003e// 只要传进的st唯一即可达到线程安全的要求\u003c/span\u003e\n\n      System.out.println(mySafeInt);\n      System.out.println(st.mInt);\n\n      System.out.printf(\u003cspan class=\"hljs-string\"\u003e\"unsafe int:%d\\n\"\u003c/span\u003e, threadUnsafe());\n\n      \u003cspan class=\"hljs-type\"\u003eMyCls\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003eobj\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eMyCls\u003c/span\u003e();\n      obj.threadUnsafe2();\n      System.out.printf(\u003cspan class=\"hljs-string\"\u003e\"unsafe int:%d\\n\"\u003c/span\u003e, obj.myUnsafeInt);\n    }\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 加载c动态库\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eboolean\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadLibrary\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      System.loadLibrary(\u003cspan class=\"hljs-string\"\u003e\"abc\"\u003c/span\u003e);\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(SecurityException e) {\n      e.printStackTrace();\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e(UnsatisfiedLinkError e) {\n      e.printStackTrace();\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    }\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003elong\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003emySafeInt\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003elong\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003emyUnsafeInt\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 本地化接口\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enative\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ethreadSafe\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e(ConSt st)\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enative\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ethreadUnsafe\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 使用了C++层的公共变量，且没有加锁机制\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enative\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evoid\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ethreadUnsafe2\u003c/span\u003e\u003cspan class=\"hljs-params\"\u003e()\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 使用了Java层的公共变量，且没有加锁机制\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e上面的主体部分就是这三个本地调用的使用，\u003ccode\u003ethreadSafe()\u003c/code\u003e实际上可以拆开成两个函数的，注意下面的C++部分的代码，为了省事，我把写在一块了。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ethreadSafe()\u003c/code\u003e是线程安全的在任意调用次数后，都会返回正确的结果，而下面的\u003ccode\u003ethreadUnsafe()\u003c/code\u003e和\u003ccode\u003ethreadUnsafe2()\u003c/code\u003e则不是线程安全的，在很多线程执行时会得到混乱的结果。\u003c/p\u003e\n\u003ch2 id=\"cc部分\"\u003eC/C++部分\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#cc部分\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003ec++\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-c++\"\u003estd::mutex mu_thread_safe;\n\n\u003cspan class=\"hljs-comment\"\u003e/*\n * Class:     MyCls\n * Method:    threadSafe\n * Signature: (LConSt;)V\n */\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003eJNIEXPORT \u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e JNICALL \u003cspan class=\"hljs-title\"\u003eJava_MyCls_threadSafe\u003c/span\u003e\n  \u003cspan class=\"hljs-params\"\u003e(JNIEnv *env, jclass clz, jobject cons_st)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// -- 1 -- 使用C++的互斥锁来阻塞操作，这样可以保证线程安全\u003c/span\u003e\n    jfieldID _fieldId = env-\u003e\u003cspan class=\"hljs-built_in\"\u003eGetStaticFieldID\u003c/span\u003e(clz, \u003cspan class=\"hljs-string\"\u003e\"mySafeInt\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"J\"\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 获得类中的静态成员变量\u003c/span\u003e\n\n    mu_thread_safe.\u003cspan class=\"hljs-built_in\"\u003elock\u003c/span\u003e();\n    env-\u003e\u003cspan class=\"hljs-built_in\"\u003eSetStaticLongField\u003c/span\u003e(clz, _fieldId, \u003cspan class=\"hljs-number\"\u003e12345\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 这里通过互斥锁来达到线程安全\u003c/span\u003e\n    mu_thread_safe.\u003cspan class=\"hljs-built_in\"\u003eunlock\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-comment\"\u003e// -- 2 -- 通过形式参数形式传递变量进入，只要保证形参不同即可线程安全\u003c/span\u003e\n    jclass _cs_clz = env-\u003e\u003cspan class=\"hljs-built_in\"\u003eFindClass\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"ConSt\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-built_in\"\u003eassert\u003c/span\u003e(_cs_clz != \u003cspan class=\"hljs-literal\"\u003enullptr\u003c/span\u003e);\n    jfieldID _cs_fieldId = env-\u003e\u003cspan class=\"hljs-built_in\"\u003eGetFieldID\u003c/span\u003e(_cs_clz, \u003cspan class=\"hljs-string\"\u003e\"mInt\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"J\"\u003c/span\u003e);\n    env-\u003e\u003cspan class=\"hljs-built_in\"\u003eSetLongField\u003c/span\u003e(cons_st, _cs_fieldId, \u003cspan class=\"hljs-number\"\u003e12345\u003c/span\u003e);\n  }\n\n\u003cspan class=\"hljs-comment\"\u003e/*\n * Class:     MyCls\n * Method:    threadUnsafe\n * Signature: ()V\n */\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003eJNIEXPORT jint JNICALL \u003cspan class=\"hljs-title\"\u003eJava_MyCls_threadUnsafe\u003c/span\u003e\n  \u003cspan class=\"hljs-params\"\u003e(JNIEnv *, jclass)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// -- 3 -- 在C++层存储公共数据，并进行改写不加锁，不是线程安全的\u003c/span\u003e\n    \u003cspan class=\"hljs-type\"\u003estatic\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eint\u003c/span\u003e _unsafe_int = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e;\n    _unsafe_int++; \u003cspan class=\"hljs-comment\"\u003e// 这里不加任何互斥锁机制\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _unsafe_int;\n  }\n\n\u003cspan class=\"hljs-comment\"\u003e/*\n * Class:     MyCls\n * Method:    threadUnsafe2\n * Signature: ()V\n */\u003c/span\u003e\n\u003cspan class=\"hljs-function\"\u003eJNIEXPORT \u003cspan class=\"hljs-type\"\u003evoid\u003c/span\u003e JNICALL \u003cspan class=\"hljs-title\"\u003eJava_MyCls_threadUnsafe2\u003c/span\u003e\n  \u003cspan class=\"hljs-params\"\u003e(JNIEnv *env, jobject obj)\u003c/span\u003e \u003c/span\u003e{\n    \u003cspan class=\"hljs-comment\"\u003e// -- 4 -- 或者C++层操作的公共数据是在java层的变量，亦不加锁，也不是线程安全的\u003c/span\u003e\n    jclass _clz = env-\u003e\u003cspan class=\"hljs-built_in\"\u003eFindClass\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"MyCls\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-built_in\"\u003eassert\u003c/span\u003e(_clz != \u003cspan class=\"hljs-literal\"\u003enullptr\u003c/span\u003e);\n    jfieldID fieldId = env-\u003e\u003cspan class=\"hljs-built_in\"\u003eGetFieldID\u003c/span\u003e(_clz, \u003cspan class=\"hljs-string\"\u003e\"myUnsafeInt\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"J\"\u003c/span\u003e);\n    \u003cspan class=\"hljs-built_in\"\u003eassert\u003c/span\u003e(fieldId != \u003cspan class=\"hljs-literal\"\u003enullptr\u003c/span\u003e);\n    jlong myUnsafeInt = env-\u003e\u003cspan class=\"hljs-built_in\"\u003eGetLongField\u003c/span\u003e(obj, fieldId) + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n    env-\u003e\u003cspan class=\"hljs-built_in\"\u003eSetLongField\u003c/span\u003e(obj, fieldId, myUnsafeInt);\n  }\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e以上四处标识中，第一个函数\u003ccode\u003ethreadSafe()\u003c/code\u003e处，通过C++的互斥锁来对公共变量修改是一种方案，但是它对于大量并发的操作而言，效率低下，因为它是互斥线性化的，所以一般推荐第二处标识的方案，它让用户传递一个自定义的类型对象，C++层就对这个对象进行修改，调用者负责它传递的对象唯一，那么对于大量的并发操作而言，得到的结果也必然是正确的。\u003c/p\u003e\n\u003cp\u003e对于第三处和第四处是线程安全要求下不能满足的反例，第三处是没有对C++层公共数据添加加锁机制，而第四处是和第三处类似的，不同之处在于它的修改是在Java代码里的变量。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e关于GetFiledID()的第四个参数\u003ccode\u003esign\u003c/code\u003e是什么意思？它是Java代码对这个函数的表述，可以参照下面这张图（还是从别人的那里截图过来的），更多详情可以查找官方文档。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/post/jnithreadsafe/327d2bc302b0.png\" alt=\"sign\"\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"总结\"\u003e总结\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#总结\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e保证线程安全的要求是对\u003cstrong\u003e公共资源\u003c/strong\u003e恰当使用，最好不要用公共资源，让调用者传递参数值作为修改变量来使用，效果最佳。\u003c/p\u003e\n\u003cp\u003e链接：\ndemo\u003ca href=\"src.tar.gz\"\u003e下载\u003c/a\u003e\u003c/p\u003e"])</script><script>self.__next_f.push([1,"7:[\"$\",\"$L15\",null,{\"postData\":{\"id\":\"jnithreadsafe\",\"contentHtml\":\"$16\",\"title\":\"JNI函数调用之线程安全问题\",\"date\":\"$D2021-11-29T23:03:02.000Z\",\"categories\":[\"随笔\"],\"tags\":[\"jni\",\"java\",\"cpp\"]}}]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"14:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"JNI函数调用之线程安全问题\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"HCHEN90 博客\"}],[\"$\",\"link\",\"2\",{\"rel\":\"alternate\",\"type\":\"application/atom+xml\",\"href\":\"https://hchen90.top/atom.xml\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]],\"error\":null,\"digest\":\"$undefined\"}\ne:{\"metadata\":\"$14:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>