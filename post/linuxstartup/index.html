<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/283bb1ed86b49fd2.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/09ec4099fb721b31.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/09dfadb69bdaa005.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/54b9acc791aa599c.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-ede82f7d0ae11dac.js"/><script src="/_next/static/chunks/4bd1b696-299743f5624cdabe.js" async=""></script><script src="/_next/static/chunks/684-481501000630d05e.js" async=""></script><script src="/_next/static/chunks/main-app-eb9456c5a3bb7ef4.js" async=""></script><script src="/_next/static/chunks/766-f505dbd3efffaa4c.js" async=""></script><script src="/_next/static/chunks/226-13d4d3f1fc18ceb6.js" async=""></script><script src="/_next/static/chunks/app/layout-b3ce58a25da6999d.js" async=""></script><script src="/_next/static/chunks/874-e909718850e7282e.js" async=""></script><script src="/_next/static/chunks/734-02ba314a893e68e9.js" async=""></script><script src="/_next/static/chunks/351-1a0463ef6ec6e59e.js" async=""></script><script src="/_next/static/chunks/app/post/%5Bid%5D/page-871a46f82159f9c4.js" async=""></script><title>Linux系统启动流程</title><meta name="description" content="HCHEN90 博客"/><link rel="alternate" type="application/atom+xml" href="https://hchen90.top/atom.xml"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="antialiased relative"><div class="fixed top-4 right-4 z-50"><a href="https://github.com/hchen90" target="_blank" rel="noopener noreferrer" class="flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300" title="Visit my GitHub profile"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a></div><div class="min-h-screen relative"><div class="fixed top-0 left-0 h-1 bg-blue-500 z-50 transition-all duration-300" style="width:0%"></div><button class="fixed bottom-24 right-8 p-3 rounded-full bg-blue-600 hover:bg-blue-700 text-white shadow-lg transition-opacity duration-300 z-50 opacity-0 pointer-events-none" aria-label="Back to top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"></path></svg></button><div class="main-content transition-all duration-300"><div class="max-w-4xl mx-auto px-4 py-8"><div class="mb-8"><a class="text-blue-500 hover:underline mb-4 inline-block" href="/">← 返回首页</a></div><article><header class="mb-8"><h1 class="text-4xl font-bold mb-4">Linux系统启动流程</h1><div class="text-gray-500 mb-4">2018年6月24日</div></header><div class="markdown-content"><h1 id="内核加载">内核加载<a aria-hidden="true" tabindex="-1" href="#内核加载"><span class="anchor-link"> #</span></a></h1>
<p>在<a href="/2018/06/16/systemstartup">上篇博文</a>里面我说明过计算机如何从远古到近代的启动流程，然后，走到操作系统一层的时候就没有深入阐述了，在这篇博文我将以Linux系统为例来叙述操作系统是如何启动的。</p>
<p>通常在系统<code>/boot</code>目录下放着内核文件，如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">initramfs-linux.img
vmlinuz-linux
</code></pre></div>
<p>GRUB（或者LILO）加载内核的时候，会把<code>vmlinuz-linux</code>映射到内存并会把它的一个初始根目录的文件镜像（<code>initramfs-linux.img</code>）作为文件系统加载到内存，系统会从这个迷你的初始化文件系统来启动，在这个迷你的文件系统里面又会加载真正的磁盘文件系统，带有这种<code>initramfs</code>的都是这种加载流程，但是，对于那种没有<code>initramfs</code>的（例如：Slackware发行版本），它是加载内核后，内核直接从磁盘加载文件系统，这种区分跟内核配置有关。</p>
<blockquote>
<p>内核初始化进行哪些操作？</p>
<p>内核初始操作属于操作系统内核部分的知识，一般来说，主体包括以下（还有很多细节可以参看Linux内核方面的书籍）：</p>
<ul>
<li>系统处于实模式需要切换到保护模式，所以需要设置GDT,LDT，设置平坦模式的内存寻址，在GDT,LDT寄存器里面，可以设置内存保护位，大小等等信息</li>
<li>原始的系统没有任何可以使用库，但是不要忘记BIOS提供的中断调用，还有BIOS设定好的各种IO端口，通过它们我们就可以获取和设置计算机信息，从而达到控制计算机，我们可以把它们封装出函数调用，为了兼容历史，我们需要保留部分低位中断，这样把这些函数写成中断调用（即设置IDT中断调用表），按UNIX规范提供一套SYSCALL</li>
<li>实际上，我们的计算机内存已经非常大了，所以我们往往需要一种快速定位寻址的机制，在没有硬件支持的时候用软件算法可以达到相似的效果，但是在Intel平台上，提供了Paging机制，利用这种机制我们只需要设置PDE表格（即页表），那么CPU就会自动就加载寻址，这就达到硬件加速的效果</li>
<li>但我们设置完了进程相关设置，内存相关设置后，接下来的就是文件系统，文件系统是操作系统的基本要素（目前来说是这样的），内核会按着磁盘上数据格式把文件信息读取，并在内存中构建一个文件存留信息的数据结构（一般不一定是位视图这种表格，多数情况要复杂一些，也就是多层次的可以拓展的树状构型）</li>
<li>外设是最复杂的部分，外设需要各种初始化，初始化过的外设才可以正常使用，一般这部分也叫设备驱动流程（这部分也可以延后加载，进行初始化）</li>
</ul>
</blockquote>
<h1 id="初始化程序加载">初始化程序加载<a aria-hidden="true" tabindex="-1" href="#初始化程序加载"><span class="anchor-link"> #</span></a></h1>
<p>当内核加载流程全部完成后（只要没有发生出错都会加载完成），内核会启动系统的第一个进程，它就是著名的<code>init</code>进程（pid为1），而现在随着开源社区的发展，出现过好多版本的init程序了，最老也是最稳定的是sysvinit，除此之外还有Upstart之流，不过systemd还是更受青睐，它也是目前互动最多的init初始化开源项目。</p>
<p>Systemd和sysvinit有很大的区别，所以这里分别介绍两者：</p>
<blockquote>
<p>Upstart是一个基于事件触发的异步初始化方案，和Sysvinit高度兼容，但这里不作讨论，相关介绍可以查阅其他介绍Upstart的博客或技术Wiki等等</p>
</blockquote>
<h2 id="sysvinit的流程">Sysvinit的流程<a aria-hidden="true" tabindex="-1" href="#sysvinit的流程"><span class="anchor-link"> #</span></a></h2>
<p>Sysvinit的启动可以把它看作两个部分：初始化，服务加载。</p>
<h3 id="初始化部分">初始化部分<a aria-hidden="true" tabindex="-1" href="#初始化部分"><span class="anchor-link"> #</span></a></h3>
<p>在Systvinit中，它会读取系统中的 <code>/etc/inittab</code>信息，从而来确定系统下一步的启动步骤。为了判断下一步步骤，系统有一个概念，叫做“运行级别”（runlevel），意思就是要确定以何种场景来启动系统，一般而言，Linux有如下7种运行级别：</p>
<ul>
<li>0 - 关机模式</li>
<li>1 - 单用户模式</li>
<li>2 - 多用户模式</li>
<li>3 - 多用户网络模式</li>
<li>4 - 自定义模式</li>
<li>5 - 完全模式</li>
<li>6 - 重启模式</li>
</ul>
<blockquote>
<p>Runlevel的定义可以参考<a href="https://en.wikipedia.org/wiki/Runlevel">维基百科的介绍</a></p>
</blockquote>
<p>针对不同的Linux发行版本，上述的定义值不一定相同。</p>
<p>当init程序读取了<code>/etc/inittab</code>中的信息时，该配置文件里面存放了各种运行级别所要进行的操作，假设有如下配置：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell"><span class="hljs-meta prompt_"># </span><span class="bash">These are the default runlevels <span class="hljs-keyword">in</span> Slackware:</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  0 = halt</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  1 = single user mode</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  2 = unused (but configured the same as runlevel 3)</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  3 = multiuser mode (default Slackware runlevel)</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  4 = X11 with KDM/GDM/XDM (session managers)</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  5 = unused (but configured the same as runlevel 3)</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  6 = reboot</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">Default runlevel. (Do not <span class="hljs-built_in">set</span> to 0 or 6)</span>
id:3:initdefault:
<span class="hljs-meta prompt_">
# </span><span class="bash">System initialization (runs when system boots).</span>
si:S:sysinit:/etc/rc.d/rc.S
<span class="hljs-meta prompt_">
# </span><span class="bash">Script to run when going single user (runlevel 1).</span>
su:1S:wait:/etc/rc.d/rc.K
<span class="hljs-meta prompt_">
# </span><span class="bash">Script to run when going multi user.</span>
rc:2345:wait:/etc/rc.d/rc.M
<span class="hljs-meta prompt_">
# </span><span class="bash">What to <span class="hljs-keyword">do</span> at the <span class="hljs-string">"Three Finger Salute"</span>.</span>
ca::ctrlaltdel:/sbin/shutdown -t5 -r now
<span class="hljs-meta prompt_">
# </span><span class="bash">Runlevel 0 halts the system.</span>
l0:0:wait:/etc/rc.d/rc.0
<span class="hljs-meta prompt_">
# </span><span class="bash">Runlevel 6 reboots the system.</span>
l6:6:wait:/etc/rc.d/rc.6
<span class="hljs-meta prompt_">
# </span><span class="bash">What to <span class="hljs-keyword">do</span> when power fails.</span>
pf::powerfail:/sbin/genpowerfail start
<span class="hljs-meta prompt_">
# </span><span class="bash">If power is back, cancel the running shutdown.</span>
pg::powerokwait:/sbin/genpowerfail stop
<span class="hljs-meta prompt_">
# </span><span class="bash">These are the standard console login getties <span class="hljs-keyword">in</span> multiuser mode:</span>
c1:12345:respawn:/sbin/agetty --noclear 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux
<span class="hljs-meta prompt_">
# </span><span class="bash">Local serial lines:</span>
<span class="hljs-meta prompt_">#</span><span class="bash">s1:12345:respawn:/sbin/agetty -L ttyS0 9600 vt100</span>
<span class="hljs-meta prompt_">#</span><span class="bash">s2:12345:respawn:/sbin/agetty -L ttyS1 9600 vt100</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">Dialup lines:</span>
<span class="hljs-meta prompt_">#</span><span class="bash">d1:12345:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS0 vt100</span>
<span class="hljs-meta prompt_">#</span><span class="bash">d2:12345:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS1 vt100</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">Runlevel 4 also starts /etc/rc.d/rc.4 to run a display manager <span class="hljs-keyword">for</span> X.</span>
<span class="hljs-meta prompt_"># </span><span class="bash">Display managers are preferred <span class="hljs-keyword">in</span> this order:  gdm, kdm, xdm</span>
x1:4:respawn:/etc/rc.d/rc.4
</code></pre></div>
<p>每一行可以看作是一个函数。</p>
<p>这样以来，第一列对应单个函数的ID（2-4个字母数字组合，只要不重复即可），第二列对应函数Runlevel的值，第三列对应内部Runlevel操作入口（action），第四列是函数要执行的程序或者脚本。</p>
<blockquote>
<p>对于函数的操作入口（action）存在如下几种：initdefault, sysinit, boot, bootwait, wait, respawn</p>
</blockquote>
<p>例如，以这个函数举例来说：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">id:3:initdefault:
</code></pre></div>
<p>当运行Runlevel为3时，就会执行initdefault的入口，它不需要执行脚本或程序，表示默认的Runlevel，其他的函数配置同理。</p>
<p>再看上面的inittab配置，如下这行：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">si:S:sysinit:/etc/rc.d/rc.S
</code></pre></div>
<p>它表示系统启动是就运行<code>/etc/rc.d/rc.S</code>脚本，在<code>/etc/rc.d/rc.S</code>脚本里面则包含：</p>
<ul>
<li>挂载<code>sysfs</code>文件目录节点</li>
<li>挂载<code>tmpfs</code>文件目录节点</li>
<li>挂载<code>proc</code>文件目录节点</li>
<li>挂载<code>cgroup</code>文件目录节点</li>
<li>启动其他的rc.XX脚本</li>
<li>加载需要的内核模块</li>
<li>检测文件系统</li>
<li>随机数设置</li>
<li>等等</li>
</ul>
<p>对于用多个Runlevel的函数：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">rc:2345:wait:/etc/rc.d/rc.M
</code></pre></div>
<p>表示在<code>2345</code>这4个Runlevel下，都会执行<code>/etc/rc.d/rc.M</code>，并等待它执行完成。</p>
<p>init的配置非常的清晰明了，它的启动脚本可以在目录<code>/etc/rc.d</code>下查看。</p>
<p>系统就是这样加载rc.d下的初始化脚本，序列化地完成所有的init初始化流程。</p>
<h3 id="加载服务">加载服务<a aria-hidden="true" tabindex="-1" href="#加载服务"><span class="anchor-link"> #</span></a></h3>
<p>Sysvinit中对于服务的加载是通过<code>/etc/rc.d</code>下的初始化脚本来执行的，一般情况下，一个服务都编写一个服务管理的Shell脚本，它可以接受：<code>status</code>，<code>start</code>，<code>stop</code>，<code>restart</code>这样的参数，并把它放在<code>/etc/rc.d/init.d</code>目录下面。</p>
<p>例如，有如下服务（<code>/etc/rc.d/init.d/vbox-usb-service</code>）：</p>
<p>我们就可以执行：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">/etc/rc.d/init.d/vbox-usb-service status
</code></pre></div>
<p>来查看此服务是否已经启动，但是一般情况下，系统会为了方便创建了一个软链接（如果系统没有创建该软链接，我们可以手动创建之）：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">/etc/init.d
</code></pre></div>
<p>该软链接指向<code>/etc/rc.d/init.d</code>，因此，我们也可以这样重启服务：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">/etc/init.d/vbox-usb-service restart
</code></pre></div>
<p>但是，这不是必须这样的组织方式，也可以把服务管理的脚本直接就放在<code>/etc/rc.d</code>目录下，例如：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">/etc/rc.d/rc.httpd
</code></pre></div>
<p>该脚本是用于Apache的httpd服务的管理脚本，执行：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">/etc/rc.d/rc.httpd start
</code></pre></div>
<p>即可完成httpd服务的启动。</p>
<blockquote>
<p>对于一些外部的第三方服务都是放在<code>/etc/rc.d/init.d</code>下面，这样这些脚本只要添加执行权限，就会被初始化脚本自动加载，而不用去更改初始化脚本；而在<code>/etc/rc.d</code>下的服务管理脚本则是Linux发行版本自带的服务，它已经在初始化脚本中做过判断设置，如果我们要把一个第三方的服务管理脚本放到<code>/etc/rc.d</code>下，就意味着我们必须要修改初始化脚本。</p>
</blockquote>
<h2 id="systemd的流程">Systemd的流程<a aria-hidden="true" tabindex="-1" href="#systemd的流程"><span class="anchor-link"> #</span></a></h2>
<p>Systemd中，所有的都以单元组件的形式来加载，这些单元组件很多都可以并发执行，达到快速加载的目的，单元组件的前件和后件构成一套稳定的加载系统。</p>
<h3 id="初始化加载">初始化加载<a aria-hidden="true" tabindex="-1" href="#初始化加载"><span class="anchor-link"> #</span></a></h3>
<blockquote>
<p>在以Systemd为init服务的Linux系统中，参看<code>man 7 bootup</code>，以了解更多有关Systemd的启动详情。</p>
</blockquote>
<h3 id="加载图示">加载图示<a aria-hidden="true" tabindex="-1" href="#加载图示"><span class="anchor-link"> #</span></a></h3>
<p><img src="/post/linuxstartup/5825be82891a.png" alt="systemd-graph"></p>
<p>由上图可见，在加载<code>sysinit</code>之前，可以加载很多的服务，而这些服务是互相独立无依赖的，因此可以并行地加载，当所有的服务都加载完后，<code>sysinit</code>服务就算加载成功，之后进行下面的服务加载，后面的加载逻辑以此类推。注意到，类似<code>rescue</code>这种是具有特殊用途的服务（这里的服务是用于系统崩溃后的拯救），还有一个独立依赖链，或者没有依赖的服务，被加载到目前的服务的情况，例如上图的<code>remote-fs</code>就是这种。</p>
<blockquote>
<p>上图绘制的systemd加载图比较粗糙，细节要复杂一些，有些一个单元的加载可能分好几个步骤来加载，有的可能细分更多的加载逻辑。</p>
</blockquote>
<h1 id="用户登录系统">用户登录系统<a aria-hidden="true" tabindex="-1" href="#用户登录系统"><span class="anchor-link"> #</span></a></h1>
<p>当系统必要的服务都启动后，会分为几种场景：</p>
<h2 id="runlevel-3-登录">Runlevel 3 登录<a aria-hidden="true" tabindex="-1" href="#runlevel-3-登录"><span class="anchor-link"> #</span></a></h2>
<p>在该模式下，用户自动进入ttyS1来登录系统，init会启动<code>/sbin/agetty</code>提示用户输入用户名和密码，getty和login判断用户合法就让用户进入系统，打开用户的Shell程序。</p>
<blockquote>
<p>上述配置，会产生6个用户可以同时登录。</p>
<p>此外，getty和login这种登录验证需要验证密码，通常是读取<code>/etc/passwd</code>下的保存设置来验证用户有效性。</p>
<p>（细节可以参考系统函数：<code>getpass</code>）</p>
</blockquote>
<h2 id="runlevel-4-登录">Runlevel 4 登录<a aria-hidden="true" tabindex="-1" href="#runlevel-4-登录"><span class="anchor-link"> #</span></a></h2>
<p>如果是多用户模式，会启动一个用于管理系统登录的服务（一般PolKit/ConsoleKit最常见），这里以ConsoleKit举例来说，它允许用户在同一硬件设备登录的情况下，不用登出系统还可以再次登录，ConsoleKit以抽象化成会话的模型，从而实现这种登录机制。</p>
<p>在图形登录下，都会使用这种方式来登录系统。</p>
<blockquote>
<p>在ConsoleKit的登录验证下，也是通过读取<code>/etc/passwd</code>配置文件的信息来验证用户有效性的。</p>
<p>（对于如何验证的细节，可以参考一个系统提供的安全相关的函数：<code>crypt</code>）</p>
</blockquote>
<h1 id="打开用户shellwdm程序">打开用户SHELL/WDM程序<a aria-hidden="true" tabindex="-1" href="#打开用户shellwdm程序"><span class="anchor-link"> #</span></a></h1>
<p>当用户输入名称和密码通过验证后，init程序需要为用户执行一个Shell运行程序，以便使用户能够对系统来进行管理，Shell的种类很多，根据用户的爱好，可以自由选择一款适合的Shell。</p>
<blockquote>
<p>常见的Shell有：Bash, Csh, Ash, Tcsh, Zsh等等</p>
</blockquote>
<p>Shell被启动后，它就接管了用户的空间，用户可以通过它以命令方式来完成任何操作。</p>
<blockquote>
<p>Shell的启动会读取系统全局配置，再基于用户$HOME目录下的配置文件，读取自定义的配置。</p>
</blockquote>
<p>通常对于图形界面的登录有一些不同，图形界面的登录启动的不是Shell，而是一个XWindows的WDM，即一个窗口管理器，它接管用户空间，为用户初始化图形化设置，并展示图形界面。</p>
<blockquote>
<p>常见的 WDM有：GDM，SDDM，KDM等等</p>
</blockquote></div><div class="mt-12 pt-6 border-t border-gray-200 dark:border-gray-700"><a class="text-blue-500 hover:underline" href="/">← 返回所有文章列表</a></div><div class="mt-8 pt-4 border-t border-gray-200 dark:border-gray-700 text-center text-gray-500 text-sm">© 2013 – 2025 陈祥</div></article></div></div></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-ede82f7d0ae11dac.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n4:I[415,[\"766\",\"static/chunks/766-f505dbd3efffaa4c.js\",\"226\",\"static/chunks/226-13d4d3f1fc18ceb6.js\",\"177\",\"static/chunks/app/layout-b3ce58a25da6999d.js\"],\"default\"]\n5:I[9243,[\"766\",\"static/chunks/766-f505dbd3efffaa4c.js\",\"226\",\"static/chunks/226-13d4d3f1fc18ceb6.js\",\"177\",\"static/chunks/app/layout-b3ce58a25da6999d.js\"],\"\"]\n8:I[9665,[],\"MetadataBoundary\"]\na:I[9665,[],\"OutletBoundary\"]\nd:I[4911,[],\"AsyncMetadataOutlet\"]\nf:I[9665,[],\"ViewportBoundary\"]\n11:I[6614,[],\"\"]\n:HL[\"/_next/static/css/283bb1ed86b49fd2.css\",\"style\"]\n:HL[\"/_next/static/css/09ec4099fb721b31.css\",\"style\"]\n:HL[\"/_next/static/css/09dfadb69bdaa005.css\",\"style\"]\n:HL[\"/_next/static/css/54b9acc791aa599c.css\",\"style\"]\n6:T4a2,\n          function copyCode(button) {\n            // Find the code element within the same wrapper\n            const codeWrapper = button.closest('.code-block-wrapper');\n            if (!codeWrapper) return;\n            \n            const codeElement = codeWrapper.querySelector('code');\n            if (!codeElement) return;\n            \n            // Get the text content\n            const text = codeElement.textContent;\n            \n            // Use the clipboard API to copy the text\n            navigator.clipboard.writeText(text).then(() =\u003e {\n              // Update the button state to show \"Copied!\"\n              button.setAttribute('data-copy-state', 'copied');\n              const buttonText = button.querySelector('.copy-button-text');\n              if (buttonText) buttonText.textContent = 'Copied!';\n              \n              // Reset after 2 seconds\n              setTimeout(() =\u003e {\n                button.setAttribute('data-copy-state', 'copy');\n                if (buttonText) buttonText.textContent = 'Copy';\n              }, 2000);\n            }).catch(err =\u003e {\n              console.error('Failed to copy text: ', err);\n            });\n          }\n          "])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"xsQ5PUF4c2cJqxppneo-C\",\"p\":\"\",\"c\":[\"\",\"post\",\"linuxstartup\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"post\",{\"children\":[[\"id\",\"linuxstartup\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/283bb1ed86b49fd2.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09ec4099fb721b31.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09dfadb69bdaa005.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased relative\",\"children\":[[\"$\",\"div\",null,{\"className\":\"fixed top-4 right-4 z-50\",\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/hchen90\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"className\":\"flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300\",\"title\":\"Visit my GitHub profile\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":\"24\",\"height\":\"24\",\"viewBox\":\"0 0 24 24\",\"fill\":\"currentColor\",\"children\":[\"$\",\"path\",null,{\"d\":\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"}]}]}]}],[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"$L4\",null,{}],[\"$\",\"$L5\",null,{\"id\":\"code-copy\",\"children\":\"$6\"}]]}]}]]}],{\"children\":[\"post\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"id\",\"linuxstartup\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/54b9acc791aa599c.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"frSpuNn6RIpzCZXEKQJFa\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:\"$Sreact.suspense\"\n13:I[4911,[],\"AsyncMetadata\"]\n9:[\"$\",\"$12\",null,{\"fallback\":null,\"children\":[\"$\",\"$L13\",null,{\"promise\":\"$@14\"}]}]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script><script>self.__next_f.push([1,"15:I[9543,[\"874\",\"static/chunks/874-e909718850e7282e.js\",\"734\",\"static/chunks/734-02ba314a893e68e9.js\",\"351\",\"static/chunks/351-1a0463ef6ec6e59e.js\",\"457\",\"static/chunks/app/post/%5Bid%5D/page-871a46f82159f9c4.js\"],\"default\"]\n16:T5038,"])</script><script>self.__next_f.push([1,"\u003ch1 id=\"内核加载\"\u003e内核加载\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#内核加载\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e在\u003ca href=\"/2018/06/16/systemstartup\"\u003e上篇博文\u003c/a\u003e里面我说明过计算机如何从远古到近代的启动流程，然后，走到操作系统一层的时候就没有深入阐述了，在这篇博文我将以Linux系统为例来叙述操作系统是如何启动的。\u003c/p\u003e\n\u003cp\u003e通常在系统\u003ccode\u003e/boot\u003c/code\u003e目录下放着内核文件，如下：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003einitramfs-linux.img\nvmlinuz-linux\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003eGRUB（或者LILO）加载内核的时候，会把\u003ccode\u003evmlinuz-linux\u003c/code\u003e映射到内存并会把它的一个初始根目录的文件镜像（\u003ccode\u003einitramfs-linux.img\u003c/code\u003e）作为文件系统加载到内存，系统会从这个迷你的初始化文件系统来启动，在这个迷你的文件系统里面又会加载真正的磁盘文件系统，带有这种\u003ccode\u003einitramfs\u003c/code\u003e的都是这种加载流程，但是，对于那种没有\u003ccode\u003einitramfs\u003c/code\u003e的（例如：Slackware发行版本），它是加载内核后，内核直接从磁盘加载文件系统，这种区分跟内核配置有关。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e内核初始化进行哪些操作？\u003c/p\u003e\n\u003cp\u003e内核初始操作属于操作系统内核部分的知识，一般来说，主体包括以下（还有很多细节可以参看Linux内核方面的书籍）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e系统处于实模式需要切换到保护模式，所以需要设置GDT,LDT，设置平坦模式的内存寻址，在GDT,LDT寄存器里面，可以设置内存保护位，大小等等信息\u003c/li\u003e\n\u003cli\u003e原始的系统没有任何可以使用库，但是不要忘记BIOS提供的中断调用，还有BIOS设定好的各种IO端口，通过它们我们就可以获取和设置计算机信息，从而达到控制计算机，我们可以把它们封装出函数调用，为了兼容历史，我们需要保留部分低位中断，这样把这些函数写成中断调用（即设置IDT中断调用表），按UNIX规范提供一套SYSCALL\u003c/li\u003e\n\u003cli\u003e实际上，我们的计算机内存已经非常大了，所以我们往往需要一种快速定位寻址的机制，在没有硬件支持的时候用软件算法可以达到相似的效果，但是在Intel平台上，提供了Paging机制，利用这种机制我们只需要设置PDE表格（即页表），那么CPU就会自动就加载寻址，这就达到硬件加速的效果\u003c/li\u003e\n\u003cli\u003e但我们设置完了进程相关设置，内存相关设置后，接下来的就是文件系统，文件系统是操作系统的基本要素（目前来说是这样的），内核会按着磁盘上数据格式把文件信息读取，并在内存中构建一个文件存留信息的数据结构（一般不一定是位视图这种表格，多数情况要复杂一些，也就是多层次的可以拓展的树状构型）\u003c/li\u003e\n\u003cli\u003e外设是最复杂的部分，外设需要各种初始化，初始化过的外设才可以正常使用，一般这部分也叫设备驱动流程（这部分也可以延后加载，进行初始化）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"初始化程序加载\"\u003e初始化程序加载\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#初始化程序加载\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e当内核加载流程全部完成后（只要没有发生出错都会加载完成），内核会启动系统的第一个进程，它就是著名的\u003ccode\u003einit\u003c/code\u003e进程（pid为1），而现在随着开源社区的发展，出现过好多版本的init程序了，最老也是最稳定的是sysvinit，除此之外还有Upstart之流，不过systemd还是更受青睐，它也是目前互动最多的init初始化开源项目。\u003c/p\u003e\n\u003cp\u003eSystemd和sysvinit有很大的区别，所以这里分别介绍两者：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eUpstart是一个基于事件触发的异步初始化方案，和Sysvinit高度兼容，但这里不作讨论，相关介绍可以查阅其他介绍Upstart的博客或技术Wiki等等\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"sysvinit的流程\"\u003eSysvinit的流程\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#sysvinit的流程\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSysvinit的启动可以把它看作两个部分：初始化，服务加载。\u003c/p\u003e\n\u003ch3 id=\"初始化部分\"\u003e初始化部分\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#初始化部分\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e在Systvinit中，它会读取系统中的 \u003ccode\u003e/etc/inittab\u003c/code\u003e信息，从而来确定系统下一步的启动步骤。为了判断下一步步骤，系统有一个概念，叫做“运行级别”（runlevel），意思就是要确定以何种场景来启动系统，一般而言，Linux有如下7种运行级别：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e0 - 关机模式\u003c/li\u003e\n\u003cli\u003e1 - 单用户模式\u003c/li\u003e\n\u003cli\u003e2 - 多用户模式\u003c/li\u003e\n\u003cli\u003e3 - 多用户网络模式\u003c/li\u003e\n\u003cli\u003e4 - 自定义模式\u003c/li\u003e\n\u003cli\u003e5 - 完全模式\u003c/li\u003e\n\u003cli\u003e6 - 重启模式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eRunlevel的定义可以参考\u003ca href=\"https://en.wikipedia.org/wiki/Runlevel\"\u003e维基百科的介绍\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e针对不同的Linux发行版本，上述的定义值不一定相同。\u003c/p\u003e\n\u003cp\u003e当init程序读取了\u003ccode\u003e/etc/inittab\u003c/code\u003e中的信息时，该配置文件里面存放了各种运行级别所要进行的操作，假设有如下配置：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003e\u003cspan class=\"hljs-meta prompt_\"\u003e# \u003c/span\u003e\u003cspan class=\"bash\"\u003eThese are the default runlevels \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e Slackware:\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e# \u003c/span\u003e\u003cspan class=\"bash\"\u003e  0 = halt\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e# \u003c/span\u003e\u003cspan class=\"bash\"\u003e  1 = single user mode\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e# \u003c/span\u003e\u003cspan class=\"bash\"\u003e  2 = unused (but configured the same as runlevel 3)\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e# \u003c/span\u003e\u003cspan class=\"bash\"\u003e  3 = multiuser mode (default Slackware runlevel)\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e# \u003c/span\u003e\u003cspan class=\"bash\"\u003e  4 = X11 with KDM/GDM/XDM (session managers)\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e# \u003c/span\u003e\u003cspan class=\"bash\"\u003e  5 = unused (but configured the same as runlevel 3)\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e# \u003c/span\u003e\u003cspan class=\"bash\"\u003e  6 = reboot\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eDefault runlevel. (Do not \u003cspan class=\"hljs-built_in\"\u003eset\u003c/span\u003e to 0 or 6)\u003c/span\u003e\nid:3:initdefault:\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eSystem initialization (runs when system boots).\u003c/span\u003e\nsi:S:sysinit:/etc/rc.d/rc.S\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eScript to run when going single user (runlevel 1).\u003c/span\u003e\nsu:1S:wait:/etc/rc.d/rc.K\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eScript to run when going multi user.\u003c/span\u003e\nrc:2345:wait:/etc/rc.d/rc.M\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eWhat to \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e at the \u003cspan class=\"hljs-string\"\u003e\"Three Finger Salute\"\u003c/span\u003e.\u003c/span\u003e\nca::ctrlaltdel:/sbin/shutdown -t5 -r now\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eRunlevel 0 halts the system.\u003c/span\u003e\nl0:0:wait:/etc/rc.d/rc.0\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eRunlevel 6 reboots the system.\u003c/span\u003e\nl6:6:wait:/etc/rc.d/rc.6\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eWhat to \u003cspan class=\"hljs-keyword\"\u003edo\u003c/span\u003e when power fails.\u003c/span\u003e\npf::powerfail:/sbin/genpowerfail start\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eIf power is back, cancel the running shutdown.\u003c/span\u003e\npg::powerokwait:/sbin/genpowerfail stop\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eThese are the standard console login getties \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e multiuser mode:\u003c/span\u003e\nc1:12345:respawn:/sbin/agetty --noclear 38400 tty1 linux\nc2:12345:respawn:/sbin/agetty 38400 tty2 linux\nc3:12345:respawn:/sbin/agetty 38400 tty3 linux\nc4:12345:respawn:/sbin/agetty 38400 tty4 linux\nc5:12345:respawn:/sbin/agetty 38400 tty5 linux\nc6:12345:respawn:/sbin/agetty 38400 tty6 linux\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eLocal serial lines:\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e#\u003c/span\u003e\u003cspan class=\"bash\"\u003es1:12345:respawn:/sbin/agetty -L ttyS0 9600 vt100\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e#\u003c/span\u003e\u003cspan class=\"bash\"\u003es2:12345:respawn:/sbin/agetty -L ttyS1 9600 vt100\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eDialup lines:\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e#\u003c/span\u003e\u003cspan class=\"bash\"\u003ed1:12345:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS0 vt100\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e#\u003c/span\u003e\u003cspan class=\"bash\"\u003ed2:12345:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS1 vt100\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e\n# \u003c/span\u003e\u003cspan class=\"bash\"\u003eRunlevel 4 also starts /etc/rc.d/rc.4 to run a display manager \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e X.\u003c/span\u003e\n\u003cspan class=\"hljs-meta prompt_\"\u003e# \u003c/span\u003e\u003cspan class=\"bash\"\u003eDisplay managers are preferred \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e this order:  gdm, kdm, xdm\u003c/span\u003e\nx1:4:respawn:/etc/rc.d/rc.4\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e每一行可以看作是一个函数。\u003c/p\u003e\n\u003cp\u003e这样以来，第一列对应单个函数的ID（2-4个字母数字组合，只要不重复即可），第二列对应函数Runlevel的值，第三列对应内部Runlevel操作入口（action），第四列是函数要执行的程序或者脚本。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e对于函数的操作入口（action）存在如下几种：initdefault, sysinit, boot, bootwait, wait, respawn\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e例如，以这个函数举例来说：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003eid:3:initdefault:\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e当运行Runlevel为3时，就会执行initdefault的入口，它不需要执行脚本或程序，表示默认的Runlevel，其他的函数配置同理。\u003c/p\u003e\n\u003cp\u003e再看上面的inittab配置，如下这行：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003esi:S:sysinit:/etc/rc.d/rc.S\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e它表示系统启动是就运行\u003ccode\u003e/etc/rc.d/rc.S\u003c/code\u003e脚本，在\u003ccode\u003e/etc/rc.d/rc.S\u003c/code\u003e脚本里面则包含：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e挂载\u003ccode\u003esysfs\u003c/code\u003e文件目录节点\u003c/li\u003e\n\u003cli\u003e挂载\u003ccode\u003etmpfs\u003c/code\u003e文件目录节点\u003c/li\u003e\n\u003cli\u003e挂载\u003ccode\u003eproc\u003c/code\u003e文件目录节点\u003c/li\u003e\n\u003cli\u003e挂载\u003ccode\u003ecgroup\u003c/code\u003e文件目录节点\u003c/li\u003e\n\u003cli\u003e启动其他的rc.XX脚本\u003c/li\u003e\n\u003cli\u003e加载需要的内核模块\u003c/li\u003e\n\u003cli\u003e检测文件系统\u003c/li\u003e\n\u003cli\u003e随机数设置\u003c/li\u003e\n\u003cli\u003e等等\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于用多个Runlevel的函数：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003erc:2345:wait:/etc/rc.d/rc.M\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e表示在\u003ccode\u003e2345\u003c/code\u003e这4个Runlevel下，都会执行\u003ccode\u003e/etc/rc.d/rc.M\u003c/code\u003e，并等待它执行完成。\u003c/p\u003e\n\u003cp\u003einit的配置非常的清晰明了，它的启动脚本可以在目录\u003ccode\u003e/etc/rc.d\u003c/code\u003e下查看。\u003c/p\u003e\n\u003cp\u003e系统就是这样加载rc.d下的初始化脚本，序列化地完成所有的init初始化流程。\u003c/p\u003e\n\u003ch3 id=\"加载服务\"\u003e加载服务\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#加载服务\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003eSysvinit中对于服务的加载是通过\u003ccode\u003e/etc/rc.d\u003c/code\u003e下的初始化脚本来执行的，一般情况下，一个服务都编写一个服务管理的Shell脚本，它可以接受：\u003ccode\u003estatus\u003c/code\u003e，\u003ccode\u003estart\u003c/code\u003e，\u003ccode\u003estop\u003c/code\u003e，\u003ccode\u003erestart\u003c/code\u003e这样的参数，并把它放在\u003ccode\u003e/etc/rc.d/init.d\u003c/code\u003e目录下面。\u003c/p\u003e\n\u003cp\u003e例如，有如下服务（\u003ccode\u003e/etc/rc.d/init.d/vbox-usb-service\u003c/code\u003e）：\u003c/p\u003e\n\u003cp\u003e我们就可以执行：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003e/etc/rc.d/init.d/vbox-usb-service status\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e来查看此服务是否已经启动，但是一般情况下，系统会为了方便创建了一个软链接（如果系统没有创建该软链接，我们可以手动创建之）：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003e/etc/init.d\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e该软链接指向\u003ccode\u003e/etc/rc.d/init.d\u003c/code\u003e，因此，我们也可以这样重启服务：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003e/etc/init.d/vbox-usb-service restart\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e但是，这不是必须这样的组织方式，也可以把服务管理的脚本直接就放在\u003ccode\u003e/etc/rc.d\u003c/code\u003e目录下，例如：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003e/etc/rc.d/rc.httpd\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e该脚本是用于Apache的httpd服务的管理脚本，执行：\u003c/p\u003e\n\u003cdiv class=\"code-block-wrapper\"\u003e\u003cdiv class=\"code-block-header\"\u003e\u003cspan class=\"code-block-lang\"\u003eshell\u003c/span\u003e\u003cbutton class=\"copy-button\" data-copy-state=\"copy\" aria-label=\"Copy code to clipboard\" type=\"button\" onclick=\"copyCode(this)\"\u003e\u003cspan class=\"copy-button-text\"\u003eCopy\u003c/span\u003e\u003c/button\u003e\u003c/div\u003e\u003cpre\u003e\u003ccode class=\"hljs language-shell\"\u003e/etc/rc.d/rc.httpd start\n\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\n\u003cp\u003e即可完成httpd服务的启动。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e对于一些外部的第三方服务都是放在\u003ccode\u003e/etc/rc.d/init.d\u003c/code\u003e下面，这样这些脚本只要添加执行权限，就会被初始化脚本自动加载，而不用去更改初始化脚本；而在\u003ccode\u003e/etc/rc.d\u003c/code\u003e下的服务管理脚本则是Linux发行版本自带的服务，它已经在初始化脚本中做过判断设置，如果我们要把一个第三方的服务管理脚本放到\u003ccode\u003e/etc/rc.d\u003c/code\u003e下，就意味着我们必须要修改初始化脚本。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"systemd的流程\"\u003eSystemd的流程\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#systemd的流程\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eSystemd中，所有的都以单元组件的形式来加载，这些单元组件很多都可以并发执行，达到快速加载的目的，单元组件的前件和后件构成一套稳定的加载系统。\u003c/p\u003e\n\u003ch3 id=\"初始化加载\"\u003e初始化加载\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#初始化加载\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在以Systemd为init服务的Linux系统中，参看\u003ccode\u003eman 7 bootup\u003c/code\u003e，以了解更多有关Systemd的启动详情。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"加载图示\"\u003e加载图示\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#加载图示\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e\u003cimg src=\"/post/linuxstartup/5825be82891a.png\" alt=\"systemd-graph\"\u003e\u003c/p\u003e\n\u003cp\u003e由上图可见，在加载\u003ccode\u003esysinit\u003c/code\u003e之前，可以加载很多的服务，而这些服务是互相独立无依赖的，因此可以并行地加载，当所有的服务都加载完后，\u003ccode\u003esysinit\u003c/code\u003e服务就算加载成功，之后进行下面的服务加载，后面的加载逻辑以此类推。注意到，类似\u003ccode\u003erescue\u003c/code\u003e这种是具有特殊用途的服务（这里的服务是用于系统崩溃后的拯救），还有一个独立依赖链，或者没有依赖的服务，被加载到目前的服务的情况，例如上图的\u003ccode\u003eremote-fs\u003c/code\u003e就是这种。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e上图绘制的systemd加载图比较粗糙，细节要复杂一些，有些一个单元的加载可能分好几个步骤来加载，有的可能细分更多的加载逻辑。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"用户登录系统\"\u003e用户登录系统\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#用户登录系统\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e当系统必要的服务都启动后，会分为几种场景：\u003c/p\u003e\n\u003ch2 id=\"runlevel-3-登录\"\u003eRunlevel 3 登录\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#runlevel-3-登录\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e在该模式下，用户自动进入ttyS1来登录系统，init会启动\u003ccode\u003e/sbin/agetty\u003c/code\u003e提示用户输入用户名和密码，getty和login判断用户合法就让用户进入系统，打开用户的Shell程序。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e上述配置，会产生6个用户可以同时登录。\u003c/p\u003e\n\u003cp\u003e此外，getty和login这种登录验证需要验证密码，通常是读取\u003ccode\u003e/etc/passwd\u003c/code\u003e下的保存设置来验证用户有效性。\u003c/p\u003e\n\u003cp\u003e（细节可以参考系统函数：\u003ccode\u003egetpass\u003c/code\u003e）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"runlevel-4-登录\"\u003eRunlevel 4 登录\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#runlevel-4-登录\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e如果是多用户模式，会启动一个用于管理系统登录的服务（一般PolKit/ConsoleKit最常见），这里以ConsoleKit举例来说，它允许用户在同一硬件设备登录的情况下，不用登出系统还可以再次登录，ConsoleKit以抽象化成会话的模型，从而实现这种登录机制。\u003c/p\u003e\n\u003cp\u003e在图形登录下，都会使用这种方式来登录系统。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e在ConsoleKit的登录验证下，也是通过读取\u003ccode\u003e/etc/passwd\u003c/code\u003e配置文件的信息来验证用户有效性的。\u003c/p\u003e\n\u003cp\u003e（对于如何验证的细节，可以参考一个系统提供的安全相关的函数：\u003ccode\u003ecrypt\u003c/code\u003e）\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"打开用户shellwdm程序\"\u003e打开用户SHELL/WDM程序\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#打开用户shellwdm程序\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e当用户输入名称和密码通过验证后，init程序需要为用户执行一个Shell运行程序，以便使用户能够对系统来进行管理，Shell的种类很多，根据用户的爱好，可以自由选择一款适合的Shell。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e常见的Shell有：Bash, Csh, Ash, Tcsh, Zsh等等\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003eShell被启动后，它就接管了用户的空间，用户可以通过它以命令方式来完成任何操作。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eShell的启动会读取系统全局配置，再基于用户$HOME目录下的配置文件，读取自定义的配置。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e通常对于图形界面的登录有一些不同，图形界面的登录启动的不是Shell，而是一个XWindows的WDM，即一个窗口管理器，它接管用户空间，为用户初始化图形化设置，并展示图形界面。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e常见的 WDM有：GDM，SDDM，KDM等等\u003c/p\u003e\n\u003c/blockquote\u003e"])</script><script>self.__next_f.push([1,"7:[\"$\",\"$L15\",null,{\"postData\":{\"id\":\"linuxstartup\",\"contentHtml\":\"$16\",\"title\":\"Linux系统启动流程\",\"date\":\"$D2018-06-24T11:50:03.000Z\",\"updated\":\"$D2018-06-24T11:50:03.000Z\",\"categories\":[\"总结\"],\"tags\":[\"linux\"]}}]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"14:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Linux系统启动流程\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"HCHEN90 博客\"}],[\"$\",\"link\",\"2\",{\"rel\":\"alternate\",\"type\":\"application/atom+xml\",\"href\":\"https://hchen90.top/atom.xml\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]],\"error\":null,\"digest\":\"$undefined\"}\ne:{\"metadata\":\"$14:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>