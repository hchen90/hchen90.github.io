1:"$Sreact.fragment"
2:I[7555,[],""]
3:I[1295,[],""]
4:I[415,["766","static/chunks/766-f505dbd3efffaa4c.js","226","static/chunks/226-13d4d3f1fc18ceb6.js","177","static/chunks/app/layout-07bb40856ea7a35b.js"],"default"]
5:I[9243,["766","static/chunks/766-f505dbd3efffaa4c.js","226","static/chunks/226-13d4d3f1fc18ceb6.js","177","static/chunks/app/layout-07bb40856ea7a35b.js"],""]
8:I[9665,[],"MetadataBoundary"]
a:I[9665,[],"OutletBoundary"]
d:I[4911,[],"AsyncMetadataOutlet"]
f:I[9665,[],"ViewportBoundary"]
11:I[6614,[],""]
:HL["/_next/static/css/283bb1ed86b49fd2.css","style"]
:HL["/_next/static/css/09ec4099fb721b31.css","style"]
:HL["/_next/static/css/09dfadb69bdaa005.css","style"]
:HL["/_next/static/css/54b9acc791aa599c.css","style"]
6:T4a2,
          function copyCode(button) {
            // Find the code element within the same wrapper
            const codeWrapper = button.closest('.code-block-wrapper');
            if (!codeWrapper) return;
            
            const codeElement = codeWrapper.querySelector('code');
            if (!codeElement) return;
            
            // Get the text content
            const text = codeElement.textContent;
            
            // Use the clipboard API to copy the text
            navigator.clipboard.writeText(text).then(() => {
              // Update the button state to show "Copied!"
              button.setAttribute('data-copy-state', 'copied');
              const buttonText = button.querySelector('.copy-button-text');
              if (buttonText) buttonText.textContent = 'Copied!';
              
              // Reset after 2 seconds
              setTimeout(() => {
                button.setAttribute('data-copy-state', 'copy');
                if (buttonText) buttonText.textContent = 'Copy';
              }, 2000);
            }).catch(err => {
              console.error('Failed to copy text: ', err);
            });
          }
          0:{"P":null,"b":"ppQBZ_hjs78de-RY41wpR","p":"","c":["","post","linuxstartup",""],"i":false,"f":[[["",{"children":["post",{"children":[["id","linuxstartup","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/283bb1ed86b49fd2.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/09ec4099fb721b31.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","2",{"rel":"stylesheet","href":"/_next/static/css/09dfadb69bdaa005.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"antialiased relative","children":[["$","div",null,{"className":"fixed top-4 right-4 z-50","children":["$","a",null,{"href":"https://github.com/hchen90","target":"_blank","rel":"noopener noreferrer","className":"flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300","title":"Visit my GitHub profile","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"24","height":"24","viewBox":"0 0 24 24","fill":"currentColor","children":["$","path",null,{"d":"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"}]}]}]}],["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}],["$","$L4",null,{}],["$","$L5",null,{"id":"code-copy","children":"$6"}]]}]}]]}],{"children":["post",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["id","linuxstartup","d"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L7",["$","$L8",null,{"children":"$L9"}],[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/54b9acc791aa599c.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$La",null,{"children":["$Lb","$Lc",["$","$Ld",null,{"promise":"$@e"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","0XRXPjr0RQy-Q9RGDihTx",{"children":[["$","$Lf",null,{"children":"$L10"}],null]}],null]}],false]],"m":"$undefined","G":["$11","$undefined"],"s":false,"S":true}
12:"$Sreact.suspense"
13:I[4911,[],"AsyncMetadata"]
9:["$","$12",null,{"fallback":null,"children":["$","$L13",null,{"promise":"$@14"}]}]
c:null
15:I[9543,["874","static/chunks/874-e909718850e7282e.js","734","static/chunks/734-02ba314a893e68e9.js","47","static/chunks/47-c7e96c4c4bac7987.js","457","static/chunks/app/post/%5Bid%5D/page-203b57796d94b5ec.js"],"default"]
16:T5038,<h1 id="内核加载">内核加载<a aria-hidden="true" tabindex="-1" href="#内核加载"><span class="anchor-link"> #</span></a></h1>
<p>在<a href="/2018/06/16/systemstartup">上篇博文</a>里面我说明过计算机如何从远古到近代的启动流程，然后，走到操作系统一层的时候就没有深入阐述了，在这篇博文我将以Linux系统为例来叙述操作系统是如何启动的。</p>
<p>通常在系统<code>/boot</code>目录下放着内核文件，如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">initramfs-linux.img
vmlinuz-linux
</code></pre></div>
<p>GRUB（或者LILO）加载内核的时候，会把<code>vmlinuz-linux</code>映射到内存并会把它的一个初始根目录的文件镜像（<code>initramfs-linux.img</code>）作为文件系统加载到内存，系统会从这个迷你的初始化文件系统来启动，在这个迷你的文件系统里面又会加载真正的磁盘文件系统，带有这种<code>initramfs</code>的都是这种加载流程，但是，对于那种没有<code>initramfs</code>的（例如：Slackware发行版本），它是加载内核后，内核直接从磁盘加载文件系统，这种区分跟内核配置有关。</p>
<blockquote>
<p>内核初始化进行哪些操作？</p>
<p>内核初始操作属于操作系统内核部分的知识，一般来说，主体包括以下（还有很多细节可以参看Linux内核方面的书籍）：</p>
<ul>
<li>系统处于实模式需要切换到保护模式，所以需要设置GDT,LDT，设置平坦模式的内存寻址，在GDT,LDT寄存器里面，可以设置内存保护位，大小等等信息</li>
<li>原始的系统没有任何可以使用库，但是不要忘记BIOS提供的中断调用，还有BIOS设定好的各种IO端口，通过它们我们就可以获取和设置计算机信息，从而达到控制计算机，我们可以把它们封装出函数调用，为了兼容历史，我们需要保留部分低位中断，这样把这些函数写成中断调用（即设置IDT中断调用表），按UNIX规范提供一套SYSCALL</li>
<li>实际上，我们的计算机内存已经非常大了，所以我们往往需要一种快速定位寻址的机制，在没有硬件支持的时候用软件算法可以达到相似的效果，但是在Intel平台上，提供了Paging机制，利用这种机制我们只需要设置PDE表格（即页表），那么CPU就会自动就加载寻址，这就达到硬件加速的效果</li>
<li>但我们设置完了进程相关设置，内存相关设置后，接下来的就是文件系统，文件系统是操作系统的基本要素（目前来说是这样的），内核会按着磁盘上数据格式把文件信息读取，并在内存中构建一个文件存留信息的数据结构（一般不一定是位视图这种表格，多数情况要复杂一些，也就是多层次的可以拓展的树状构型）</li>
<li>外设是最复杂的部分，外设需要各种初始化，初始化过的外设才可以正常使用，一般这部分也叫设备驱动流程（这部分也可以延后加载，进行初始化）</li>
</ul>
</blockquote>
<h1 id="初始化程序加载">初始化程序加载<a aria-hidden="true" tabindex="-1" href="#初始化程序加载"><span class="anchor-link"> #</span></a></h1>
<p>当内核加载流程全部完成后（只要没有发生出错都会加载完成），内核会启动系统的第一个进程，它就是著名的<code>init</code>进程（pid为1），而现在随着开源社区的发展，出现过好多版本的init程序了，最老也是最稳定的是sysvinit，除此之外还有Upstart之流，不过systemd还是更受青睐，它也是目前互动最多的init初始化开源项目。</p>
<p>Systemd和sysvinit有很大的区别，所以这里分别介绍两者：</p>
<blockquote>
<p>Upstart是一个基于事件触发的异步初始化方案，和Sysvinit高度兼容，但这里不作讨论，相关介绍可以查阅其他介绍Upstart的博客或技术Wiki等等</p>
</blockquote>
<h2 id="sysvinit的流程">Sysvinit的流程<a aria-hidden="true" tabindex="-1" href="#sysvinit的流程"><span class="anchor-link"> #</span></a></h2>
<p>Sysvinit的启动可以把它看作两个部分：初始化，服务加载。</p>
<h3 id="初始化部分">初始化部分<a aria-hidden="true" tabindex="-1" href="#初始化部分"><span class="anchor-link"> #</span></a></h3>
<p>在Systvinit中，它会读取系统中的 <code>/etc/inittab</code>信息，从而来确定系统下一步的启动步骤。为了判断下一步步骤，系统有一个概念，叫做“运行级别”（runlevel），意思就是要确定以何种场景来启动系统，一般而言，Linux有如下7种运行级别：</p>
<ul>
<li>0 - 关机模式</li>
<li>1 - 单用户模式</li>
<li>2 - 多用户模式</li>
<li>3 - 多用户网络模式</li>
<li>4 - 自定义模式</li>
<li>5 - 完全模式</li>
<li>6 - 重启模式</li>
</ul>
<blockquote>
<p>Runlevel的定义可以参考<a href="https://en.wikipedia.org/wiki/Runlevel">维基百科的介绍</a></p>
</blockquote>
<p>针对不同的Linux发行版本，上述的定义值不一定相同。</p>
<p>当init程序读取了<code>/etc/inittab</code>中的信息时，该配置文件里面存放了各种运行级别所要进行的操作，假设有如下配置：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell"><span class="hljs-meta prompt_"># </span><span class="bash">These are the default runlevels <span class="hljs-keyword">in</span> Slackware:</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  0 = halt</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  1 = single user mode</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  2 = unused (but configured the same as runlevel 3)</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  3 = multiuser mode (default Slackware runlevel)</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  4 = X11 with KDM/GDM/XDM (session managers)</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  5 = unused (but configured the same as runlevel 3)</span>
<span class="hljs-meta prompt_"># </span><span class="bash">  6 = reboot</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">Default runlevel. (Do not <span class="hljs-built_in">set</span> to 0 or 6)</span>
id:3:initdefault:
<span class="hljs-meta prompt_">
# </span><span class="bash">System initialization (runs when system boots).</span>
si:S:sysinit:/etc/rc.d/rc.S
<span class="hljs-meta prompt_">
# </span><span class="bash">Script to run when going single user (runlevel 1).</span>
su:1S:wait:/etc/rc.d/rc.K
<span class="hljs-meta prompt_">
# </span><span class="bash">Script to run when going multi user.</span>
rc:2345:wait:/etc/rc.d/rc.M
<span class="hljs-meta prompt_">
# </span><span class="bash">What to <span class="hljs-keyword">do</span> at the <span class="hljs-string">"Three Finger Salute"</span>.</span>
ca::ctrlaltdel:/sbin/shutdown -t5 -r now
<span class="hljs-meta prompt_">
# </span><span class="bash">Runlevel 0 halts the system.</span>
l0:0:wait:/etc/rc.d/rc.0
<span class="hljs-meta prompt_">
# </span><span class="bash">Runlevel 6 reboots the system.</span>
l6:6:wait:/etc/rc.d/rc.6
<span class="hljs-meta prompt_">
# </span><span class="bash">What to <span class="hljs-keyword">do</span> when power fails.</span>
pf::powerfail:/sbin/genpowerfail start
<span class="hljs-meta prompt_">
# </span><span class="bash">If power is back, cancel the running shutdown.</span>
pg::powerokwait:/sbin/genpowerfail stop
<span class="hljs-meta prompt_">
# </span><span class="bash">These are the standard console login getties <span class="hljs-keyword">in</span> multiuser mode:</span>
c1:12345:respawn:/sbin/agetty --noclear 38400 tty1 linux
c2:12345:respawn:/sbin/agetty 38400 tty2 linux
c3:12345:respawn:/sbin/agetty 38400 tty3 linux
c4:12345:respawn:/sbin/agetty 38400 tty4 linux
c5:12345:respawn:/sbin/agetty 38400 tty5 linux
c6:12345:respawn:/sbin/agetty 38400 tty6 linux
<span class="hljs-meta prompt_">
# </span><span class="bash">Local serial lines:</span>
<span class="hljs-meta prompt_">#</span><span class="bash">s1:12345:respawn:/sbin/agetty -L ttyS0 9600 vt100</span>
<span class="hljs-meta prompt_">#</span><span class="bash">s2:12345:respawn:/sbin/agetty -L ttyS1 9600 vt100</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">Dialup lines:</span>
<span class="hljs-meta prompt_">#</span><span class="bash">d1:12345:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS0 vt100</span>
<span class="hljs-meta prompt_">#</span><span class="bash">d2:12345:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS1 vt100</span>
<span class="hljs-meta prompt_">
# </span><span class="bash">Runlevel 4 also starts /etc/rc.d/rc.4 to run a display manager <span class="hljs-keyword">for</span> X.</span>
<span class="hljs-meta prompt_"># </span><span class="bash">Display managers are preferred <span class="hljs-keyword">in</span> this order:  gdm, kdm, xdm</span>
x1:4:respawn:/etc/rc.d/rc.4
</code></pre></div>
<p>每一行可以看作是一个函数。</p>
<p>这样以来，第一列对应单个函数的ID（2-4个字母数字组合，只要不重复即可），第二列对应函数Runlevel的值，第三列对应内部Runlevel操作入口（action），第四列是函数要执行的程序或者脚本。</p>
<blockquote>
<p>对于函数的操作入口（action）存在如下几种：initdefault, sysinit, boot, bootwait, wait, respawn</p>
</blockquote>
<p>例如，以这个函数举例来说：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">id:3:initdefault:
</code></pre></div>
<p>当运行Runlevel为3时，就会执行initdefault的入口，它不需要执行脚本或程序，表示默认的Runlevel，其他的函数配置同理。</p>
<p>再看上面的inittab配置，如下这行：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">si:S:sysinit:/etc/rc.d/rc.S
</code></pre></div>
<p>它表示系统启动是就运行<code>/etc/rc.d/rc.S</code>脚本，在<code>/etc/rc.d/rc.S</code>脚本里面则包含：</p>
<ul>
<li>挂载<code>sysfs</code>文件目录节点</li>
<li>挂载<code>tmpfs</code>文件目录节点</li>
<li>挂载<code>proc</code>文件目录节点</li>
<li>挂载<code>cgroup</code>文件目录节点</li>
<li>启动其他的rc.XX脚本</li>
<li>加载需要的内核模块</li>
<li>检测文件系统</li>
<li>随机数设置</li>
<li>等等</li>
</ul>
<p>对于用多个Runlevel的函数：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">rc:2345:wait:/etc/rc.d/rc.M
</code></pre></div>
<p>表示在<code>2345</code>这4个Runlevel下，都会执行<code>/etc/rc.d/rc.M</code>，并等待它执行完成。</p>
<p>init的配置非常的清晰明了，它的启动脚本可以在目录<code>/etc/rc.d</code>下查看。</p>
<p>系统就是这样加载rc.d下的初始化脚本，序列化地完成所有的init初始化流程。</p>
<h3 id="加载服务">加载服务<a aria-hidden="true" tabindex="-1" href="#加载服务"><span class="anchor-link"> #</span></a></h3>
<p>Sysvinit中对于服务的加载是通过<code>/etc/rc.d</code>下的初始化脚本来执行的，一般情况下，一个服务都编写一个服务管理的Shell脚本，它可以接受：<code>status</code>，<code>start</code>，<code>stop</code>，<code>restart</code>这样的参数，并把它放在<code>/etc/rc.d/init.d</code>目录下面。</p>
<p>例如，有如下服务（<code>/etc/rc.d/init.d/vbox-usb-service</code>）：</p>
<p>我们就可以执行：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">/etc/rc.d/init.d/vbox-usb-service status
</code></pre></div>
<p>来查看此服务是否已经启动，但是一般情况下，系统会为了方便创建了一个软链接（如果系统没有创建该软链接，我们可以手动创建之）：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">/etc/init.d
</code></pre></div>
<p>该软链接指向<code>/etc/rc.d/init.d</code>，因此，我们也可以这样重启服务：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">/etc/init.d/vbox-usb-service restart
</code></pre></div>
<p>但是，这不是必须这样的组织方式，也可以把服务管理的脚本直接就放在<code>/etc/rc.d</code>目录下，例如：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">/etc/rc.d/rc.httpd
</code></pre></div>
<p>该脚本是用于Apache的httpd服务的管理脚本，执行：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">shell</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-shell">/etc/rc.d/rc.httpd start
</code></pre></div>
<p>即可完成httpd服务的启动。</p>
<blockquote>
<p>对于一些外部的第三方服务都是放在<code>/etc/rc.d/init.d</code>下面，这样这些脚本只要添加执行权限，就会被初始化脚本自动加载，而不用去更改初始化脚本；而在<code>/etc/rc.d</code>下的服务管理脚本则是Linux发行版本自带的服务，它已经在初始化脚本中做过判断设置，如果我们要把一个第三方的服务管理脚本放到<code>/etc/rc.d</code>下，就意味着我们必须要修改初始化脚本。</p>
</blockquote>
<h2 id="systemd的流程">Systemd的流程<a aria-hidden="true" tabindex="-1" href="#systemd的流程"><span class="anchor-link"> #</span></a></h2>
<p>Systemd中，所有的都以单元组件的形式来加载，这些单元组件很多都可以并发执行，达到快速加载的目的，单元组件的前件和后件构成一套稳定的加载系统。</p>
<h3 id="初始化加载">初始化加载<a aria-hidden="true" tabindex="-1" href="#初始化加载"><span class="anchor-link"> #</span></a></h3>
<blockquote>
<p>在以Systemd为init服务的Linux系统中，参看<code>man 7 bootup</code>，以了解更多有关Systemd的启动详情。</p>
</blockquote>
<h3 id="加载图示">加载图示<a aria-hidden="true" tabindex="-1" href="#加载图示"><span class="anchor-link"> #</span></a></h3>
<p><img src="/post/linuxstartup/5825be82891a.png" alt="systemd-graph"></p>
<p>由上图可见，在加载<code>sysinit</code>之前，可以加载很多的服务，而这些服务是互相独立无依赖的，因此可以并行地加载，当所有的服务都加载完后，<code>sysinit</code>服务就算加载成功，之后进行下面的服务加载，后面的加载逻辑以此类推。注意到，类似<code>rescue</code>这种是具有特殊用途的服务（这里的服务是用于系统崩溃后的拯救），还有一个独立依赖链，或者没有依赖的服务，被加载到目前的服务的情况，例如上图的<code>remote-fs</code>就是这种。</p>
<blockquote>
<p>上图绘制的systemd加载图比较粗糙，细节要复杂一些，有些一个单元的加载可能分好几个步骤来加载，有的可能细分更多的加载逻辑。</p>
</blockquote>
<h1 id="用户登录系统">用户登录系统<a aria-hidden="true" tabindex="-1" href="#用户登录系统"><span class="anchor-link"> #</span></a></h1>
<p>当系统必要的服务都启动后，会分为几种场景：</p>
<h2 id="runlevel-3-登录">Runlevel 3 登录<a aria-hidden="true" tabindex="-1" href="#runlevel-3-登录"><span class="anchor-link"> #</span></a></h2>
<p>在该模式下，用户自动进入ttyS1来登录系统，init会启动<code>/sbin/agetty</code>提示用户输入用户名和密码，getty和login判断用户合法就让用户进入系统，打开用户的Shell程序。</p>
<blockquote>
<p>上述配置，会产生6个用户可以同时登录。</p>
<p>此外，getty和login这种登录验证需要验证密码，通常是读取<code>/etc/passwd</code>下的保存设置来验证用户有效性。</p>
<p>（细节可以参考系统函数：<code>getpass</code>）</p>
</blockquote>
<h2 id="runlevel-4-登录">Runlevel 4 登录<a aria-hidden="true" tabindex="-1" href="#runlevel-4-登录"><span class="anchor-link"> #</span></a></h2>
<p>如果是多用户模式，会启动一个用于管理系统登录的服务（一般PolKit/ConsoleKit最常见），这里以ConsoleKit举例来说，它允许用户在同一硬件设备登录的情况下，不用登出系统还可以再次登录，ConsoleKit以抽象化成会话的模型，从而实现这种登录机制。</p>
<p>在图形登录下，都会使用这种方式来登录系统。</p>
<blockquote>
<p>在ConsoleKit的登录验证下，也是通过读取<code>/etc/passwd</code>配置文件的信息来验证用户有效性的。</p>
<p>（对于如何验证的细节，可以参考一个系统提供的安全相关的函数：<code>crypt</code>）</p>
</blockquote>
<h1 id="打开用户shellwdm程序">打开用户SHELL/WDM程序<a aria-hidden="true" tabindex="-1" href="#打开用户shellwdm程序"><span class="anchor-link"> #</span></a></h1>
<p>当用户输入名称和密码通过验证后，init程序需要为用户执行一个Shell运行程序，以便使用户能够对系统来进行管理，Shell的种类很多，根据用户的爱好，可以自由选择一款适合的Shell。</p>
<blockquote>
<p>常见的Shell有：Bash, Csh, Ash, Tcsh, Zsh等等</p>
</blockquote>
<p>Shell被启动后，它就接管了用户的空间，用户可以通过它以命令方式来完成任何操作。</p>
<blockquote>
<p>Shell的启动会读取系统全局配置，再基于用户$HOME目录下的配置文件，读取自定义的配置。</p>
</blockquote>
<p>通常对于图形界面的登录有一些不同，图形界面的登录启动的不是Shell，而是一个XWindows的WDM，即一个窗口管理器，它接管用户空间，为用户初始化图形化设置，并展示图形界面。</p>
<blockquote>
<p>常见的 WDM有：GDM，SDDM，KDM等等</p>
</blockquote>7:["$","$L15",null,{"postData":{"id":"linuxstartup","contentHtml":"$16","title":"Linux系统启动流程","date":"$D2018-06-24T11:50:03.000Z","updated":"$D2018-06-24T11:50:03.000Z","categories":["总结"],"tags":["linux"]}}]
10:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
b:null
14:{"metadata":[["$","title","0",{"children":"Linux系统启动流程"}],["$","meta","1",{"name":"description","content":"HCHEN90 博客"}],["$","link","2",{"rel":"alternate","type":"application/atom+xml","href":"https://hchen90.top/atom.xml"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]],"error":null,"digest":"$undefined"}
e:{"metadata":"$14:metadata","error":null,"digest":"$undefined"}
