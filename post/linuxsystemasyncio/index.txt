1:"$Sreact.fragment"
2:I[7555,[],""]
3:I[1295,[],""]
4:I[415,["766","static/chunks/766-f505dbd3efffaa4c.js","226","static/chunks/226-13d4d3f1fc18ceb6.js","177","static/chunks/app/layout-c0c1784047774695.js"],"default"]
5:I[9243,["766","static/chunks/766-f505dbd3efffaa4c.js","226","static/chunks/226-13d4d3f1fc18ceb6.js","177","static/chunks/app/layout-c0c1784047774695.js"],""]
8:I[9665,[],"MetadataBoundary"]
a:I[9665,[],"OutletBoundary"]
d:I[4911,[],"AsyncMetadataOutlet"]
f:I[9665,[],"ViewportBoundary"]
11:I[6614,[],""]
:HL["/_next/static/css/283bb1ed86b49fd2.css","style"]
:HL["/_next/static/css/09ec4099fb721b31.css","style"]
:HL["/_next/static/css/09dfadb69bdaa005.css","style"]
:HL["/_next/static/css/54b9acc791aa599c.css","style"]
6:T4a2,
          function copyCode(button) {
            // Find the code element within the same wrapper
            const codeWrapper = button.closest('.code-block-wrapper');
            if (!codeWrapper) return;
            
            const codeElement = codeWrapper.querySelector('code');
            if (!codeElement) return;
            
            // Get the text content
            const text = codeElement.textContent;
            
            // Use the clipboard API to copy the text
            navigator.clipboard.writeText(text).then(() => {
              // Update the button state to show "Copied!"
              button.setAttribute('data-copy-state', 'copied');
              const buttonText = button.querySelector('.copy-button-text');
              if (buttonText) buttonText.textContent = 'Copied!';
              
              // Reset after 2 seconds
              setTimeout(() => {
                button.setAttribute('data-copy-state', 'copy');
                if (buttonText) buttonText.textContent = 'Copy';
              }, 2000);
            }).catch(err => {
              console.error('Failed to copy text: ', err);
            });
          }
          0:{"P":null,"b":"bvXmrLIJiTuq5pCczDHLW","p":"","c":["","post","linuxsystemasyncio",""],"i":false,"f":[[["",{"children":["post",{"children":[["id","linuxsystemasyncio","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/283bb1ed86b49fd2.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/09ec4099fb721b31.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","2",{"rel":"stylesheet","href":"/_next/static/css/09dfadb69bdaa005.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"antialiased relative","children":[["$","div",null,{"className":"fixed top-4 right-4 z-50","children":["$","a",null,{"href":"https://github.com/hchen90","target":"_blank","rel":"noopener noreferrer","className":"flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300","title":"Visit my GitHub profile","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"24","height":"24","viewBox":"0 0 24 24","fill":"currentColor","children":["$","path",null,{"d":"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"}]}]}]}],["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}],["$","$L4",null,{}],["$","$L5",null,{"id":"code-copy","children":"$6"}]]}]}]]}],{"children":["post",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["id","linuxsystemasyncio","c"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L7",["$","$L8",null,{"children":"$L9"}],[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/54b9acc791aa599c.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$La",null,{"children":["$Lb","$Lc",["$","$Ld",null,{"promise":"$@e"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","o9S1s4_XkAKB4UfzyHdMx",{"children":[["$","$Lf",null,{"children":"$L10"}],null]}],null]}],false]],"m":"$undefined","G":["$11","$undefined"],"s":false,"S":true}
12:"$Sreact.suspense"
13:I[4911,[],"AsyncMetadata"]
9:["$","$12",null,{"fallback":null,"children":["$","$L13",null,{"promise":"$@14"}]}]
c:null
15:I[9543,["874","static/chunks/874-e909718850e7282e.js","734","static/chunks/734-02ba314a893e68e9.js","47","static/chunks/47-b8631d93eb2d4d4a.js","925","static/chunks/app/post/%5B...id%5D/page-deb68fe2aa3692cd.js"],"default"]
16:T2e6b,<h1 id="linux系统中的异步io问题">Linux系统中的异步I/O问题<a aria-hidden="true" tabindex="-1" href="#linux系统中的异步io问题"><span class="anchor-link"> #</span></a></h1>
<p>系统编程中，I/O（输入/输出）模型决定了如何和数据进行交互，它对整个系统性能影响至关重要。I/O模型会直接影响如下几大方面：</p>
<ul>
<li>吞吐量</li>
<li>机器资源利用率，例如：CPU使用率</li>
<li>系统的可拓展性</li>
<li>编程复杂性</li>
</ul>
<p>I/O模型在网络编程中，是高性能服务器的基础，如果设计的不好，不管上层如何设计精巧都会在I/O层卡住，成为性能瓶颈。</p>
<p>本文将重点讨论Linux环境下的两种核心I/O模型：同步I/O模型和异步I/O模型，并结合相关的套接字函数进行阐述。</p>
<h2 id="第一部分同步io那些我们熟悉的阻塞和非阻塞">第一部分：同步I/O，那些我们熟悉的“阻塞”和“非阻塞”<a aria-hidden="true" tabindex="-1" href="#第一部分同步io那些我们熟悉的阻塞和非阻塞"><span class="anchor-link"> #</span></a></h2>
<p>同步I/O的通俗解释是：调用方发起I/O操作后，必须等待数据就绪才能继续执行。</p>
<h3 id="核心子模型一阻塞ioblocking-io">核心子模型一：阻塞I/O（Blocking I/O）<a aria-hidden="true" tabindex="-1" href="#核心子模型一阻塞ioblocking-io"><span class="anchor-link"> #</span></a></h3>
<p>在Linux系统调用<code>socket()</code>中，默认的模式就是阻塞模式。在这种模式下，调用<code>recv()</code>，<code>read()</code>，或者<code>accept()</code>函数时，如果数据没有准备好，进程就会被挂起进入阻塞状态，一直等到数据准备就绪，进程恢复运行。</p>
<blockquote>
<p>这里的进程挂起对于多线程场景是线程挂起的意思。</p>
</blockquote>
<p>这种方式有它的优点和缺点。优点是编程简单，逻辑直观，容易理解，但是缺点就是它的效率低下，特别对于高并发场景下，单个线程只能处理一个连接，这是无法充分利用CPU资源的。</p>
<h3 id="核心子模型二非阻塞ionon-blocking-io">核心子模型二：非阻塞I/O（Non-blocking I/O）<a aria-hidden="true" tabindex="-1" href="#核心子模型二非阻塞ionon-blocking-io"><span class="anchor-link"> #</span></a></h3>
<p>在Linux中，非阻塞I/O是通过<code>fcntl()</code>函数将套接字设置成非阻塞模式。设置生效后，如果数据没有就绪，调用方会立即得到函数返回的错误（通常是<code>EAGAIN</code>或<code>EWOULDBLOCK</code>），此时调用线程不会被挂起，从而可以处理其他事务。</p>
<p>这种方式下，优点是显而易见的，那就是线程不阻塞，这样可以同时处理更多的任务，大大地利用了CPU资源，但是缺点也是明显的，它需要有一种不断地轮训机制去检查I/O是否数据准备就绪，这种情况下，也会导致消耗CPU资源。</p>
<h3 id="两种模式的小结">两种模式的小结<a aria-hidden="true" tabindex="-1" href="#两种模式的小结"><span class="anchor-link"> #</span></a></h3>
<p>同步I/O的本质是<strong>发起I/O请求后，调用方必须等待数据拷贝完成</strong>。阻塞和非阻塞只是在等待数据就绪这个阶段采取的不同策略。</p>
<h2 id="第二部分异步io让操作系统来帮你处理io">第二部分：异步I/O，让操作系统来帮你处理I/O<a aria-hidden="true" tabindex="-1" href="#第二部分异步io让操作系统来帮你处理io"><span class="anchor-link"> #</span></a></h2>
<p>在第一部分我们看到了阻塞I/O的CPU利用率低，而非阻塞I/O的控制复杂，同时它的机制也会导致消耗大量CPU，为了更够更好解决这些问题，于是就有了操作系统级别的异步I/O。</p>
<p>它的流程是这样的，调用方发起I/O操作后，可以立即返回并继续执行其他任务，当I/O操作<strong>完成后</strong>，操作系统会通过某种机制（如回调函数）通知调用方。就像你点外卖后可以继续工作，等到外卖到了会收到通知。</p>
<p>这样下来，操作系统帮我们解决了非阻塞I/O的控制复杂和消耗CPU的问题。</p>
<p>这里介绍Linux中的异步I/O机制，不过它们是用于磁盘块设备读取使用的，不适用网络I/O，目的是阐述Linux异步I/O思想。异步I/O分为如下几个步骤：</p>
<h3 id="步骤一发起异步io请求">步骤一：发起异步I/O请求<a aria-hidden="true" tabindex="-1" href="#步骤一发起异步io请求"><span class="anchor-link"> #</span></a></h3>
<p>异步I/O发起的流程：</p>
<ol>
<li>应用程序调用一个特殊的异步I/O请求函数（例如<code>aio_read()</code>，或者<code>io_submit()</code>）。</li>
<li>这个调用会立即把 I/O 请求（包括要读取的文件描述符、缓冲区地址、数据大小等信息）提交给<strong>内核</strong>。</li>
<li>这是最关键的一步。提交请求的函数会<strong>立即返回</strong>，而<strong>不是</strong>等待数据读写完成。这意味着应用程序可以继续执行其他任务，而不需要停下来。</li>
</ol>
<blockquote>
<p>LibAIO和Linux原生异步I/O函数</p>
<p>LibAIO是符合POSIX标准的，具有更好的跨平台能力，但是它实际上使用线程池模拟异步的，所以性能上并不理想，典型函数有：</p>
<ul>
<li><code>aio_read()</code></li>
<li><code>aio_write()</code></li>
<li><code>aio_fsync()</code></li>
<li><code>aio_error()</code></li>
<li><code>aio_return()</code></li>
<li><code>aio_suspend()</code></li>
<li><code>aio_cancel()</code></li>
<li><code>aio_listio()</code></li>
</ul>
<p>Linux原生异步I/O函数是一种更直接、更高效的方式与内核进行交互的方式，它的工作方式是直接把I/O请求提交到内核的事件队列，从而不依赖线程模拟，达到真正的内核级别的异步，但是它的缺点主要是在于它只能在Linux系统中运行，不具备跨平台能力，典型函数有：</p>
<ul>
<li><code>io_setup()</code></li>
<li><code>io_getevents()</code></li>
<li><code>io_submit()</code></li>
<li><code>io_cancel()</code></li>
<li><code>io_destroy()</code></li>
</ul>
</blockquote>
<h3 id="步骤二内核接管并处理io">步骤二：内核接管并处理I/O<a aria-hidden="true" tabindex="-1" href="#步骤二内核接管并处理io"><span class="anchor-link"> #</span></a></h3>
<p>请求被提交，剩下的工作就由内核来完成，应用程序几乎不用再操心。</p>
<ul>
<li><strong>内核调度</strong>：内核接收到请求后，会将其放入一个队列中，并安排合适的时间进行处理。</li>
<li><strong>硬件交互</strong>：内核会与硬件（如磁盘控制器）进行交互，启动数据的传输。这个过程是完全在后台进行的，通常不需要 CPU 的介入（通过 <strong>DMA，直接内存访问</strong>技术）。</li>
<li><strong>数据拷贝</strong>：数据会直接从硬件设备被拷贝到应用程序指定的内存缓冲区中。这个拷贝过程是完全由内核负责的，不需要应用程序的参与。</li>
</ul>
<h3 id="步骤三-io操作完成并通知">步骤三： I/O操作完成并通知<a aria-hidden="true" tabindex="-1" href="#步骤三-io操作完成并通知"><span class="anchor-link"> #</span></a></h3>
<p>数据拷贝完成后，内核需要以某种方式通知应用程序，告诉它“你的 I/O 任务已经完成了”。</p>
<p><strong>通知机制</strong>：这就是异步 I/O 模型的精髓所在。通知机制可以有多种方式：</p>
<ul>
<li><strong>信号（Signal）</strong>：内核可以向应用程序发送一个信号（例如 <code>SIGIO</code>）来表示 I/O 任务完成。应用程序需要提前注册一个信号处理函数来捕获这个信号。</li>
<li><strong>回调函数（Callback Function）</strong>：这是更常见的方式。在发起请求时，应用程序会提供一个回调函数的地址。当 I/O 完成后，内核会<strong>自动调用</strong>这个函数，并将结果（比如成功或失败）作为参数传递进去。</li>
</ul>
<h3 id="步骤四应用程序处理结果">步骤四：应用程序处理结果<a aria-hidden="true" tabindex="-1" href="#步骤四应用程序处理结果"><span class="anchor-link"> #</span></a></h3>
<p>当应用程序收到完成通知后，就可以安全地处理数据了。</p>
<ul>
<li><strong>检查结果</strong>：应用程序接收到通知后，会检查操作的结果，例如数据读入的字节数或者是否发生了错误。</li>
<li><strong>继续处理</strong>：现在，缓冲区中已经有了完整的数据，应用程序可以开始对数据进行解析、处理或响应了。</li>
</ul>
<h2 id="第三部分io多路复用同步世界的异步曙光">第三部分：I/O多路复用：同步世界的异步曙光<a aria-hidden="true" tabindex="-1" href="#第三部分io多路复用同步世界的异步曙光"><span class="anchor-link"> #</span></a></h2>
<p>上面两个部分分别介绍了非阻塞I/O和异步I/O编程，可见非阻塞效率低下，而异步I/O编程又比较复杂。那么有没有一种折中的方案呢？答案是有的，那就是<strong>I/O多路复用（I/O Multiplexing）</strong>。</p>
<p>I/O多路复用的定义是一个线程可以同时监听多个<code>socket</code>文件描述符（file descriptor），当某个<code>socket</code>上有事件（数据可读、可写）发生时，内核会通知应用层。</p>
<p>这里只介绍几个核心API:</p>
<ul>
<li><strong><code>select()</code></strong>：最早期的API，优点是跨平台，缺点是性能随<code>socket</code>数量线性下降，且有文件描述符数量的限制。</li>
<li><strong><code>poll()</code></strong>：<code>select()</code>的改进版，解决了文件描述符数量的限制。</li>
<li><strong><code>epoll()</code></strong>：Linux系统独有的高性能API。详细阐述其**边缘触发（ET）<strong>和</strong>水平触发（LT）**两种模式，并解释它为何能在大规模并发连接中表现出色（仅返回已就绪的描述符，不需要轮询所有）。</li>
</ul>
<p>I/O多路复用<strong>本质上仍然是同步I/O</strong>（因为内核通知后，应用层还是需要自己发起<code>read()</code>或<code>write()</code>调用来拷贝数据），但它通过“<strong>等待多个文件描述符就绪</strong>”的机制，解决了阻塞I/O的效率问题和非阻塞I/O的轮询问题，实现了“单线程处理多连接”的高效模式。</p>
<h2 id="第四部分总结与选择">第四部分：总结与选择<a aria-hidden="true" tabindex="-1" href="#第四部分总结与选择"><span class="anchor-link"> #</span></a></h2>
<p><strong>阻塞I/O</strong>、<strong>非阻塞I/O</strong>、<strong>I/O多路复用</strong>和<strong>异步I/O</strong>的选择需要考虑不同因素，需要综合考虑编程复杂度、性能、适用场景等维度，选择适合自己业务的方式。</p>
<p>一般性建议：</p>
<ul>
<li><strong>阻塞I/O</strong>：适用于客户端应用、连接数较少且对性能要求不高的服务器。</li>
<li><strong>I/O多路复用（尤其是<code>epoll</code>）</strong>：这是<strong>高并发服务器的首选</strong>，例如Web服务器、聊天室等，它在编程复杂度和性能之间取得了最佳平衡。</li>
<li><strong>异步I/O</strong>：适用于对I/O性能有极致要求、且编程模型复杂性可以接受的场景，例如数据库、高性能存储系统等。</li>
</ul>
<p>对于I/O模型技术的发展也在不断进步中，其中典型是Linux中<code>io_uring</code>的出现，它可以支持所有类型的I/O类型，包括网络I/O。</p>7:["$","$L15",null,{"postData":{"id":"linuxsystemasyncio","contentHtml":"$16","title":"Linux系统中的异步I/O问题","date":"$D2017-07-08T00:02:11.000Z","updated":"$D2017-07-08T00:02:11.000Z","categories":["总结"],"tags":["linux"]}}]
10:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
b:null
14:{"metadata":[["$","title","0",{"children":"Linux系统中的异步I/O问题"}],["$","meta","1",{"name":"description","content":"HCHEN90 博客"}],["$","link","2",{"rel":"alternate","type":"application/atom+xml","href":"https://hchen90.top/atom.xml"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]],"error":null,"digest":"$undefined"}
e:{"metadata":"$14:metadata","error":null,"digest":"$undefined"}
