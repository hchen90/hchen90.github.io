<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/283bb1ed86b49fd2.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/09ec4099fb721b31.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/09dfadb69bdaa005.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/54b9acc791aa599c.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-ede82f7d0ae11dac.js"/><script src="/_next/static/chunks/4bd1b696-299743f5624cdabe.js" async=""></script><script src="/_next/static/chunks/684-481501000630d05e.js" async=""></script><script src="/_next/static/chunks/main-app-eb9456c5a3bb7ef4.js" async=""></script><script src="/_next/static/chunks/766-f505dbd3efffaa4c.js" async=""></script><script src="/_next/static/chunks/226-13d4d3f1fc18ceb6.js" async=""></script><script src="/_next/static/chunks/app/layout-bc83bfd6141341e7.js" async=""></script><script src="/_next/static/chunks/874-e909718850e7282e.js" async=""></script><script src="/_next/static/chunks/734-02ba314a893e68e9.js" async=""></script><script src="/_next/static/chunks/351-7dd07b3f065cc09a.js" async=""></script><script src="/_next/static/chunks/app/post/%5Bid%5D/page-871a46f82159f9c4.js" async=""></script><title>Linux系统中的异步I/O问题</title><meta name="description" content="HCHEN90 博客"/><link rel="alternate" type="application/atom+xml" href="https://hchen90.top/atom.xml"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="antialiased relative"><div class="fixed top-4 right-4 z-50"><a href="https://github.com/hchen90" target="_blank" rel="noopener noreferrer" class="flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300" title="Visit my GitHub profile"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a></div><div class="min-h-screen relative"><div class="fixed top-0 left-0 h-1 bg-blue-500 z-50 transition-all duration-300" style="width:0%"></div><button class="fixed bottom-24 right-8 p-3 rounded-full bg-blue-600 hover:bg-blue-700 text-white shadow-lg transition-opacity duration-300 z-50 opacity-0 pointer-events-none" aria-label="Back to top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 19V5M5 12l7-7 7 7"></path></svg></button><div class="main-content transition-all duration-300"><div class="max-w-4xl mx-auto px-4 py-8"><div class="mb-8"><a class="text-blue-500 hover:underline mb-4 inline-block" href="/">← 返回首页</a></div><article><header class="mb-8"><h1 class="text-4xl font-bold mb-4">Linux系统中的异步I/O问题</h1><div class="text-gray-500 mb-4">2017年7月8日</div></header><div class="markdown-content"><h1 id="linux系统中的异步io问题">Linux系统中的异步I/O问题<a aria-hidden="true" tabindex="-1" href="#linux系统中的异步io问题"><span class="anchor-link"> #</span></a></h1>
<p>系统编程中，I/O（输入/输出）模型决定了如何和数据进行交互，它对整个系统性能影响至关重要。I/O模型会直接影响如下几大方面：</p>
<ul>
<li>吞吐量</li>
<li>机器资源利用率，例如：CPU使用率</li>
<li>系统的可拓展性</li>
<li>编程复杂性</li>
</ul>
<p>I/O模型在网络编程中，是高性能服务器的基础，如果设计的不好，不管上层如何设计精巧都会在I/O层卡住，成为性能瓶颈。</p>
<p>本文将重点讨论Linux环境下的两种核心I/O模型：同步I/O模型和异步I/O模型，并结合相关的套接字函数进行阐述。</p>
<h2 id="第一部分同步io那些我们熟悉的阻塞和非阻塞">第一部分：同步I/O，那些我们熟悉的“阻塞”和“非阻塞”<a aria-hidden="true" tabindex="-1" href="#第一部分同步io那些我们熟悉的阻塞和非阻塞"><span class="anchor-link"> #</span></a></h2>
<p>同步I/O的通俗解释是：调用方发起I/O操作后，必须等待数据就绪才能继续执行。</p>
<h3 id="核心子模型一阻塞ioblocking-io">核心子模型一：阻塞I/O（Blocking I/O）<a aria-hidden="true" tabindex="-1" href="#核心子模型一阻塞ioblocking-io"><span class="anchor-link"> #</span></a></h3>
<p>在Linux系统调用<code>socket()</code>中，默认的模式就是阻塞模式。在这种模式下，调用<code>recv()</code>，<code>read()</code>，或者<code>accept()</code>函数时，如果数据没有准备好，进程就会被挂起进入阻塞状态，一直等到数据准备就绪，进程恢复运行。</p>
<blockquote>
<p>这里的进程挂起对于多线程场景是线程挂起的意思。</p>
</blockquote>
<p>这种方式有它的优点和缺点。优点是编程简单，逻辑直观，容易理解，但是缺点就是它的效率低下，特别对于高并发场景下，单个线程只能处理一个连接，这是无法充分利用CPU资源的。</p>
<h3 id="核心子模型二非阻塞ionon-blocking-io">核心子模型二：非阻塞I/O（Non-blocking I/O）<a aria-hidden="true" tabindex="-1" href="#核心子模型二非阻塞ionon-blocking-io"><span class="anchor-link"> #</span></a></h3>
<p>在Linux中，非阻塞I/O是通过<code>fcntl()</code>函数将套接字设置成非阻塞模式。设置生效后，如果数据没有就绪，调用方会立即得到函数返回的错误（通常是<code>EAGAIN</code>或<code>EWOULDBLOCK</code>），此时调用线程不会被挂起，从而可以处理其他事务。</p>
<p>这种方式下，优点是显而易见的，那就是线程不阻塞，这样可以同时处理更多的任务，大大地利用了CPU资源，但是缺点也是明显的，它需要有一种不断地轮训机制去检查I/O是否数据准备就绪，这种情况下，也会导致消耗CPU资源。</p>
<h3 id="两种模式的小结">两种模式的小结<a aria-hidden="true" tabindex="-1" href="#两种模式的小结"><span class="anchor-link"> #</span></a></h3>
<p>同步I/O的本质是<strong>发起I/O请求后，调用方必须等待数据拷贝完成</strong>。阻塞和非阻塞只是在等待数据就绪这个阶段采取的不同策略。</p>
<h2 id="第二部分异步io让操作系统来帮你处理io">第二部分：异步I/O，让操作系统来帮你处理I/O<a aria-hidden="true" tabindex="-1" href="#第二部分异步io让操作系统来帮你处理io"><span class="anchor-link"> #</span></a></h2>
<p>在第一部分我们看到了阻塞I/O的CPU利用率低，而非阻塞I/O的控制复杂，同时它的机制也会导致消耗大量CPU，为了更够更好解决这些问题，于是就有了操作系统级别的异步I/O。</p>
<p>它的流程是这样的，调用方发起I/O操作后，可以立即返回并继续执行其他任务，当I/O操作<strong>完成后</strong>，操作系统会通过某种机制（如回调函数）通知调用方。就像你点外卖后可以继续工作，等到外卖到了会收到通知。</p>
<p>这样下来，操作系统帮我们解决了非阻塞I/O的控制复杂和消耗CPU的问题。</p>
<p>这里介绍Linux中的异步I/O机制，不过它们是用于磁盘块设备读取使用的，不适用网络I/O，目的是阐述Linux异步I/O思想。异步I/O分为如下几个步骤：</p>
<h3 id="步骤一发起异步io请求">步骤一：发起异步I/O请求<a aria-hidden="true" tabindex="-1" href="#步骤一发起异步io请求"><span class="anchor-link"> #</span></a></h3>
<p>异步I/O发起的流程：</p>
<ol>
<li>应用程序调用一个特殊的异步I/O请求函数（例如<code>aio_read()</code>，或者<code>io_submit()</code>）。</li>
<li>这个调用会立即把 I/O 请求（包括要读取的文件描述符、缓冲区地址、数据大小等信息）提交给<strong>内核</strong>。</li>
<li>这是最关键的一步。提交请求的函数会<strong>立即返回</strong>，而<strong>不是</strong>等待数据读写完成。这意味着应用程序可以继续执行其他任务，而不需要停下来。</li>
</ol>
<blockquote>
<p>LibAIO和Linux原生异步I/O函数</p>
<p>LibAIO是符合POSIX标准的，具有更好的跨平台能力，但是它实际上使用线程池模拟异步的，所以性能上并不理想，典型函数有：</p>
<ul>
<li><code>aio_read()</code></li>
<li><code>aio_write()</code></li>
<li><code>aio_fsync()</code></li>
<li><code>aio_error()</code></li>
<li><code>aio_return()</code></li>
<li><code>aio_suspend()</code></li>
<li><code>aio_cancel()</code></li>
<li><code>aio_listio()</code></li>
</ul>
<p>Linux原生异步I/O函数是一种更直接、更高效的方式与内核进行交互的方式，它的工作方式是直接把I/O请求提交到内核的事件队列，从而不依赖线程模拟，达到真正的内核级别的异步，但是它的缺点主要是在于它只能在Linux系统中运行，不具备跨平台能力，典型函数有：</p>
<ul>
<li><code>io_setup()</code></li>
<li><code>io_getevents()</code></li>
<li><code>io_submit()</code></li>
<li><code>io_cancel()</code></li>
<li><code>io_destroy()</code></li>
</ul>
</blockquote>
<h3 id="步骤二内核接管并处理io">步骤二：内核接管并处理I/O<a aria-hidden="true" tabindex="-1" href="#步骤二内核接管并处理io"><span class="anchor-link"> #</span></a></h3>
<p>请求被提交，剩下的工作就由内核来完成，应用程序几乎不用再操心。</p>
<ul>
<li><strong>内核调度</strong>：内核接收到请求后，会将其放入一个队列中，并安排合适的时间进行处理。</li>
<li><strong>硬件交互</strong>：内核会与硬件（如磁盘控制器）进行交互，启动数据的传输。这个过程是完全在后台进行的，通常不需要 CPU 的介入（通过 <strong>DMA，直接内存访问</strong>技术）。</li>
<li><strong>数据拷贝</strong>：数据会直接从硬件设备被拷贝到应用程序指定的内存缓冲区中。这个拷贝过程是完全由内核负责的，不需要应用程序的参与。</li>
</ul>
<h3 id="步骤三-io操作完成并通知">步骤三： I/O操作完成并通知<a aria-hidden="true" tabindex="-1" href="#步骤三-io操作完成并通知"><span class="anchor-link"> #</span></a></h3>
<p>数据拷贝完成后，内核需要以某种方式通知应用程序，告诉它“你的 I/O 任务已经完成了”。</p>
<p><strong>通知机制</strong>：这就是异步 I/O 模型的精髓所在。通知机制可以有多种方式：</p>
<ul>
<li><strong>信号（Signal）</strong>：内核可以向应用程序发送一个信号（例如 <code>SIGIO</code>）来表示 I/O 任务完成。应用程序需要提前注册一个信号处理函数来捕获这个信号。</li>
<li><strong>回调函数（Callback Function）</strong>：这是更常见的方式。在发起请求时，应用程序会提供一个回调函数的地址。当 I/O 完成后，内核会<strong>自动调用</strong>这个函数，并将结果（比如成功或失败）作为参数传递进去。</li>
</ul>
<h3 id="步骤四应用程序处理结果">步骤四：应用程序处理结果<a aria-hidden="true" tabindex="-1" href="#步骤四应用程序处理结果"><span class="anchor-link"> #</span></a></h3>
<p>当应用程序收到完成通知后，就可以安全地处理数据了。</p>
<ul>
<li><strong>检查结果</strong>：应用程序接收到通知后，会检查操作的结果，例如数据读入的字节数或者是否发生了错误。</li>
<li><strong>继续处理</strong>：现在，缓冲区中已经有了完整的数据，应用程序可以开始对数据进行解析、处理或响应了。</li>
</ul>
<h2 id="第三部分io多路复用同步世界的异步曙光">第三部分：I/O多路复用：同步世界的异步曙光<a aria-hidden="true" tabindex="-1" href="#第三部分io多路复用同步世界的异步曙光"><span class="anchor-link"> #</span></a></h2>
<p>上面两个部分分别介绍了非阻塞I/O和异步I/O编程，可见非阻塞效率低下，而异步I/O编程又比较复杂。那么有没有一种折中的方案呢？答案是有的，那就是<strong>I/O多路复用（I/O Multiplexing）</strong>。</p>
<p>I/O多路复用的定义是一个线程可以同时监听多个<code>socket</code>文件描述符（file descriptor），当某个<code>socket</code>上有事件（数据可读、可写）发生时，内核会通知应用层。</p>
<p>这里只介绍几个核心API:</p>
<ul>
<li><strong><code>select()</code></strong>：最早期的API，优点是跨平台，缺点是性能随<code>socket</code>数量线性下降，且有文件描述符数量的限制。</li>
<li><strong><code>poll()</code></strong>：<code>select()</code>的改进版，解决了文件描述符数量的限制。</li>
<li><strong><code>epoll()</code></strong>：Linux系统独有的高性能API。详细阐述其**边缘触发（ET）<strong>和</strong>水平触发（LT）**两种模式，并解释它为何能在大规模并发连接中表现出色（仅返回已就绪的描述符，不需要轮询所有）。</li>
</ul>
<p>I/O多路复用<strong>本质上仍然是同步I/O</strong>（因为内核通知后，应用层还是需要自己发起<code>read()</code>或<code>write()</code>调用来拷贝数据），但它通过“<strong>等待多个文件描述符就绪</strong>”的机制，解决了阻塞I/O的效率问题和非阻塞I/O的轮询问题，实现了“单线程处理多连接”的高效模式。</p>
<h2 id="第四部分总结与选择">第四部分：总结与选择<a aria-hidden="true" tabindex="-1" href="#第四部分总结与选择"><span class="anchor-link"> #</span></a></h2>
<p><strong>阻塞I/O</strong>、<strong>非阻塞I/O</strong>、<strong>I/O多路复用</strong>和<strong>异步I/O</strong>的选择需要考虑不同因素，需要综合考虑编程复杂度、性能、适用场景等维度，选择适合自己业务的方式。</p>
<p>一般性建议：</p>
<ul>
<li><strong>阻塞I/O</strong>：适用于客户端应用、连接数较少且对性能要求不高的服务器。</li>
<li><strong>I/O多路复用（尤其是<code>epoll</code>）</strong>：这是<strong>高并发服务器的首选</strong>，例如Web服务器、聊天室等，它在编程复杂度和性能之间取得了最佳平衡。</li>
<li><strong>异步I/O</strong>：适用于对I/O性能有极致要求、且编程模型复杂性可以接受的场景，例如数据库、高性能存储系统等。</li>
</ul>
<p>对于I/O模型技术的发展也在不断进步中，其中典型是Linux中<code>io_uring</code>的出现，它可以支持所有类型的I/O类型，包括网络I/O。</p></div><div class="mt-12 pt-6 border-t border-gray-200 dark:border-gray-700"><a class="text-blue-500 hover:underline" href="/">← 返回所有文章列表</a></div><div class="mt-8 pt-4 border-t border-gray-200 dark:border-gray-700 text-center text-gray-500 text-sm">© 2013 – 2025 陈祥</div></article></div></div></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-ede82f7d0ae11dac.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n4:I[415,[\"766\",\"static/chunks/766-f505dbd3efffaa4c.js\",\"226\",\"static/chunks/226-13d4d3f1fc18ceb6.js\",\"177\",\"static/chunks/app/layout-bc83bfd6141341e7.js\"],\"default\"]\n5:I[9243,[\"766\",\"static/chunks/766-f505dbd3efffaa4c.js\",\"226\",\"static/chunks/226-13d4d3f1fc18ceb6.js\",\"177\",\"static/chunks/app/layout-bc83bfd6141341e7.js\"],\"\"]\n8:I[9665,[],\"MetadataBoundary\"]\na:I[9665,[],\"OutletBoundary\"]\nd:I[4911,[],\"AsyncMetadataOutlet\"]\nf:I[9665,[],\"ViewportBoundary\"]\n11:I[6614,[],\"\"]\n:HL[\"/_next/static/css/283bb1ed86b49fd2.css\",\"style\"]\n:HL[\"/_next/static/css/09ec4099fb721b31.css\",\"style\"]\n:HL[\"/_next/static/css/09dfadb69bdaa005.css\",\"style\"]\n:HL[\"/_next/static/css/54b9acc791aa599c.css\",\"style\"]\n6:T4a2,\n          function copyCode(button) {\n            // Find the code element within the same wrapper\n            const codeWrapper = button.closest('.code-block-wrapper');\n            if (!codeWrapper) return;\n            \n            const codeElement = codeWrapper.querySelector('code');\n            if (!codeElement) return;\n            \n            // Get the text content\n            const text = codeElement.textContent;\n            \n            // Use the clipboard API to copy the text\n            navigator.clipboard.writeText(text).then(() =\u003e {\n              // Update the button state to show \"Copied!\"\n              button.setAttribute('data-copy-state', 'copied');\n              const buttonText = button.querySelector('.copy-button-text');\n              if (buttonText) buttonText.textContent = 'Copied!';\n              \n              // Reset after 2 seconds\n              setTimeout(() =\u003e {\n                button.setAttribute('data-copy-state', 'copy');\n                if (buttonText) buttonText.textContent = 'Copy';\n              }, 2000);\n            }).catch(err =\u003e {\n              console.error('Failed to copy text: ', err);\n            });\n          }\n          "])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ZnA_pffjAXy0PvB3tEph0\",\"p\":\"\",\"c\":[\"\",\"post\",\"linuxsystemasyncio\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"post\",{\"children\":[[\"id\",\"linuxsystemasyncio\",\"d\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/283bb1ed86b49fd2.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09ec4099fb721b31.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09dfadb69bdaa005.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased relative\",\"children\":[[\"$\",\"div\",null,{\"className\":\"fixed top-4 right-4 z-50\",\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/hchen90\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"className\":\"flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300\",\"title\":\"Visit my GitHub profile\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":\"24\",\"height\":\"24\",\"viewBox\":\"0 0 24 24\",\"fill\":\"currentColor\",\"children\":[\"$\",\"path\",null,{\"d\":\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"}]}]}]}],[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"$L4\",null,{}],[\"$\",\"$L5\",null,{\"id\":\"code-copy\",\"children\":\"$6\"}]]}]}]]}],{\"children\":[\"post\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"id\",\"linuxsystemasyncio\",\"d\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/54b9acc791aa599c.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"OZs6AU-9wm5ncrGp6mKEz\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:\"$Sreact.suspense\"\n13:I[4911,[],\"AsyncMetadata\"]\n9:[\"$\",\"$12\",null,{\"fallback\":null,\"children\":[\"$\",\"$L13\",null,{\"promise\":\"$@14\"}]}]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script><script>self.__next_f.push([1,"15:I[9543,[\"874\",\"static/chunks/874-e909718850e7282e.js\",\"734\",\"static/chunks/734-02ba314a893e68e9.js\",\"351\",\"static/chunks/351-7dd07b3f065cc09a.js\",\"457\",\"static/chunks/app/post/%5Bid%5D/page-871a46f82159f9c4.js\"],\"default\"]\n16:T2e6b,"])</script><script>self.__next_f.push([1,"\u003ch1 id=\"linux系统中的异步io问题\"\u003eLinux系统中的异步I/O问题\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#linux系统中的异步io问题\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003e系统编程中，I/O（输入/输出）模型决定了如何和数据进行交互，它对整个系统性能影响至关重要。I/O模型会直接影响如下几大方面：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e吞吐量\u003c/li\u003e\n\u003cli\u003e机器资源利用率，例如：CPU使用率\u003c/li\u003e\n\u003cli\u003e系统的可拓展性\u003c/li\u003e\n\u003cli\u003e编程复杂性\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI/O模型在网络编程中，是高性能服务器的基础，如果设计的不好，不管上层如何设计精巧都会在I/O层卡住，成为性能瓶颈。\u003c/p\u003e\n\u003cp\u003e本文将重点讨论Linux环境下的两种核心I/O模型：同步I/O模型和异步I/O模型，并结合相关的套接字函数进行阐述。\u003c/p\u003e\n\u003ch2 id=\"第一部分同步io那些我们熟悉的阻塞和非阻塞\"\u003e第一部分：同步I/O，那些我们熟悉的“阻塞”和“非阻塞”\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#第一部分同步io那些我们熟悉的阻塞和非阻塞\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e同步I/O的通俗解释是：调用方发起I/O操作后，必须等待数据就绪才能继续执行。\u003c/p\u003e\n\u003ch3 id=\"核心子模型一阻塞ioblocking-io\"\u003e核心子模型一：阻塞I/O（Blocking I/O）\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#核心子模型一阻塞ioblocking-io\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e在Linux系统调用\u003ccode\u003esocket()\u003c/code\u003e中，默认的模式就是阻塞模式。在这种模式下，调用\u003ccode\u003erecv()\u003c/code\u003e，\u003ccode\u003eread()\u003c/code\u003e，或者\u003ccode\u003eaccept()\u003c/code\u003e函数时，如果数据没有准备好，进程就会被挂起进入阻塞状态，一直等到数据准备就绪，进程恢复运行。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这里的进程挂起对于多线程场景是线程挂起的意思。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e这种方式有它的优点和缺点。优点是编程简单，逻辑直观，容易理解，但是缺点就是它的效率低下，特别对于高并发场景下，单个线程只能处理一个连接，这是无法充分利用CPU资源的。\u003c/p\u003e\n\u003ch3 id=\"核心子模型二非阻塞ionon-blocking-io\"\u003e核心子模型二：非阻塞I/O（Non-blocking I/O）\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#核心子模型二非阻塞ionon-blocking-io\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e在Linux中，非阻塞I/O是通过\u003ccode\u003efcntl()\u003c/code\u003e函数将套接字设置成非阻塞模式。设置生效后，如果数据没有就绪，调用方会立即得到函数返回的错误（通常是\u003ccode\u003eEAGAIN\u003c/code\u003e或\u003ccode\u003eEWOULDBLOCK\u003c/code\u003e），此时调用线程不会被挂起，从而可以处理其他事务。\u003c/p\u003e\n\u003cp\u003e这种方式下，优点是显而易见的，那就是线程不阻塞，这样可以同时处理更多的任务，大大地利用了CPU资源，但是缺点也是明显的，它需要有一种不断地轮训机制去检查I/O是否数据准备就绪，这种情况下，也会导致消耗CPU资源。\u003c/p\u003e\n\u003ch3 id=\"两种模式的小结\"\u003e两种模式的小结\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#两种模式的小结\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e同步I/O的本质是\u003cstrong\u003e发起I/O请求后，调用方必须等待数据拷贝完成\u003c/strong\u003e。阻塞和非阻塞只是在等待数据就绪这个阶段采取的不同策略。\u003c/p\u003e\n\u003ch2 id=\"第二部分异步io让操作系统来帮你处理io\"\u003e第二部分：异步I/O，让操作系统来帮你处理I/O\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#第二部分异步io让操作系统来帮你处理io\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e在第一部分我们看到了阻塞I/O的CPU利用率低，而非阻塞I/O的控制复杂，同时它的机制也会导致消耗大量CPU，为了更够更好解决这些问题，于是就有了操作系统级别的异步I/O。\u003c/p\u003e\n\u003cp\u003e它的流程是这样的，调用方发起I/O操作后，可以立即返回并继续执行其他任务，当I/O操作\u003cstrong\u003e完成后\u003c/strong\u003e，操作系统会通过某种机制（如回调函数）通知调用方。就像你点外卖后可以继续工作，等到外卖到了会收到通知。\u003c/p\u003e\n\u003cp\u003e这样下来，操作系统帮我们解决了非阻塞I/O的控制复杂和消耗CPU的问题。\u003c/p\u003e\n\u003cp\u003e这里介绍Linux中的异步I/O机制，不过它们是用于磁盘块设备读取使用的，不适用网络I/O，目的是阐述Linux异步I/O思想。异步I/O分为如下几个步骤：\u003c/p\u003e\n\u003ch3 id=\"步骤一发起异步io请求\"\u003e步骤一：发起异步I/O请求\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#步骤一发起异步io请求\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e异步I/O发起的流程：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e应用程序调用一个特殊的异步I/O请求函数（例如\u003ccode\u003eaio_read()\u003c/code\u003e，或者\u003ccode\u003eio_submit()\u003c/code\u003e）。\u003c/li\u003e\n\u003cli\u003e这个调用会立即把 I/O 请求（包括要读取的文件描述符、缓冲区地址、数据大小等信息）提交给\u003cstrong\u003e内核\u003c/strong\u003e。\u003c/li\u003e\n\u003cli\u003e这是最关键的一步。提交请求的函数会\u003cstrong\u003e立即返回\u003c/strong\u003e，而\u003cstrong\u003e不是\u003c/strong\u003e等待数据读写完成。这意味着应用程序可以继续执行其他任务，而不需要停下来。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cblockquote\u003e\n\u003cp\u003eLibAIO和Linux原生异步I/O函数\u003c/p\u003e\n\u003cp\u003eLibAIO是符合POSIX标准的，具有更好的跨平台能力，但是它实际上使用线程池模拟异步的，所以性能上并不理想，典型函数有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eaio_read()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaio_write()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaio_fsync()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaio_error()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaio_return()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaio_suspend()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaio_cancel()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eaio_listio()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eLinux原生异步I/O函数是一种更直接、更高效的方式与内核进行交互的方式，它的工作方式是直接把I/O请求提交到内核的事件队列，从而不依赖线程模拟，达到真正的内核级别的异步，但是它的缺点主要是在于它只能在Linux系统中运行，不具备跨平台能力，典型函数有：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eio_setup()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eio_getevents()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eio_submit()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eio_cancel()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eio_destroy()\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/blockquote\u003e\n\u003ch3 id=\"步骤二内核接管并处理io\"\u003e步骤二：内核接管并处理I/O\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#步骤二内核接管并处理io\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e请求被提交，剩下的工作就由内核来完成，应用程序几乎不用再操心。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e内核调度\u003c/strong\u003e：内核接收到请求后，会将其放入一个队列中，并安排合适的时间进行处理。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e硬件交互\u003c/strong\u003e：内核会与硬件（如磁盘控制器）进行交互，启动数据的传输。这个过程是完全在后台进行的，通常不需要 CPU 的介入（通过 \u003cstrong\u003eDMA，直接内存访问\u003c/strong\u003e技术）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e数据拷贝\u003c/strong\u003e：数据会直接从硬件设备被拷贝到应用程序指定的内存缓冲区中。这个拷贝过程是完全由内核负责的，不需要应用程序的参与。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"步骤三-io操作完成并通知\"\u003e步骤三： I/O操作完成并通知\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#步骤三-io操作完成并通知\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e数据拷贝完成后，内核需要以某种方式通知应用程序，告诉它“你的 I/O 任务已经完成了”。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e通知机制\u003c/strong\u003e：这就是异步 I/O 模型的精髓所在。通知机制可以有多种方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e信号（Signal）\u003c/strong\u003e：内核可以向应用程序发送一个信号（例如 \u003ccode\u003eSIGIO\u003c/code\u003e）来表示 I/O 任务完成。应用程序需要提前注册一个信号处理函数来捕获这个信号。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e回调函数（Callback Function）\u003c/strong\u003e：这是更常见的方式。在发起请求时，应用程序会提供一个回调函数的地址。当 I/O 完成后，内核会\u003cstrong\u003e自动调用\u003c/strong\u003e这个函数，并将结果（比如成功或失败）作为参数传递进去。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"步骤四应用程序处理结果\"\u003e步骤四：应用程序处理结果\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#步骤四应用程序处理结果\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e当应用程序收到完成通知后，就可以安全地处理数据了。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e检查结果\u003c/strong\u003e：应用程序接收到通知后，会检查操作的结果，例如数据读入的字节数或者是否发生了错误。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e继续处理\u003c/strong\u003e：现在，缓冲区中已经有了完整的数据，应用程序可以开始对数据进行解析、处理或响应了。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"第三部分io多路复用同步世界的异步曙光\"\u003e第三部分：I/O多路复用：同步世界的异步曙光\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#第三部分io多路复用同步世界的异步曙光\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e上面两个部分分别介绍了非阻塞I/O和异步I/O编程，可见非阻塞效率低下，而异步I/O编程又比较复杂。那么有没有一种折中的方案呢？答案是有的，那就是\u003cstrong\u003eI/O多路复用（I/O Multiplexing）\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003eI/O多路复用的定义是一个线程可以同时监听多个\u003ccode\u003esocket\u003c/code\u003e文件描述符（file descriptor），当某个\u003ccode\u003esocket\u003c/code\u003e上有事件（数据可读、可写）发生时，内核会通知应用层。\u003c/p\u003e\n\u003cp\u003e这里只介绍几个核心API:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eselect()\u003c/code\u003e\u003c/strong\u003e：最早期的API，优点是跨平台，缺点是性能随\u003ccode\u003esocket\u003c/code\u003e数量线性下降，且有文件描述符数量的限制。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003epoll()\u003c/code\u003e\u003c/strong\u003e：\u003ccode\u003eselect()\u003c/code\u003e的改进版，解决了文件描述符数量的限制。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e\u003ccode\u003eepoll()\u003c/code\u003e\u003c/strong\u003e：Linux系统独有的高性能API。详细阐述其**边缘触发（ET）\u003cstrong\u003e和\u003c/strong\u003e水平触发（LT）**两种模式，并解释它为何能在大规模并发连接中表现出色（仅返回已就绪的描述符，不需要轮询所有）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eI/O多路复用\u003cstrong\u003e本质上仍然是同步I/O\u003c/strong\u003e（因为内核通知后，应用层还是需要自己发起\u003ccode\u003eread()\u003c/code\u003e或\u003ccode\u003ewrite()\u003c/code\u003e调用来拷贝数据），但它通过“\u003cstrong\u003e等待多个文件描述符就绪\u003c/strong\u003e”的机制，解决了阻塞I/O的效率问题和非阻塞I/O的轮询问题，实现了“单线程处理多连接”的高效模式。\u003c/p\u003e\n\u003ch2 id=\"第四部分总结与选择\"\u003e第四部分：总结与选择\u003ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#第四部分总结与选择\"\u003e\u003cspan class=\"anchor-link\"\u003e #\u003c/span\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e阻塞I/O\u003c/strong\u003e、\u003cstrong\u003e非阻塞I/O\u003c/strong\u003e、\u003cstrong\u003eI/O多路复用\u003c/strong\u003e和\u003cstrong\u003e异步I/O\u003c/strong\u003e的选择需要考虑不同因素，需要综合考虑编程复杂度、性能、适用场景等维度，选择适合自己业务的方式。\u003c/p\u003e\n\u003cp\u003e一般性建议：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e阻塞I/O\u003c/strong\u003e：适用于客户端应用、连接数较少且对性能要求不高的服务器。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eI/O多路复用（尤其是\u003ccode\u003eepoll\u003c/code\u003e）\u003c/strong\u003e：这是\u003cstrong\u003e高并发服务器的首选\u003c/strong\u003e，例如Web服务器、聊天室等，它在编程复杂度和性能之间取得了最佳平衡。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e异步I/O\u003c/strong\u003e：适用于对I/O性能有极致要求、且编程模型复杂性可以接受的场景，例如数据库、高性能存储系统等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e对于I/O模型技术的发展也在不断进步中，其中典型是Linux中\u003ccode\u003eio_uring\u003c/code\u003e的出现，它可以支持所有类型的I/O类型，包括网络I/O。\u003c/p\u003e"])</script><script>self.__next_f.push([1,"7:[\"$\",\"$L15\",null,{\"postData\":{\"id\":\"linuxsystemasyncio\",\"contentHtml\":\"$16\",\"title\":\"Linux系统中的异步I/O问题\",\"date\":\"$D2017-07-08T00:02:11.000Z\",\"updated\":\"$D2017-07-08T00:02:11.000Z\",\"categories\":[\"总结\"],\"tags\":[\"linux\"]}}]\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"14:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"Linux系统中的异步I/O问题\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"HCHEN90 博客\"}],[\"$\",\"link\",\"2\",{\"rel\":\"alternate\",\"type\":\"application/atom+xml\",\"href\":\"https://hchen90.top/atom.xml\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]],\"error\":null,\"digest\":\"$undefined\"}\ne:{\"metadata\":\"$14:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>