1:"$Sreact.fragment"
2:I[7555,[],""]
3:I[1295,[],""]
4:I[415,["766","static/chunks/766-f505dbd3efffaa4c.js","226","static/chunks/226-13d4d3f1fc18ceb6.js","177","static/chunks/app/layout-c0c1784047774695.js"],"default"]
5:I[9243,["766","static/chunks/766-f505dbd3efffaa4c.js","226","static/chunks/226-13d4d3f1fc18ceb6.js","177","static/chunks/app/layout-c0c1784047774695.js"],""]
8:I[9665,[],"MetadataBoundary"]
a:I[9665,[],"OutletBoundary"]
d:I[4911,[],"AsyncMetadataOutlet"]
f:I[9665,[],"ViewportBoundary"]
11:I[6614,[],""]
:HL["/_next/static/css/283bb1ed86b49fd2.css","style"]
:HL["/_next/static/css/09ec4099fb721b31.css","style"]
:HL["/_next/static/css/09dfadb69bdaa005.css","style"]
:HL["/_next/static/css/54b9acc791aa599c.css","style"]
6:T4a2,
          function copyCode(button) {
            // Find the code element within the same wrapper
            const codeWrapper = button.closest('.code-block-wrapper');
            if (!codeWrapper) return;
            
            const codeElement = codeWrapper.querySelector('code');
            if (!codeElement) return;
            
            // Get the text content
            const text = codeElement.textContent;
            
            // Use the clipboard API to copy the text
            navigator.clipboard.writeText(text).then(() => {
              // Update the button state to show "Copied!"
              button.setAttribute('data-copy-state', 'copied');
              const buttonText = button.querySelector('.copy-button-text');
              if (buttonText) buttonText.textContent = 'Copied!';
              
              // Reset after 2 seconds
              setTimeout(() => {
                button.setAttribute('data-copy-state', 'copy');
                if (buttonText) buttonText.textContent = 'Copy';
              }, 2000);
            }).catch(err => {
              console.error('Failed to copy text: ', err);
            });
          }
          0:{"P":null,"b":"bvXmrLIJiTuq5pCczDHLW","p":"","c":["","post","softwaredesignpattern4",""],"i":false,"f":[[["",{"children":["post",{"children":[["id","softwaredesignpattern4","c"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/283bb1ed86b49fd2.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/09ec4099fb721b31.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","2",{"rel":"stylesheet","href":"/_next/static/css/09dfadb69bdaa005.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"antialiased relative","children":[["$","div",null,{"className":"fixed top-4 right-4 z-50","children":["$","a",null,{"href":"https://github.com/hchen90","target":"_blank","rel":"noopener noreferrer","className":"flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300","title":"Visit my GitHub profile","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":"24","height":"24","viewBox":"0 0 24 24","fill":"currentColor","children":["$","path",null,{"d":"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"}]}]}]}],["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}],["$","$L4",null,{}],["$","$L5",null,{"id":"code-copy","children":"$6"}]]}]}]]}],{"children":["post",["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["id","softwaredesignpattern4","c"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L7",["$","$L8",null,{"children":"$L9"}],[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/54b9acc791aa599c.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","$La",null,{"children":["$Lb","$Lc",["$","$Ld",null,{"promise":"$@e"}]]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","56pIq2rIox978hhuZ3A71",{"children":[["$","$Lf",null,{"children":"$L10"}],null]}],null]}],false]],"m":"$undefined","G":["$11","$undefined"],"s":false,"S":true}
12:"$Sreact.suspense"
13:I[4911,[],"AsyncMetadata"]
9:["$","$12",null,{"fallback":null,"children":["$","$L13",null,{"promise":"$@14"}]}]
c:null
15:I[9543,["874","static/chunks/874-e909718850e7282e.js","734","static/chunks/734-02ba314a893e68e9.js","47","static/chunks/47-b8631d93eb2d4d4a.js","925","static/chunks/app/post/%5B...id%5D/page-deb68fe2aa3692cd.js"],"default"]
16:Tb477,<h1 id="软件设计模式---行为模式">软件设计模式 - 行为模式<a aria-hidden="true" tabindex="-1" href="#软件设计模式---行为模式"><span class="anchor-link"> #</span></a></h1>
<p>行为模式负责对象之间的高效沟通和职责委派。</p>
<p>行为模式包括：责任链，命令，迭代器，中介者，备忘录，观察者，状态，策略，模版方法，访问者。</p>
<h2 id="责任链模式chain-of-responsibilitycor">责任链模式（Chain of Responsibility/CoR）<a aria-hidden="true" tabindex="-1" href="#责任链模式chain-of-responsibilitycor"><span class="anchor-link"> #</span></a></h2>
<p>责任链模式允许你将请求沿着处理者链进行传递。每个节点上的处理者收到请求后，可对请求进行处理，或者将请求继续传递给链上的下个处理者。</p>
<p>例如：</p>
<p><img src="/post/softwaredesignpattern4/3bd87b0f387e.png" alt="CoR"></p>
<p>这里只是两级责任链。</p>
<p>示例代码：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handler</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicHandler</span> : <span class="hljs-keyword">public</span> Handler {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 进行第一级必要处理</span>
        <span class="hljs-keyword">if</span> (okay &#x26;&#x26; next != <span class="hljs-literal">nullptr</span>) {
            <span class="hljs-built_in">next</span>(); <span class="hljs-comment">// 转上级责任链节点处理</span>
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Handler&#x26; hdr)</span> </span>{
        next = hdr
    }
<span class="hljs-keyword">private</span>:
    Handler next;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondHandler</span> : <span class="hljs-keyword">public</span> Handler {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 进行必要处理</span>
    }
    <span class="hljs-comment">// 最后一级不必设置next</span>
    <span class="hljs-comment">// void setNext(Handler&#x26; hdr) {</span>
    <span class="hljs-comment">//     next = hdr</span>
    <span class="hljs-comment">// }</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">// Handler next;</span>
};
</code></pre></div>
<h2 id="命令模式command">命令模式（Command）<a aria-hidden="true" tabindex="-1" href="#命令模式command"><span class="anchor-link"> #</span></a></h2>
<p>命令模式将请求转换成包含与请求相关的所有信息的独立对象，并且对象存放在队列中，队列元素可以进行撤销操作。</p>
<p>这里以编辑器软件的设计为例，如下：</p>
<p><img src="/post/softwaredesignpattern4/864e9e18f296.png" alt="Command"></p>
<p>示例代码：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Command</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-comment">// 打开文件</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">OpenCommand</span> : <span class="hljs-keyword">public</span> Command {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 进行打开文件操作</span>
    }
};

<span class="hljs-comment">// 保存文件</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveCommand</span> : <span class="hljs-keyword">public</span> Command {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 进行保存文件操作</span>
    }
};

<span class="hljs-comment">// 打印文件</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintCommand</span> : <span class="hljs-keyword">public</span> Command {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 进行文件打印的操作</span>
    }
};
</code></pre></div>
<p>此外还需要一个命令队列机制：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-comment">// 命令队列</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CommandQueue</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(Command&#x26;)</span> </span>{
        <span class="hljs-comment">// 命令入列</span>
    }
    <span class="hljs-function">Command <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 命令出列</span>
    }
};
</code></pre></div>
<p>命令队列用于存储命令，并且队列的进出使用一定的调度算法：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-function">CommandQueue <span class="hljs-title">cq</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;

<span class="hljs-comment">// 可以根据具体的调度方式，这里使用定时器来调度</span>
<span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
    std::this_thread::<span class="hljs-built_in">sleep_for</span>(std::chrono::<span class="hljs-built_in">seconds</span>(<span class="hljs-number">1</span>));
    <span class="hljs-keyword">auto</span> cmd = cq.<span class="hljs-built_in">pop</span>();
    cmd.<span class="hljs-built_in">execute</span>();
}
</code></pre></div>
<p>如果要进行撤销操作，只需推出队列元素不用执行即可：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp">cq.<span class="hljs-built_in">pop</span>();
</code></pre></div>
<p>如果创建菜单打开操作，只需要如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">auto</span> openCmd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OpenCommand</span>();
<span class="hljs-keyword">auto</span> menuOpen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Menu</span>(<span class="hljs-string">"Open"</span>);
menuOpen.action = [openCmd](){
    cq.<span class="hljs-built_in">push</span>(openCmd); <span class="hljs-comment">// 发送打开命令进入队列</span>
};
</code></pre></div>
<h2 id="迭代器模式iterator">迭代器模式（Iterator）<a aria-hidden="true" tabindex="-1" href="#迭代器模式iterator"><span class="anchor-link"> #</span></a></h2>
<p>迭代器模式的目的是为了不暴露集合的底层的前提下，让外部仍然可以遍历集合中的所有元素。</p>
<p>结构如下：</p>
<p><img src="/post/softwaredesignpattern4/bab81b954a9e.png" alt="Iterator"></p>
<p>首先定义一个集合：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-comment">// 迭代器</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Iterator</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Iterator <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Item</span> : <span class="hljs-keyword">public</span> Iterator {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Item <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 下一个元素</span>
    }
};

<span class="hljs-comment">// 迭代器集合</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">IteratorCollection</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Iterator <span class="hljs-title">create</span><span class="hljs-params">(Iterator)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Collection</span> : <span class="hljs-keyword">public</span> IteratorCollection {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Iterator <span class="hljs-title">create</span><span class="hljs-params">(Iterator)</span> </span>{
        <span class="hljs-comment">// 建立一个迭代器</span>
    }
    <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 返回第一个迭代器</span>
    }
    <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 返回最后一个迭代器</span>
    }
};
</code></pre></div>
<p>迭代器集合构造可以如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp">Collection collection;
Item empty;
first = collection.<span class="hljs-built_in">create</span>(empty);
second = collection.<span class="hljs-built_in">create</span>(first);
third = collection.<span class="hljs-built_in">create</span>(second);
</code></pre></div>
<p>对于迭代器集合的构造，方式多样，可以如上面通过函数逐个构造，也可以通过构造函数进行构造。</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-function">Collection <span class="hljs-title">collection</span><span class="hljs-params">([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>])</span></span>;
</code></pre></div>
<p>使用迭代器集合来访问迭代器元素：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = collection.<span class="hljs-built_in">begin</span>(); it != collection.<span class="hljs-built_in">end</span>(); it = it.<span class="hljs-built_in">next</span>()) {
    <span class="hljs-comment">// 访问迭代器元素it</span>
}
</code></pre></div>
<h2 id="中介者模式mediator">中介者模式（Mediator）<a aria-hidden="true" tabindex="-1" href="#中介者模式mediator"><span class="anchor-link"> #</span></a></h2>
<p>中介者模式是为了减少对象之间混乱无序的依赖关系，该模式会限制对象之间的直接交互，而是使用一个中介对象作为交互者。</p>
<p>假设在一个表单UI交互设计的场景下，用户可以填写姓名，出生日期，性别等信息，每一栏信息的更新也会触发其他UI栏目的元素变化，例如：填写完出生日期会触发表单中年龄更新，如果所有的UI控件元素之间直接交互来更新，那么这将导致最终的混乱。如果使用中介者就可以避免这种混乱的发生。</p>
<p><img src="/post/softwaredesignpattern4/1decbdf92c84.png" alt="Mediator"></p>
<p>如上图，更改出生日期后，更新年龄，使用中介者就避免了直接调用导致的混乱。</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mediator</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(<span class="hljs-type">int</span> type, std::string param)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">registerObject</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInformation</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(<span class="hljs-type">int</span> type, std::string param)</span> </span>{
        <span class="hljs-comment">// 根据type不同，通知不同的对象进行UI更新</span>
    }
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">registerObject</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 注册UI对象</span>
    }
<span class="hljs-keyword">private</span>:
    std::vector&#x3C;UIObject> objects;
};
</code></pre></div>
<p>使用时，内存环境维持一个唯一的用户信息，这样定义：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp">UserInformation info;
info.<span class="hljs-built_in">registerObject</span>(userNameLabel);
info.<span class="hljs-built_in">registerObject</span>(birthLabel);
info.<span class="hljs-built_in">registerObject</span>(ageLabel);
<span class="hljs-comment">// ...</span>
</code></pre></div>
<p>用户触发了UI控件的值修改：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp">info.<span class="hljs-built_in">notify</span>(<span class="hljs-number">123</span>, <span class="hljs-string">"1975-02-12"</span>); <span class="hljs-comment">// 假设123为更新出生日期的事件，参数是更新后的日期</span>
</code></pre></div>
<h2 id="备忘录模式memento">备忘录模式（Memento）<a aria-hidden="true" tabindex="-1" href="#备忘录模式memento"><span class="anchor-link"> #</span></a></h2>
<p>备忘录模式允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态.</p>
<p>在编辑器软件中一般都支持操作的撤销与恢复，实现如下：</p>
<p><img src="/post/softwaredesignpattern4/adea908520cc.png" alt="Memento"></p>
<p>如图中，文档打开时由一个初始原发器构成，下一步的快照基于该原发器，以此类推，然后，快照由一个快照列表构成来存储管理，代码如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memento</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Originator</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Memento* <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Snapshot</span> : <span class="hljs-keyword">public</span> Memento {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Snapshot</span>(Memento* m, <span class="hljs-type">int</span> s) {
        originator = m;
        state = s;
        <span class="hljs-comment">// 存储操作状态</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">restore</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 恢复操作状态</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Initial</span> : <span class="hljs-keyword">public</span> Originator {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> state)</span> </span>{
        <span class="hljs-keyword">this</span>->state = state;
    }
    <span class="hljs-function">Memento* <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Snapshot</span>(<span class="hljs-keyword">this</span>, state);
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> state;
};
</code></pre></div>
<p>定义管理器，用于管理快照，创建和恢复快照：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp">std::vector&#x3C;Snapshot*> snapshots;
<span class="hljs-comment">// 初始原发器</span>
Initial init;
init.<span class="hljs-built_in">setState</span>(<span class="hljs-number">0</span>);
<span class="hljs-comment">// 保存快照</span>
Snapshot* s1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Snapshot</span>(init, <span class="hljs-number">1</span>);
snapshots.<span class="hljs-built_in">push_back</span>(s1);
<span class="hljs-comment">// 恢复快照</span>
<span class="hljs-keyword">auto</span> s = snapshots.<span class="hljs-built_in">pop_back</span>();
s-><span class="hljs-built_in">restore</span>();
</code></pre></div>
<h2 id="观察者模式observer">观察者模式（Observer）<a aria-hidden="true" tabindex="-1" href="#观察者模式observer"><span class="anchor-link"> #</span></a></h2>
<p>观察者模式是一种发布订阅机制，允许当对象状态发生改变时，通知多个其他的“观察”对象。</p>
<p>这里以代码编辑器为例，代码编辑器不仅是文本编辑器，同时支持基于代码文本的语法加亮，自动缩进，括号自动匹配等功能。</p>
<p><img src="/post/softwaredesignpattern4/9d980a98bd2d.png" alt="Observer"></p>
<p>代码实现如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventListener</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Highlight</span> : <span class="hljs-keyword">public</span> EventListener {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 更新语法高亮</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoIndent</span> : <span class="hljs-keyword">public</span> EventListener {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 更新自动缩进</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoBracket</span> : <span class="hljs-keyword">public</span> EventListener {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 更新括号匹配</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">EventManager</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">subscribe</span><span class="hljs-params">(<span class="hljs-type">int</span> type, EventListener* listener)</span> </span>{
        <span class="hljs-keyword">auto</span> it = listeners[type];
        <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">nullptr</span>) {
            it = <span class="hljs-built_in">initListenerList</span>(); <span class="hljs-comment">// 初始化监听者列表</span>
            listeners.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(type, it));
        }
        it-><span class="hljs-built_in">push_back</span>(listener); <span class="hljs-comment">// 添加监听者</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unsubscribe</span><span class="hljs-params">(<span class="hljs-type">int</span> type, EventListener* listener)</span> </span>{
        <span class="hljs-keyword">auto</span> it = listeners[type];
        <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find_if</span>(it, listener)) { <span class="hljs-comment">// 查找监听者</span>
            it = <span class="hljs-built_in">remove_if</span>(it, listener); <span class="hljs-comment">// 删除</span>
            listeners[type] = it;
        }
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(<span class="hljs-type">int</span> type, DataFrame* data)</span> </span>{
        <span class="hljs-comment">// 遍历所有监听该事件的监听者并发送通知</span>
        <span class="hljs-keyword">auto</span> it = listeners[type];
        <span class="hljs-keyword">if</span> (it == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">for</span> (l := it-><span class="hljs-built_in">begin</span>(); l != it-><span class="hljs-built_in">end</span>(); l = l-><span class="hljs-built_in">next</span>()) {
            l-><span class="hljs-built_in">update</span>(); <span class="hljs-comment">// 通知事件</span>
        }
    }
<span class="hljs-keyword">private</span>:
    std::map&#x3C;<span class="hljs-type">int</span>, ListenerList*> listeners;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Editor</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">Editor</span>() {}
<span class="hljs-keyword">private</span>:
    EventManager eventMgr;
};
</code></pre></div>
<h2 id="状态模式state">状态模式（State）<a aria-hidden="true" tabindex="-1" href="#状态模式state"><span class="anchor-link"> #</span></a></h2>
<p>状态模型是指一个对象的状态发生变化后，它的行为也会发生改变。其主要思想是有限状态机的原理。</p>
<p>空调恒温系统是一个最简单的状态机，如下图：</p>
<p><img src="/post/softwaredesignpattern4/7a92462341cc.png" alt="State Machine"></p>
<p>对于状态模型的类定义如下：</p>
<p><img src="/post/softwaredesignpattern4/daa6b086d079.png" alt="State"></p>
<p>代码如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AirConditionerState</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">AirConditionerState</span>() {
        <span class="hljs-comment">// 初始化状态转换表</span>
        transits.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">compound</span>(STATE_START, SYM_RDY), STATE_ON);
        transits.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">compound</span>(STATE_ON, SYM_BELOW), STATE_WAIT);
        <span class="hljs-comment">// ...</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">transit</span><span class="hljs-params">(<span class="hljs-type">int</span> cur)</span> </span>{ <span class="hljs-comment">// 转换函数</span>
        <span class="hljs-keyword">auto</span> sym = cur > <span class="hljs-number">26</span> ? SYM_ABOVE : SYM_BELOW;
        <span class="hljs-keyword">auto</span> key = <span class="hljs-built_in">compound</span>(state, sym);
        <span class="hljs-keyword">auto</span> val = transits.<span class="hljs-built_in">find</span>(key);
        state = val;
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span> state;
    std::map&#x3C;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>> transits;

    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">compound</span><span class="hljs-params">(<span class="hljs-type">int</span> state, <span class="hljs-type">int</span> symbol)</span> </span>{
        <span class="hljs-keyword">return</span> state | (symbol &#x3C;&#x3C; <span class="hljs-number">16</span>);
    }
};
</code></pre></div>
<p>每次调用时，只需将当前的温度作为<code>transit()</code>函数的参数传入，函数会根据状态和符号在状态表中切换状态。</p>
<blockquote>
<p>状态机原理</p>
<blockquote>
<p>状态机原理是由符号表，状态表，转移函数，以及开始和结束，简单可以用一句话以概括：状态机通过符号表的符号在转移函数上切换状态表中的不同状态。状态机分为有穷状态机和无穷状态机，无穷状态机的状态表大小不同于有穷状态机，无穷状态机可存在无限个状态。有穷状态机在编译技术的词法分析和构造形式化语法分析都会用到。</p>
</blockquote>
</blockquote>
<h2 id="策略模式strategy">策略模式（Strategy）<a aria-hidden="true" tabindex="-1" href="#策略模式strategy"><span class="anchor-link"> #</span></a></h2>
<p>策略模式能够实现一种算法自定义的功能。例如，如果现在有一款软件支持机器学习，为了使用它，我们需要进行模型选择并加以训练，以用于后续的实际预测。这里的模型即可以抽象化为策略，对于不同的模型选择，即为对不同的策略选择。</p>
<p><img src="/post/softwaredesignpattern4/efdffe0eb9a6.png" alt="Strategy"></p>
<p>代码实现：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Strategy</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">train</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">predict</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearRegression</span> : <span class="hljs-keyword">public</span> Strategy {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">train</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 线性回归训练</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">predict</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 线性回归预测</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DecisionTree</span> : <span class="hljs-keyword">public</span> Strategy {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">train</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 决策树训练</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">predict</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 决策树预测</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Forest</span> : <span class="hljs-keyword">public</span> Strategy {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">train</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 森林训练</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">predict</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 森林预测</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">NeuralNetwork</span> : <span class="hljs-keyword">public</span> Strategy {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">train</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 神经网络训练</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">predict</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 神经网络预测</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">AIDecision</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setStrategy</span><span class="hljs-params">(Strategy* s)</span> </span>{
        strategy = s;
        <span class="hljs-built_in">scheduleTrain</span>();
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">decisionPredict</span><span class="hljs-params">()</span> </span>{
        strategy-><span class="hljs-built_in">predict</span>();
    }
<span class="hljs-keyword">private</span>:
    Strategy* strategy;
};
</code></pre></div>
<p>调用者使用，如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp">AIDecision ai;

<span class="hljs-comment">// 使用神经网络模型的策略进行预测</span>
<span class="hljs-keyword">auto</span> stra = <span class="hljs-keyword">new</span> <span class="hljs-built_in">NeuralNetwork</span>();
ai.<span class="hljs-built_in">setStrategy</span>(stra);
ai.<span class="hljs-built_in">decisionPredict</span>();
</code></pre></div>
<h2 id="模版方法模式template-method">模版方法模式（Template Method）<a aria-hidden="true" tabindex="-1" href="#模版方法模式template-method"><span class="anchor-link"> #</span></a></h2>
<p>模版方法是在超类中定义一套算法框架，继承该超类的子类可以在不修改结构的情况下重写算法的特定步骤。</p>
<p>例如，编辑器软件中，可以将基本操作方法设计为超类，但是对于不同类型的文件处理方式，子类可以重写方法实现特定文件的操作。</p>
<p><img src="/post/softwaredesignpattern4/11d0af43cb52.png" alt="Template Method"></p>
<p>代码如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicEditor</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 打开文件</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 加载文件数据</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 关闭文件</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 保存文件</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 查找文件</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">undo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 恢复</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">redo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 重做</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goto_</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 光标偏移</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">select</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 文本选择</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">RtfEditor</span> : <span class="hljs-keyword">public</span> BasicEditor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 富文本数据加载</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">DocEditor</span> : <span class="hljs-keyword">public</span> BasicEditor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Doc文档加载</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">PdfEditor</span> : <span class="hljs-keyword">public</span> BasicEditor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// Pdf文档数据加载</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 不支持保存，Pdf只支持查看，不能更改</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">undo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 不支持保存，Pdf只支持查看，不能更改</span>
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">redo</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 不支持保存，Pdf只支持查看，不能更改</span>
    }
};
</code></pre></div>
<h2 id="访问者模式visitor">访问者模式（Visitor）<a aria-hidden="true" tabindex="-1" href="#访问者模式visitor"><span class="anchor-link"> #</span></a></h2>
<p>访问者模式是把算法和访问对象隔离开来的方式。</p>
<p>这种方式下，访问对象不需要任何更新，同时可以达到对象属性访问能力。</p>
<p><img src="/post/softwaredesignpattern4/a8db09ca9457.png" alt="Visitor"></p>
<p>上图中，实现的是通过访问者模式从应用程序的菜单和工具栏获取图标图片的示例。</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CtrlItem</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Image* <span class="hljs-title">image</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ToolbarItem</span> : <span class="hljs-keyword">public</span> CtrlItem {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Image* <span class="hljs-title">image</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 返回图标图片</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MenuItem</span> : <span class="hljs-keyword">public</span> CtrlItem {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Image* <span class="hljs-title">image</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-comment">// 返回图标图片</span>
    }
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Image* <span class="hljs-title">visit</span><span class="hljs-params">(ToolbarItem*)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function">Image* <span class="hljs-title">visit</span><span class="hljs-params">(MenuItem*)</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageVisitor</span> : <span class="hljs-keyword">public</span> Visitor {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Image* <span class="hljs-title">visit</span><span class="hljs-params">(ToolbarItem* item)</span> </span>{
        <span class="hljs-keyword">return</span> item-><span class="hljs-built_in">image</span>();
    }
    <span class="hljs-function">Image* <span class="hljs-title">visit</span><span class="hljs-params">(MenuItem* item)</span> </span>{
        <span class="hljs-keyword">return</span> item-><span class="hljs-built_in">image</span>();
    }
};
</code></pre></div>
<p>使用访问者模式如下：</p>
<div class="code-block-wrapper"><div class="code-block-header"><span class="code-block-lang">cpp</span><button class="copy-button" data-copy-state="copy" aria-label="Copy code to clipboard" type="button" onclick="copyCode(this)"><span class="copy-button-text">Copy</span></button></div><pre><code class="hljs language-cpp">ToolbarItem* item1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ToolbarItem</span>(<span class="hljs-string">"a.png"</span>);
ToolbarItem* item2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ToolbarItem</span>(<span class="hljs-string">"b.png"</span>);
MenuItem* item3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MenuItem</span>(<span class="hljs-string">"c.png"</span>);

ImageVisitor visitor;
<span class="hljs-keyword">auto</span> image1 = visitor.<span class="hljs-built_in">visit</span>(item1);
<span class="hljs-keyword">auto</span> image2 = visitor.<span class="hljs-built_in">visit</span>(item2);
<span class="hljs-keyword">auto</span> image3 = visitor.<span class="hljs-built_in">visit</span>(item3);
</code></pre></div>7:["$","$L15",null,{"postData":{"id":"softwaredesignpattern4","contentHtml":"$16","title":"软件设计模式 - 行为模式","date":"$D2017-06-08T22:01:03.000Z","updated":"$D2024-10-08T20:15:08.000Z","categories":["总结"],"tags":["设计模式"]}}]
10:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
b:null
14:{"metadata":[["$","title","0",{"children":"软件设计模式 - 行为模式"}],["$","meta","1",{"name":"description","content":"HCHEN90 博客"}],["$","link","2",{"rel":"alternate","type":"application/atom+xml","href":"https://hchen90.top/atom.xml"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]],"error":null,"digest":"$undefined"}
e:{"metadata":"$14:metadata","error":null,"digest":"$undefined"}
