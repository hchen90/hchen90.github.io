<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>程序的代码修改问题</title>
    <url>/2022/06/11/codemodification/</url>
    <content><![CDATA[<h1 id="什么是代码改动"><a href="#什么是代码改动" class="headerlink" title="什么是代码改动"></a>什么是代码改动</h1><p>在软件项目中都存在一个生命周期，无论周期长短，都会涉及到代码改动，不管是对以前缺陷的修复，还是在敏捷开发中（每一个故事的迭代），都会或多或少地产生代码修改。</p>
<span id="more"></span>

<h1 id="为什么会发生代码改动"><a href="#为什么会发生代码改动" class="headerlink" title="为什么会发生代码改动"></a>为什么会发生代码改动</h1><p>代码修改其实是很常见的，但代码修改却是要尽量避免的，我们可以使用极限思维，一种是无比兼容的代码，它不需要任何修改，即可满足业务需求，这种代码在我们生活中是可见的，如果把业务代码不算作真正的代码，而是业务逻辑流程，那么脚本驱动的服务框架，其底层是用高效的原生语言编写（例如：C++），其使用通用设计模型和抽象方法，这种底层很少改动，上层的脚本业务受之驱动，那么这种代码就是几乎不需要修改的，需要改的就是业务脚本（无代码方案也是一种极限思维）；另外一种就是前者相反，它会把业务参杂到代码的各个角落，代码没有什么抽象层，这种代码如果对业务不熟，对于代码的阅读性就会下降，业务的修改都会直接引发代码修改，可维护性以及复用性都不高。</p>
<blockquote>
<p>我们都不想修改代码，因为修改会花费成本，时间和精力，而我们之所以这么做，却仅仅为了弥补以前做的不足？那么为何不站在前期的角度为后期做点着想，做好预防性工作，更利于项目的健康发展，后期维护成本更低。</p>
</blockquote>
<h1 id="如何进行代码改动"><a href="#如何进行代码改动" class="headerlink" title="如何进行代码改动"></a>如何进行代码改动</h1><p>我们可以尽量避免改动代码，但是又不得不改动代码，因此如何把代码改好，减少它的不足也可以提升项目代码质量。</p>
<p>对于如何写优雅的代码一直都是有迹可循的，计算机行业存在大量相关的资料文档。</p>
<h2 id="代码常识性规则"><a href="#代码常识性规则" class="headerlink" title="代码常识性规则"></a>代码常识性规则</h2><p>常识性的问题，一般人都会知道，但是对于代码逻辑来说是无关紧要的，因为它其实和代码没有关系，但是有了它可以减少代码中犯错误。</p>
<h3 id="代码对齐"><a href="#代码对齐" class="headerlink" title="代码对齐"></a>代码对齐</h3><p>一般来说，用空格键代替Tab键，可以明显改善此点，尤其在团队开发的时候，这点更加明显（代码对其，对于使用高级编辑器的来说，他可以自动格式化代码，几乎不用操心了）。</p>
<h3 id="代码注释"><a href="#代码注释" class="headerlink" title="代码注释"></a>代码注释</h3><p>代码注释也是代码格式的一种，合理的代码注释可以便于开发人员对于代码的理解，从而提高效率。如今各自格式的代码注释花样百出，支持生成丰富的api文档，等等，都是便于后期对于代码的查看与理解。</p>
<h2 id="代码逻辑需要注意的地方"><a href="#代码逻辑需要注意的地方" class="headerlink" title="代码逻辑需要注意的地方"></a>代码逻辑需要注意的地方</h2><p>代码逻辑流程，不同的人因为不同的习惯而写出的代码可谓天差地别，但是有很多不错的代码逻辑是值得借鉴的，代码逻辑流程和上面的格式规则不同，它会直接影响到二进制代码的运行质量。</p>
<h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>很多的时候，代码中对于条件的判断可能很简单，程序也许只关心一种条件，所以很多时候会忽略掉了ELSE情形，这是一种不好的习惯，代码质量也不会很高。</p>
<p>如下这种代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_node</span><span class="params">(<span class="type">const</span> std::unordered_map&lt;std::string&gt;&amp; poll, std::unordered_map&lt;std::string&gt;&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_wanted</span>(poll, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">store_result</span>(result, <span class="built_in">load_item</span>(poll, <span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_wanted</span>(poll, <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="built_in">store_result</span>(result, <span class="built_in">load_item</span>(poll, <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_wanted</span>(poll, <span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="built_in">store_result</span>(result, <span class="built_in">load_item</span>(poll, <span class="number">2</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种代码就是典型的ELSE缺失，它将导致冗余执行，代码运行质量会下降。</p>
<p>我们可以进行适当的修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">make_node</span><span class="params">(<span class="type">const</span> std::unordered_map&lt;std::string&gt;&amp; poll, std::unordered_map&lt;std::string&gt;&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_wanted</span>(poll, <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="built_in">store_result</span>(result, <span class="built_in">load_item</span>(poll, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_wanted</span>(poll, <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="built_in">store_result</span>(result, <span class="built_in">load_item</span>(poll, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">is_wanted</span>(poll, <span class="number">2</span>)) &#123;</span><br><span class="line">    <span class="built_in">store_result</span>(result, <span class="built_in">load_item</span>(poll, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>冗余执行即可消除，这是让所有的ELSE按默认往下走的意思，这种风格通常用来判断一个函数是否满足条件以执行时，很常用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_condition</span><span class="params">(<span class="type">int</span> flags, std::vector&lt;<span class="type">int</span>&gt;&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flags == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; <span class="number">0xa0</span> &amp;&amp; flags &amp; <span class="number">0x0c</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; <span class="number">0x80</span>) <span class="keyword">return</span> <span class="built_in">update_result_v1</span>(result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; <span class="number">0x02</span>) <span class="keyword">return</span> <span class="built_in">update_result_v2</span>(result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">update_result</span>(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>循环语句是用来迭代执行的，但是程序需要在有限的时间里得到确定性的结果，所以循环语句不恰当的使用也会导致低质量的代码，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">maybe_infinite_loop</span><span class="params">(<span class="type">int</span> flags, std::vector&lt;<span class="type">int</span>&gt;&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags</span>(&amp;flags)) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags_v1</span>(&amp;flags)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">store_result</span>(flags, result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述的几行代码，就有可能是缺陷代码，这里假设<code>check_flags</code>和<code>check_flags_v1</code>不是基于状态模式的，那么代码就存在无限循环的可能。</p>
<h4 id="有穷循环"><a href="#有穷循环" class="headerlink" title="有穷循环"></a>有穷循环</h4><p>对于上述的代码可以设计一个简单的状态转换表，使每条转化路径都是从<strong>开始状态</strong>走到<strong>终结状态</strong>，这样引入状态模式就变成这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">finite_loop</span><span class="params">(<span class="type">int</span> flags, std::vector&lt;<span class="type">int</span>&gt;&amp; result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">state_start</span>(&amp;flags); it != <span class="built_in">state_end</span>(&amp;flags); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags</span>(&amp;flags)) <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags_v1</span>(&amp;flags)) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">store_result</span>(flags, result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的逻辑会存在确定性终结点。</p>
<h4 id="尽量不要打破循环层次"><a href="#尽量不要打破循环层次" class="headerlink" title="尽量不要打破循环层次"></a>尽量不要打破循环层次</h4><p>我们先看一个头都变大的代码段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad_loop</span><span class="params">(<span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags_v1</span>(&amp;flags)) <span class="keyword">break</span>;</span><br><span class="line">___end1:</span><br><span class="line">    <span class="built_in">func_v1</span>();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">check_flags_v2</span>(&amp;flags)) <span class="keyword">goto</span> ___end1;</span><br><span class="line">___end2:</span><br><span class="line">      <span class="built_in">func_v2</span>();</span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_flags_v3</span>(&amp;flags)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_flags_v4</span>(&amp;flags)) <span class="keyword">goto</span> ___end1;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_flags_v5</span>(&amp;flags)) <span class="keyword">goto</span> ___end2;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种代码的可维护性特别差，为了理清代码逻辑，需要花更多的时间和精力，所以，还是那条规则，尽量避免使用<code>goto</code>语句，避免复杂混乱的流程。</p>
<p>改善后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bad_loop</span><span class="params">(<span class="type">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> state = <span class="number">0</span>; <span class="comment">// 状态开始</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">state_start</span>(&amp;state); it != <span class="built_in">state_end</span>(&amp;state); it++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags</span>(&amp;state)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags_v1</span>(&amp;flags)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">func_v1</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags_v2</span>(&amp;flags)) <span class="built_in">state_move</span>(&amp;flags, <span class="number">5</span>); <span class="comment">// 5 - __end1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags_v2</span>(&amp;flags)) <span class="built_in">state_move</span>(&amp;flags, <span class="number">6</span>); <span class="comment">// 6 - __end2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags_v3</span>(&amp;flags)) <span class="built_in">state_move</span>(&amp;flags, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags_v4</span>(&amp;flags)) <span class="built_in">state_move</span>(&amp;flags, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">check_flags_v5</span>(&amp;flags)) <span class="built_in">state_move</span>(&amp;flags, <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样改良后的代码不仅容易理解，而且复杂度明显优化，代码运行效率更高。</p>
<blockquote>
<p>对于深层次的循环代码，不宜跨层次跳转，这里还是避免使用<code>goto</code>语句，否则很容易打破逻辑层次，使代码变得混乱。</p>
</blockquote>
<h3 id="重复代码块"><a href="#重复代码块" class="headerlink" title="重复代码块"></a>重复代码块</h3><p>有时代码中存在多个小段代码片段，功能上相差无几（很可以是前人Ctrl C+Ctrl V，修修改改留下的），其使用频率也很高，这种代码可以进一步优化，使其成为一个功能性的调用函数。</p>
<h3 id="用状态标记来跟踪执行"><a href="#用状态标记来跟踪执行" class="headerlink" title="用状态标记来跟踪执行"></a>用状态标记来跟踪执行</h3><p>状态位标记实际上就是上面的状态模式的设计方法（用于确定性的for循环），其实很多时候，并不是循环才会用状态模式，任何情形都可以用，但是对于复杂的执行流程情形，状态模式更易抽象流程，也便于调试和排查，它带来的各种好处是显而易见的，也是各种优秀架构设计对于复杂流程处理经常选择该模式的原因。</p>
<h1 id="代码哲学"><a href="#代码哲学" class="headerlink" title="代码哲学"></a>代码哲学</h1><p>代码方面，如果代码可以满足如下几点，那么就可以说这是优秀的代码：</p>
<ul>
<li>通过所有测试</li>
<li>没有重复代码</li>
<li>体现系统的全部设计理念</li>
<li>包含尽量少的实体（例如：类型，函数）</li>
</ul>
<h2 id="命名方式"><a href="#命名方式" class="headerlink" title="命名方式"></a>命名方式</h2><ul>
<li>蛇形命名</li>
<li>大驼峰命名</li>
<li>小驼峰命名</li>
</ul>
<p>统一的变量命名方式，可以便于代码的沟通与理解，从而可以提高团队的生产效率。</p>
<h2 id="代码格式问题"><a href="#代码格式问题" class="headerlink" title="代码格式问题"></a>代码格式问题</h2><p>代码格式主要是空白字符，换行字符等等的编码或默认使用的规则，一般而言，编辑器是可以定制化这些格式的，然后团队可以共享一份编码规章，这样在同一项目中就不会产生代码格式不同而发生的显示风格差异。</p>
<h2 id="代码抽象"><a href="#代码抽象" class="headerlink" title="代码抽象"></a>代码抽象</h2><p>代码抽象层面需要探讨一下，作为软件工程方面，必须理解的设计模式，不是说对所有的模式倒背如流，而是说对常用的设计模式能够理解，并知道在什么场景下要用它，它能解决什么问题。</p>
<h3 id="为何要使用设计模式呢？"><a href="#为何要使用设计模式呢？" class="headerlink" title="为何要使用设计模式呢？"></a>为何要使用设计模式呢？</h3><p>因为在解决同一问题时，不同的人就有可能存在不同的表达方法，在代码层表现出的差异就会更加明显，而对于团队项目来说，这样的代码要让同时几十人来维护，需要每个人去理清它的具体逻辑将会很耗时间和精力，那么为何不让团队们一起使用同种语言来交流表达呢？所以在逻辑层面就有了设计模式，这样的话，张三写的逻辑，他在表达一个<strong>外观设计模式</strong>，李四只要知道<strong>外观设计模式</strong>，看了他的代码之后便一眼明白他的逻辑，这样团队就可以节省大量的时间和精力成本，从而更加高效地投入有意义的工作价值之中。</p>
<p>而设计模式正是应用软件开发中常见的底层逻辑，因此作为开发首先就是需要抽象化功能逻辑到设计模式（但如果不能抽象化，一般来说就是对设计模式无法掌握）。</p>
<blockquote>
<p>德墨忒耳定律：<br>模块使用者不应该了解对象的内部细节</p>
</blockquote>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>单元测试通常是用来对代码功能模块的正确性进行检验的工具，如果软件的所有功能模块都是正确的，那么软件集成后的代码也是可以方便调试的，并极有可能也是正确的。因为功能模块属于部分性问题，集成的软件属于整体性问题，如果整体性问题不满足，说明部分性问题在顺序或相互依赖上存在差错，而我们就不用再考虑模块内的事情了，只需调整功能模块间的顺序或依赖即可解决问题。</p>
<h2 id="跌进规则"><a href="#跌进规则" class="headerlink" title="跌进规则"></a>跌进规则</h2><ul>
<li>通过所有的测试</li>
<li>重构代码</li>
<li>代码不可重复性</li>
<li>表达程序员的意图</li>
<li>尽量少的类和方法数量</li>
</ul>
<h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>在多线程系统中，会出现并发问题，并发的意思指多个运行节点对于某个资源的使用，在时间上具有不确定性。</p>
<blockquote>
<p>并发和并行：<br>并发是指多个执行节点对单个资源使用在时间上具有不确定性，无法断定谁先谁后的问题；而并行则是说多个执行节点对于单个资源的使用，可能存在同时使用的可能。<br>实际上解决好并发问题，也是解决了并行的问题。</p>
</blockquote>
<h3 id="互斥与同步的问题"><a href="#互斥与同步的问题" class="headerlink" title="互斥与同步的问题"></a>互斥与同步的问题</h3><p>正是多执行节点对单个资源使用在时间序列的不确定，需要一种互斥同步使用的机制。</p>
<p>首先，需要知道互斥操作，它是一种排他操作，用于在使用资源的时候，资源被锁定，其他使用者无法获取使用。</p>
<p>操作系统里面用PV术语来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P()</span><br><span class="line">do_resource()</span><br><span class="line">V()</span><br></pre></td></tr></table></figure>

<p>PV操作都是原子化的，当执行P操作后，若存已经在资源使用，P操作会被阻塞，直到资源使用完毕，V操作执行后，资源就被正式是否，阻塞在P操作的一个使用者会立即得到使用权，并继续获取&#x2F;使用&#x2F;释放的操作流程。</p>
<p>在C++中，也是用同样的方式机制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> std::unordered_map&lt;std::string&gt; resource;</span><br><span class="line"><span class="type">static</span> std::mutex mut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cosume_resource</span><span class="params">()</span> <span class="comment">// 被多线程调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mut.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="built_in">consume</span>(&amp;resource);</span><br><span class="line">  mut.<span class="built_in">unlock</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但C++里面还可以设计一种原子锁，这种是确定资源消耗时间是可终结的，它起到的作用就是线程挂起，使之只能一个线程消耗资源，适合资源消耗简短的逻辑，因其结构简单，效率往往比互斥锁高。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> lck = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">atomic_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (lck &lt; <span class="number">0</span>) &#123;&#125;</span><br><span class="line">  lck--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume_resource</span><span class="params">()</span> <span class="comment">// 被多线程调用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">atomic_lock</span>();</span><br><span class="line">  <span class="built_in">consume_resource</span>(&amp;resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步问题，是从互斥问题推导出来的，他是两个互斥操作之间的同步问题，仍然采用PV术语来表达。</p>
<p>对于生产者而言：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P(S1)</span><br><span class="line">P(N1)</span><br><span class="line">do_produce()</span><br><span class="line">V(N1)</span><br><span class="line">V(S2)</span><br></pre></td></tr></table></figure>

<p>这里M的互斥锁是用于锁容器池的（池子发生改变时一定要加锁），当生产完一个，同时计数一个到N对应的计数锁。</p>
<p>对应的消费者为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P(S2)</span><br><span class="line">P(N2)</span><br><span class="line">resource = get()</span><br><span class="line">V(N2)</span><br><span class="line">V(S1)</span><br><span class="line">do_consume(resource)</span><br></pre></td></tr></table></figure>

<h3 id="生产者和消费者概念"><a href="#生产者和消费者概念" class="headerlink" title="生产者和消费者概念"></a>生产者和消费者概念</h3><p>生产者和消费者是对互斥同步问题抽象而来的，而且对于资源的取用使用更通用的方式，通常为资源容器池，这样只要生产者没有把容器池放满，就一直可以存放资源，消费者也是可以在容器池未消耗完前一直可以消耗资源，提高互斥同步的效率。</p>
<p>可以用C++这样表示，对应生产者和消费者：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> std::mutex producer_lock;</span><br><span class="line"><span class="type">static</span> std::mutex consumer_lock;</span><br><span class="line"><span class="type">static</span> std::mutex poll_lock;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> std::unordered_map&lt;std::string&gt; poll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">produce</span><span class="params">()</span> <span class="comment">// 多线程生产</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  producer_lock.<span class="built_in">lock</span>();</span><br><span class="line">  poll_lock.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="built_in">do_produce</span>(&amp;poll);</span><br><span class="line">  poll_lock.<span class="built_in">unlock</span>();</span><br><span class="line">  consumer_lock.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consume</span><span class="params">()</span> <span class="comment">// 多线程消费</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  consumer_lock.<span class="built_in">lock</span>();</span><br><span class="line">  poll_lock.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="keyword">auto</span> resource = <span class="built_in">get</span>(&amp;poll);</span><br><span class="line">  poll_lock.<span class="built_in">unlock</span>();</span><br><span class="line">  producer_lock.<span class="built_in">unlock</span>();</span><br><span class="line">  <span class="built_in">do_consume</span>(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://dl.acm.org/doi/pdf/10.1145/358589.358596">Improving Computer Program Readability to Aid Modification</a></p>
<p><a href="https://www.amazon.cn/dp/B00CBBJWJQ/ref=sr_1_1?__mk_zh_CN=%E4%BA%9A%E9%A9%AC%E9%80%8A%E7%BD%91%E7%AB%99&crid=28DGF820DETG3&keywords=clean+code&qid=1654883200&sprefix=clean+code,aps,74&sr=8-1">Clean Code</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>expr</tag>
      </tags>
  </entry>
  <entry>
    <title>玩转自搭建 GitLab 社区版</title>
    <url>/2022/07/02/deploygitlabcerunner/</url>
    <content><![CDATA[<h1 id="玩转自搭建-GitLab-社区版"><a href="#玩转自搭建-GitLab-社区版" class="headerlink" title="玩转自搭建 GitLab 社区版"></a>玩转自搭建 GitLab 社区版</h1><p>本文的自搭建是基于docker容器技术而实现的，其中包括<code>gitlab-ce</code>和<code>gitlab-runner</code>两个部分。</p>
<h2 id="什么是-GitLab"><a href="#什么是-GitLab" class="headerlink" title="什么是 GitLab"></a>什么是 GitLab</h2><p><strong>GitLab</strong>是一个代码仓库管理系统（它是一套开源项目），使用 Git 作为代码管理工具，集成 Web 管理的服务，<strong>GitLab</strong>被广泛用于基于 Git 代码管理平台，在很多一些结构不是复杂的组织结构中都会优先使用它。</p>
<span id="more"></span>

<h2 id="它能做什么"><a href="#它能做什么" class="headerlink" title="它能做什么"></a>它能做什么</h2><p><strong>GitLab</strong>是代码仓库管理系统，它实现了一个更加界面友好的交互方式来对项目代码进行管理，除此之外，它还可以集成CI&#x2F;CD特性，通过部署 <strong>GitLab-Runner</strong> 来对项目代码进行持续集成和部署分发。</p>
<p>功能很实用，可以满足常规的项目开发工作。</p>
<blockquote>
<p>对比一些大项目，其设计复杂，对于代码的管控也非常复杂，采取的管理手段也多样化，GitLab可能不一定适应这种场景，为此大多数的做法是仓库管理系统和CI&#x2F;CD系统分离的结构，仓库管理系统有五花八门的，有自己开发的（或者基于其他的开源项目），而对于CI&#x2F;CD系统一般都是采用Jenkins，其有更加丰富的成熟套件和流程方案。</p>
</blockquote>
<h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><p>这里介绍我测试搭建这套系统的搭建步骤。</p>
<h3 id="搭建-GitLab-主框架"><a href="#搭建-GitLab-主框架" class="headerlink" title="搭建 GitLab 主框架"></a>搭建 GitLab 主框架</h3><p>在Docker镜像的主官网上，我们其实可以搜索到<strong>GitLab</strong>的镜像，所以我们很方便的使用Docker技术来部署我们需要的服务。</p>
<p><img src="/2022/07/02/deploygitlabcerunner/docker-gitlab-ce.png" alt="docker-gitlab-ce"></p>
<p>该镜像下有很多的<code>tags</code>，可以指定特定的版本，或者使用默认的最近版本。</p>
<p><strong>GitLab</strong>的管理系统搭建，我使用编写<code>docker-compose.yml</code>方式来部署的，注意添加服务的时候，设置的环境变量<code>GITLAB_OMNIBUS_CONFIG</code>，可以为服务启动传递启动参数。</p>
<p>当仓库管理系统服务创建并启动后，我们就可以打开浏览器来访问自搭建部署的<strong>GitLab</strong>服务了，如下图所示：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/login.png" alt="login"></p>
<h3 id="登录管理员账号"><a href="#登录管理员账号" class="headerlink" title="登录管理员账号"></a>登录管理员账号</h3><p>以上步骤之后，需要登录管理员的账号，来进一步对系统进行配置，管理员的用户名是<code>root</code>，而密码需要从容器里面去获取，我们也可以获取容器的IP，便于后面的设置使用，如下：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/gitlab-ce-info.png" alt="gitlab-ce-info"></p>
<p>据此我们得到管理员的密码来登录系统。</p>
<p><img src="/2022/07/02/deploygitlabcerunner/admin-dashboard.png" alt="admin-dashboard"></p>
<p>系统登录后进入系统配置的页面，在此页面上，我们可以完成仓库管理系统的所有配置工作。</p>
<blockquote>
<p>我们弄这个GitLab绝对不是仅仅作为代码管理系统而用的，如果仅仅为了代码仓库管理，可以移步到<code>gogs</code>这些代码仓库管理系统，它速度快，简洁而且美观，很有Github的界面感。</p>
</blockquote>
<h4 id="CI-x2F-CD环境部署配置"><a href="#CI-x2F-CD环境部署配置" class="headerlink" title="CI&#x2F;CD环境部署配置"></a>CI&#x2F;CD环境部署配置</h4><p>这是配置的重头戏了。</p>
<p>当上面的步骤都差不多了，就要进行<strong>GitLab-Runner</strong>的部署，它是CI&#x2F;CD的代理节点，我们可以在管理员界面下点开<strong>Runner</strong>查看可以用的列表：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/runners.png" alt="runners"></p>
<p>上面啥也没有，我们需要弄一个代理机器作为节点，让它去跑<strong>Runner</strong>，为此我们需要在代理机器上安装<strong>GitLab-Runner</strong>，这是常规操作。</p>
<p>但是，我只是测试一下GitLab的特性，把玩一下而已，所有不需要那么复杂，仍然可以通过部署Docker的<strong>GitLab-Runner</strong>服务的运行它，并把它注册到本地，这样为了便于解析IP，我需要调整一下Hosts文件的内容，增加一行解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.176.2 gitlab.me</span><br></pre></td></tr></table></figure>

<p>上面的<code>192.168.176.2</code>，不一定和你的一样，需要和上面的容器内的IP对应，这样多个容器都可以正确解析到正确的IP上去。</p>
<p>下面是注册 Runner （这里的<code>token</code>可以从上图的<code>Registration token</code>处复制过来），如图所示：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/runner-register.png" alt="runner-register"></p>
<p>注册成功后，会在上面的Runners列表里面刷新出来。</p>
<blockquote>
<p>注意到，我这里的<code>executor</code>用的是<code>docker</code>，这样我可以用Docker镜像（gcc）来编译代码，这适合这种用Docker容器部署的情形，但是如果是直接把Runner安装在了实体机器上的，并且实体机器上已经存在开发环境，那么我们可以直接用<code>shell</code>方式来编译。如果是需要在代理节点上再次ssh登录远程机器来编译代码，那么<code>executor</code>就应该选用<code>ssh</code>的方式。具体使用哪种方式取决于实际环境。</p>
</blockquote>
<p>注册成功后，在 <strong>Runners</strong> 列表刷新出刚刚新加的<strong>Runner</strong>，如下图：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/runner-list.png" alt="runner-list"></p>
<p>上图中，点击左边的链接可以看到 <strong>Runner</strong> 的详情：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/runner-details.png" alt="runner-details"></p>
<p>点击右边的铅笔，可以修改Runner的参数设定：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/runner-enable-untag.png" alt="runner-enable-untag"></p>
<p>这里我把<code>Run untagged jobs</code>复选框勾上，并保存修改。</p>
<p>到这里整个<strong>Runner</strong>的配置基本就完成了。</p>
<blockquote>
<p>Runner还有更多的配置，详情可以参考官方文档介绍。</p>
</blockquote>
<h3 id="创建普通用户帐号"><a href="#创建普通用户帐号" class="headerlink" title="创建普通用户帐号"></a>创建普通用户帐号</h3><p>接着我们打开一个隐私页面，进入登录界面，这次我们点击<code>Register now</code>来新建用户，填写完用户信息后，注册一个新的用户，然后需要管理员在用户管理界面上进行批准，批准通过后，刚注册的用户就可以正常登录系统了，如下图（图中的用户已经新建了一个仓库）：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/user-projects.png" alt="user-projects"></p>
<p>该普通用户帐户是开发者，后面测试CI&#x2F;CD系统将以该用户进行测试。</p>
<h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>新建仓库非常简单，只需点击<code>New project</code>后，填写项目基本信息即可：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/new-project.png" alt="new-project"></p>
<h4 id="设置仓库的-gitlab-ci"><a href="#设置仓库的-gitlab-ci" class="headerlink" title="设置仓库的 gitlab-ci"></a>设置仓库的 gitlab-ci</h4><p>设置仓库根目录下的<code>.gitlab-ci.yml</code>文件，添加流水线任务。</p>
<p>我写的非常简单，<code>script</code>指定编译命令，<code>only</code>指定在哪一个分支下进行CI部署（我指定的是：main分支），然后<code>tags</code>和注册<strong>Runner</strong>的<code>tags</code>一一对应的。</p>
<blockquote>
<p>关于<code>gitlab-ci.yml</code>文件的更多细节可以参考<a href="https://docs.gitlab.com/ee/ci/yaml/gitlab_ci_yaml.html">官方文档</a>。</p>
</blockquote>
<h4 id="提交代码并进行-CI-操作"><a href="#提交代码并进行-CI-操作" class="headerlink" title="提交代码并进行 CI 操作"></a>提交代码并进行 CI 操作</h4><p>当一切都准备妥当后，下面就是写代码，并提交到远程仓库的main分支下：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/git-push.png" alt="git-push"></p>
<p>刚提交了代码，系统上立即显示流水线就已经在更新了。</p>
<p><img src="/2022/07/02/deploygitlabcerunner/pipelines.png" alt="pipelines"></p>
<p>可以点开正在执行的流水，查看任务细节：</p>
<p><img src="/2022/07/02/deploygitlabcerunner/pipeline-success.png" alt="pipeline-success"></p>
<p>至此，这个<strong>GitLab</strong>的基本配置，和它的CI&#x2F;CD流水配置，以及使用也已经完成，这套代码管理系统的实用性，总体来说还算不错的。</p>
<h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>以下两个文件是我的测试配置，仅供参考。</p>
<h3 id="我的测试配置"><a href="#我的测试配置" class="headerlink" title="我的测试配置"></a>我的测试配置</h3><p><code>.gitlab-ci.yml</code>配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build source:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">linux</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">gcc</span> <span class="string">-o</span> <span class="string">main</span> <span class="string">main.c</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">interruptible:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p><code>docker-compose.yml</code>配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">gitlab-web:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitlab/gitlab-ce</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">&#x27;gitlab.me&#x27;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        external_url &#x27;http://gitlab.me:2080/&#x27;</span></span><br><span class="line"><span class="string"></span>    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;2080:2080&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;2443:443&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitlab/config:/etc/gitlab</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitlab/logs:/var/log/gitlab</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitlab/data:/var/opt/gitlab</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitlab</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">gitlab-runner:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">gitlab/gitlab-runner:alpine</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitlab-web</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitlab/gitlab-runner:/etc/gitlab-runner</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitlab</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitlab:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gitlab-network</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="我遇到的坑"><a href="#我遇到的坑" class="headerlink" title="我遇到的坑"></a>我遇到的坑</h3><blockquote>
<p>可能会碰到的坑：</p>
<ol>
<li><code>docker-compose.yml</code>文件中设置环境变量<code>GITLAB_OMNIBUS_CONFIG</code>中的<code>external_url</code>，如果域名带端口，docker的服务监听会绑定到该端口上；</li>
<li><code>gitlab-runner</code>的配置（config.toml），<code>runner.docker</code>节区下添加<code>network_mode</code>为<code>gitlab-network</code>以对应<code>docker-compose.yml</code></li>
</ol>
</blockquote>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="https://www.czerniga.it/2021/11/14/how-to-install-gitlab-using-docker-compose/">how-to-install-gitlab-using-docker-compose</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在 Linux 系统启用 UEFI 的 Secure Boot</title>
    <url>/2017/09/02/enablesbonlinux/</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Secure Boot 作为 UEFI 的一个选项，它可以被设置为开启或关闭 ( 有少数的计算机里面， Secure Boot 被设置为开启，却不存在关闭它的选项，但系统主板内置有 Windows 系统的公钥证书签名，使其只能加载 Windows ，其他系统一律不以加载，用户没有选项，不能关闭，还没法换系统，无法适用本博客介绍内容）。 Secure Boot 所需要的公钥证书被保存在计算机的主板的 FLASH 里面（注意不是磁盘里面哦），在主板的一小块 FLASH 里面保存着 PK ， KEK， db， dbx 的证书链，所以， <strong>在操作开始前请确保你的计算机 UEFI-BIOS 的 Secure Boot 能够被关闭，否则，发生操作失误，将导致证书不能匹配任何程序代码文件，而使主板拒绝加载任何程序代码文件，就会导致主板变砖</strong> (虽然它不是 BIOS ，但是许多人都这么称呼它为 UEFI-BIOS ，所以，这里也这么称呼其为 UEFI-BIOS) 。</p>
<span id="more"></span>

<p>这里说一下 Fedora 是如何做到在 Secure Boot 开启时加载的，它实际上是 Fedora 开源项目向微软公司购买签名达到的， Fedora 被系统的主板识别为和 Windows 一样的系统，这种购买行为在开源社区是不鼓励的，好处是 Fedora 几乎可以在任何可以加载 Windows 系统上被识别加载，即使该计算机硬件不能关闭 Secure Boot。</p>
<blockquote>
<p>本人只在 ThinkPad 测试成功，其他机器未曾实验过，不过仅从理论来看，应该也会成功。</p>
</blockquote>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>以下工具是必不可少的：</p>
<ul>
<li>openssl</li>
<li>efitools</li>
<li>sbsigntools</li>
</ul>
<p>如果你是第三方编译好的软件包来安装的，可以忽略此步：</p>
<p>在用源代码编译 efitools 时，需要 Perl 的一个模块，名字为 <code>File Slurp</code>，在 <a href="http://www.cpan.org/">cpan</a> 可以找到。</p>
<h2 id="预先准备"><a href="#预先准备" class="headerlink" title="预先准备"></a>预先准备</h2><p>开机进入系统的 UEFI-BIOS 页面，在安全页面里找到 Secure Boot 选项，先关掉 Secure Boot （如果没有关的话），再删除或清空所有证书文件，使机器从 <code>User Mode</code> 转到 <code>Setup Mode</code> 即为正常，如果这两步不能做到，可能影响到下面的步骤。</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><p>这里简要介绍 PK，KEK，db，dbx 和 <em>MOK</em> 的概念。</p>
<ul>
<li><p>Platform Key （PK） － <strong>PK 是用于在硬件平台层和硬件平台拥有者建立起的信任关系</strong> ，规定一个硬件平台只能被一个拥有者所拥有，即 <strong>PK 只能存在一个</strong> ，与拥有者相关的公钥被存储在 FLASH 里面的 PK 变量里面，同时，拥有者的私钥可以来对 PK， KEK， db， dbx 进行签名和管理。</p>
</li>
<li><p>Key Exchange Key (KEK) － <strong>KEK 是用于在硬件平台和操作系统之间建立信任关系</strong> ，KEK 的公钥可以在主板的 FLASH 存在多个不同项，即 <strong>KEK 可以存在多个</strong> ，每一项对应一种可以被启动的操作系统，同样，KEK 的私钥可以来对 db， dbx 进行签名和管理。</p>
</li>
<li><p>Database (db) － db 是用于对 <strong>被许可的 EFI 文件予以加载的数据签名库</strong> ，和 KEK 一样， <strong>db 的公钥可以存在很多项</strong> 。（在 UEFI 平台里面，操作系统加载文件就是一个 EFI 文件）</p>
</li>
<li><p>Database Excluded (dbx) - dbx 是一个 <strong>黑名单数据签名库</strong> ，只要谁的 EFI 签名在这，谁就被屏蔽掉， <strong>dbx 的公钥也可以存在很多项</strong> 。</p>
</li>
<li><p>Machine Owner Key (MOK) - MOK 的作用是等价于 db 的，但是它不是标准 Secure Boot 的内容，<code>PreLoader</code> 和 <code>Shim</code> 使用了 MOK 。</p>
</li>
</ul>
<h3 id="建立-PK，KEK，db-密钥对"><a href="#建立-PK，KEK，db-密钥对" class="headerlink" title="建立 PK，KEK，db 密钥对"></a>建立 PK，KEK，db 密钥对</h3><p>这里需要 Linux 系统中存在 <code>uuidgen</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $(uuidgen) &gt;guid</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>如果你不打算启动 Windows 系统，请忽略文中所有提及有关 Windows 系统的内容</em> </p>
</blockquote>
<p>如果系统不存在 <code>uuidgen</code>，就随便写个 GUID 到那个 guid 文件里，然后把微软的 Owner GUID 写到另外一个文件里：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span>  77fa9abd-0359-4d32-bd60-28f4e78f784b &gt;ms-guid</span><br></pre></td></tr></table></figure>

<p>建立密钥对：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -newkey rsa:2048 -subj <span class="string">&quot;/CN=Platform Key/&quot;</span> -keyout PK.key -out PK.crt -days 3650 -nodes -sha256</span><br></pre></td></tr></table></figure>

<p>上面的 <code>-subj</code> 的参数可以自己设置，参数 <code>-days</code> 是密钥的有效期，这里设置为 10 年，也可以设置为其他，生成私钥 <code>PK.key</code>，公钥 <code>PK.crt</code>。</p>
<p>同理，KEK 和 db 亦是如此：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl req -new -x509 -newkey rsa:2048 -subj <span class="string">&quot;/CN=Key Exchange Key/&quot;</span> -keyout KEK.key -out KEK.crt -days 3650 -nodes -sha256</span><br><span class="line">openssl req -new -x509 -newkey rsa:2048 -subj <span class="string">&quot;/CN=Database/&quot;</span> -keyout db.key -out db.crt -days 3650 -nodes -sha256</span><br></pre></td></tr></table></figure>

<p><em>这里没有建立 dbx 的黑名单，因为暂时用不到这个，也没有黑名单签名文件，MOK 不通用，亦不讨论</em></p>
<h3 id="建立-EFI-List-文件"><a href="#建立-EFI-List-文件" class="headerlink" title="建立 EFI List 文件"></a>建立 EFI List 文件</h3><p>EFI List 文件其实就是公钥配以平台拥有者的 GUID 的文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cert-to-efi-sig-list -g $(<span class="built_in">cat</span> guid) PK.crt PK.esl</span><br><span class="line">cert-to-efi-sig-list -g $(<span class="built_in">cat</span> guid) KEK.crt KEK.esl</span><br><span class="line">cert-to-efi-sig-list -g $(<span class="built_in">cat</span> guid) db.crt db.esl</span><br></pre></td></tr></table></figure>

<p>这样三个公钥就全变成 List 文件了。</p>
<p>为了能够也启动磁盘里的 Windows 系统，下载三个微软的公钥，一个 KEK，两个 db：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L http://go.microsoft.com/fwlink/?LinkID=321185 -o MSKEK.der</span><br><span class="line">curl -L http://go.microsoft.com/fwlink/?LinkID=321192 -o MSdbWPCA.der</span><br><span class="line">curl -L http://go.microsoft.com/fwlink/?LinkID=321194 -o MSdbUDSCA.der</span><br></pre></td></tr></table></figure>

<p>微软的这三个公钥与这里使用的公钥格式不同，需要重新转换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> MSKEK.der -inform DER -out MSKEK.crt</span><br><span class="line">openssl x509 -<span class="keyword">in</span> MSdbWPCA.der -inform DER -out MSdbWPCA.crt</span><br><span class="line">openssl x509 -<span class="keyword">in</span> MSdbUDSCA.der -inform DER -out MSdbUDSCA.crt</span><br></pre></td></tr></table></figure>

<p>同样需要转换成 List 文件，不过这里的 GUID 最好用微软 Owner GUID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cert-to-efi-sig-list -g $(<span class="built_in">cat</span> ms-guid) MSKEK.crt MSKEK.esl</span><br><span class="line">cert-to-efi-sig-list -g $(<span class="built_in">cat</span> ms-guid) MSdbWPCA.crt MSdbWPCA.esl</span><br><span class="line">cert-to-efi-sig-list -g $(<span class="built_in">cat</span> ms-guid) MSdbUDSCA.crt MSdbUDSCA.esl</span><br></pre></td></tr></table></figure>

<p>在这里需要注意一下，在 ThinkPad 里面，第二次添加 KEK 时（加参数 <code>-a</code> ），会出现失败，我的解决方法是把那些 List 合并成一个 List 文件，即：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> KEK.esl MSKEK.esl &gt;realKEK.esl</span><br><span class="line"><span class="built_in">cat</span> db.esl MSdbWPCA.esl MSdbUDSCA.esl &gt;realDB.esl</span><br></pre></td></tr></table></figure>

<p>根据 efitools 的文档，这种 cat 操作是可以完成合并的。</p>
<h3 id="给-List-文件签名"><a href="#给-List-文件签名" class="headerlink" title="给 List 文件签名"></a>给 List 文件签名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sign-efi-sig-list -k PK.key -c PK.crt PK PK.esl PK.esl.signed</span><br><span class="line">sign-efi-sig-list -k PK.key -c PK.crt KEK realKEK.esl realKEK.esl.signed</span><br><span class="line">sign-efi-sig-list -k KEK.key -c KEK.crt db realDB.esl realDB.esl.signed</span><br></pre></td></tr></table></figure>

<p>上述中，平台拥有着的 Key 权限最高，可以对 PK 本身，和 KEK 签名，KEK 是建立操作系统和硬件平台之间的信任关系，它只用于对于 db 进行签名。</p>
<h3 id="给二进制的-EFI-文件签名"><a href="#给二进制的-EFI-文件签名" class="headerlink" title="给二进制的 EFI 文件签名"></a>给二进制的 EFI 文件签名</h3><p>这是密钥管理和签名的最后一步，我使用的 grub ，其他的比如 elilo 等等，同理。给 grub 的 EFI 文件签名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sbsign --key db.key --cert db.crt --output grubx64.efi.signed /boot/efi/EFI/slackware64/grub64.efi</span><br></pre></td></tr></table></figure>

<p>可以不用给内核 <code>vmlinuz</code> 签名，毕竟 <code>vmlinuz</code> 不是硬件平台的启动 EFI 文件，不过给内核签名也没什么影响，如果想给内核签名类似于给 grub 签名，用 私钥 <code>db.key</code> 及对应的公钥 <code>db.crt</code> 对其签名，这里用的 db 是那个自己创建的 db ，即没有合并微软 db 的那个，合并了微软 db 的是 <strong>realDB</strong> 。</p>
<h3 id="写入-efivars"><a href="#写入-efivars" class="headerlink" title="写入 efivars"></a>写入 efivars</h3><p>到这里是整个过程的最后一步，首先必须保证系统的 <em>efivarfs</em> 被正确挂载，<code>ls</code> 一下 <code>/sys/firmware/efi/efivars/</code> 是否存在文件，有的系统默认挂载 <em>efivarfs</em> ，有的则不是（后续步骤需要切换至 root 用户）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t efivarfs efivarfs /sys/firmware/efi/efivars/</span><br></pre></td></tr></table></figure>

<p>再把那三个签过名的 List 文件写入主板：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">efi-updatevar -f PK.esl.signed PK</span><br><span class="line">efi-updatevar -f realKEK.esl.signed KEK</span><br><span class="line">efi-updatevar -f realDB.esl.signed db</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考 <a href="http://www.linuxquestions.org/">LinuxQuestions</a> 上的解决方案，使用了在 <code>efi-updatevar</code> 添加 <code>-a</code> 参数来表示添加，但是在 ThinkPad 上多次实验第二次皆以 <code>Operation not permitted</code> 的错误而中断，所以，合并 EFI List 文件即只需添加一次，就全部都被加上，无需再用 <code>-a</code> 来添加。上述的问题很难判断是密钥链的逻辑问题，还是硬件的保护机制，不过用合并这种方法，在 Secure Boot 下，Windows 和 Linux 都可以正常启动，看来没问题。</p>
</blockquote>
<p>所有操作都完成后，可以运行 <code>efi-readvar</code> 来查看添加结果。只要 <em>efivarfs</em> 仍然被挂载，即使在非 root 用户也可以查看。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://docs.slackware.com/howtos:security:enabling_secure_boot">docs.slackware.com</a></p>
<p><a href="http://www.linuxquestions.org/questions/slackware-14/slackware64-14-1-uefi-booting-with-secure-boot-enabled-4175532990">linuxquesions.org</a></p>
<p><a href="https://www.howtogeek.com/175641/how-to-boot-and-install-linux-on-a-uefi-pc-with-secure-boot">howtogeek.com</a></p>
<p><a href="http://wiki.archlinux.org/index.php/Secure_Boot">archlinux.org</a></p>
<p><a href="http://www.pcworld.com/article/2951559/operating-systems/how-to-install-linux-on-a-pc-with-secure-boot-enabled.html">pcworld.com</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>uefi</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Linux的coredump机制快速定位程序BUG</title>
    <url>/2019/11/12/linuxcoredumptofindbug/</url>
    <content><![CDATA[<h1 id="什么是coredump？"><a href="#什么是coredump？" class="headerlink" title="什么是coredump？"></a>什么是coredump？</h1><p><strong>Coredump</strong>是继承于UNIX系统的机制，它用于保存程序出错而崩溃时的栈，内存，PID，UID，GID，时间等等信息的快照，通常用于程序诊断和调试，<strong>Coredump</strong>的信息在计算机中一般保存三天左右（依系统设定而定），如果出错的程序BUG不及时查找，超过三天系统会吧这些<strong>Coredump</strong>删除。</p>
<span id="more"></span>

<h1 id="需要些什么工具？"><a href="#需要些什么工具？" class="headerlink" title="需要些什么工具？"></a>需要些什么工具？</h1><p>一般来说，只需要objdump和gdb即可，诊断时源代码以原始为佳（core dumped时的未修改的代码）。</p>
<h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><p>下面是我展示的一个出错事例，供参考观摩。</p>
<h2 id="程序崩溃了"><a href="#程序崩溃了" class="headerlink" title="程序崩溃了"></a>程序崩溃了</h2><p>这个程序运行时，一点问题也没有，就是退出时有小概率的情况出现崩溃，这种最让人头疼，像这种隐蔽BUG，很多情形不会触发它，却在某个特殊条件下，它突然就发生了。总结为两难：</p>
<ul>
<li>难确定（是否发生）</li>
<li>难定位</li>
</ul>
<p>见下图：</p>
<p><img src="/2019/11/12/linuxcoredumptofindbug/crashed.png" alt="pic1"></p>
<h2 id="尝试用coredumpctl工具直接调试"><a href="#尝试用coredumpctl工具直接调试" class="headerlink" title="尝试用coredumpctl工具直接调试"></a>尝试用coredumpctl工具直接调试</h2><p><em>coredumpctl</em>是systemd的工具之一，只要用的是这个系统服务的，应该都有，此工具使用非常简单，可以命令输入以获帮助：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">coredumpctl --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>
<p>或者，也可以查看它的man文档。</p>
<p>好了，言归正传，尝试输入命令以调试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">coredumpctl debug xxxx</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的xxxx是程序文件名，关于该程序名，可以用<code>coredumpctl list</code>查看到</p>
</blockquote>
<p>出现如下图的结果：</p>
<p><img src="/2019/11/12/linuxcoredumptofindbug/info.png" alt="pic2"></p>
<p>这种情况就比较复杂了，可以看见<code>0x00007f77be94cf25 in ?? ()</code>这句，<strong>Coredump</strong>也不能在源代码确定具体出错的位置了，作为比较，我展示另一个例子：</p>
<p><img src="/2019/11/12/linuxcoredumptofindbug/info2.png" alt="pic3"></p>
<p>上图这个例子出错代码立马被<strong>Coredump</strong>断定出来，很显然执行这句代码时崩溃的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*a = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这句是我故意改错用于比较的，源代码是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">input</span><span class="params">(string&amp; filename, ...)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">  <span class="type">int</span>* a = <span class="number">0</span>;</span><br><span class="line">  *a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，我们继续前面的<code>0x00007f77be94cf25 in ?? ()</code>这句，我们不能像前面这个立马断定，那该怎么办呢？</p>
<h2 id="用coredumctl-info查看栈信息"><a href="#用coredumctl-info查看栈信息" class="headerlink" title="用coredumctl info查看栈信息"></a>用<code>coredumctl info</code>查看栈信息</h2><p>下面两张图展示了这个崩溃程序的栈信息。</p>
<p>图一：</p>
<p><img src="/2019/11/12/linuxcoredumptofindbug/stack.png" alt="pic4"></p>
<p>图二：<br><img src="/2019/11/12/linuxcoredumptofindbug/stack2.png" alt="pic5"></p>
<p>因为输出信息较宽，被我分成了两张图，注意图二中栈的调用列表，下面我们接着反汇编原始程序文件。</p>
<h2 id="反汇编程序文件"><a href="#反汇编程序文件" class="headerlink" title="反汇编程序文件"></a>反汇编程序文件</h2><p>反汇编原始崩溃程序文件时，不要忘记加<code>--source</code>参数，不然全是汇编代码查找效率就不是很高，即输入命令带反汇编：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">objdump --<span class="built_in">source</span> -d xxxx | less</span><br></pre></td></tr></table></figure>

<p>图片展示：</p>
<p><img src="/2019/11/12/linuxcoredumptofindbug/disasm.png" alt="pic6"></p>
<blockquote>
<p>同样，xxxx为程序文件名</p>
</blockquote>
<p>这时，我们可以在<code>less</code>中依次查找各个栈地址（见图二所述），转到那个从<code>libc</code>刚出来，在程序文件最先出错位置，即：<code>0x42ce8</code>的文件位置，错误立马被锁定位置（可以依次查找栈上面的地址，顺藤摸瓜，可以断定那是在给<code>list</code>进行<code>clear</code>操作），原来是C++的类析构函数在析构一个<code>list</code>时出的错误，继而判定这个错误实际上是个多线程引起的错误，因为程序中还有一个子线程也在释放操作，是主线程和子线程同时释放引起，对于释放资源，主&#x2F;子线程没有加同步，从而导致时而正常，时而出错，加上一个最简单的同步机制，问题解决。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>debug</tag>
        <tag>coredump</tag>
        <tag>gdb</tag>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub的OAuth App的使用</title>
    <url>/2020/04/15/githuboauthappintro/</url>
    <content><![CDATA[<p>Github的App有两种，一种是普通的App，一般用以制作自动化机器人，另一种是利用用户登录的App，它可以操作登录用户的Github里面的API定义的操作，包括：用户信息获取，仓库信息修改，用户信息修改，等等。</p>
<h1 id="OAuth2的定义"><a href="#OAuth2的定义" class="headerlink" title="OAuth2的定义"></a>OAuth2的定义</h1><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0 是 OAuth 协议的延续版本，但不向后兼容 OAuth 1.0，即完全废止了 OAuth1.0。</p>
<span id="more"></span>

<h1 id="Github-OAuth-App"><a href="#Github-OAuth-App" class="headerlink" title="Github OAuth App"></a>Github OAuth App</h1><p>通过 OAuth2 协议可以让外部应用不用输入用户密码的情况下获取 GitHub 帐号的隐私信息，在 OAuth App 下的应用使用 GitHub 作为唯一标识。比起传统的简单认证方式来说，这种方式的认证具有更大的优势，因为对于token来说，它限制了数据类型，同时token也可以被用户随时撤销。</p>
<p>一个 OAuth App 运行起来就像一个已认证的用户，OAuth App 适合创建复杂的流程，而 OAuth App 通常是被部署到某个站点下面，在认证中会重定向到这个站点并附加一些参数，用于验证流程进行一些复杂的操作。</p>
<p>关于 Github OAuth App 的更多介绍可以查看<a href="https://docs.github.com/en/developers/apps/getting-started-with-apps/about-apps">这里</a>。</p>
<h1 id="Github上创建-OAuth-App"><a href="#Github上创建-OAuth-App" class="headerlink" title="Github上创建 OAuth App"></a>Github上创建 OAuth App</h1><p>创建 Github App 很简单，只需要等陆 Github，在设置里面进行，它允许创建 Github App 和 Github OAuth App，这里我们创建的是 Github OAuth App。</p>
<h2 id="登陆个人设置页面创建-App"><a href="#登陆个人设置页面创建-App" class="headerlink" title="登陆个人设置页面创建 App"></a>登陆个人设置页面创建 App</h2><p>在个人设置的左侧的导航栏的下方，有一个 <em>Developer settings</em> 的选项。</p>
<p><img src="/2020/04/15/githuboauthappintro/gh_prof.png" alt="settings"></p>
<p>在下一步中，我们创建了一个 OAuth App，并给它起名  <em>blogchat</em>。</p>
<p><img src="/2020/04/15/githuboauthappintro/gh_oa_app.png" alt="oa_app"></p>
<p>创建完 OAuth App 后，我们可以查看它的一些必要信息，比如：<em>Client ID</em> ，<em>Client secrets</em>，等等。</p>
<p>还可以在其中对 App 进行一些信息的修改，例如：logo图片。</p>
<p><img src="/2020/04/15/githuboauthappintro/gh_oa_app_cb1.png" alt="oa_app_cb1"></p>
<p>在 App 的设置页面里面有很多的项目设定，其中有两项比较重要的设定，一个是 App 的主页的 URL，还有一个是认证的重定向回调 URL。</p>
<p><img src="/2020/04/15/githuboauthappintro/gh_oa_app_cb2.png" alt="oa_app_cb2"></p>
<blockquote>
<p>重定向回调URL用于在认证的时候传入 <em>code</em>，<em>code</em> 是用于后续的向 Github 获取 <em>access_token</em> 而需要的</p>
</blockquote>
<p>在个人设置里面，对于 OAuth App 的设置到这里基本完成了，我们需要使用工具对 App 进行测试调通，如果可行的话，那么就说明我们的 App 是没有问题的，进而才可以进行后续的开发。</p>
<h2 id="使用-Postman-进行调通测试"><a href="#使用-Postman-进行调通测试" class="headerlink" title="使用 Postman 进行调通测试"></a>使用 Postman 进行调通测试</h2><p><img src="/2020/04/15/githuboauthappintro/pm1.png" alt="pm1"></p>
<p><img src="/2020/04/15/githuboauthappintro/pm2.png" alt="pm2"></p>
<p><img src="/2020/04/15/githuboauthappintro/pm3.png" alt="pm3"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>oauth</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux环境搭建中文LaTeX排版系统</title>
    <url>/2016/05/03/linuxlatex/</url>
    <content><![CDATA[<h2 id="TeX系统简介"><a href="#TeX系统简介" class="headerlink" title="TeX系统简介"></a>TeX系统简介</h2><p><strong>TeX</strong>系统最早由Stanford大学教授Donald E. Kunth制成的计算机排版软件系统，大家对他的《The Art of Computer Programming》应该不会陌生。</p>
<p>实际上，TeX的制成正是由于上述的书出版样本，令他不满意，所以激发了他创制了TeX排版系统。正所谓：一个确定性的需求比十所大学更能把握前进的方向。</p>
<p>大家可能经常以据如MS Word等这类简单排版的所见即所得的软件，或者在Linux中以LibreOffice中的Word这样的软件，来完成文字排版等操作，但是对于论文，书籍这样的文档，和TeX相比，MS Word这些软件就成了小儿科了。</p>
<span id="more"></span>

<p>说了这么多，今天的主题可是在Linux中搭建TeX系统，所以我就不废话了，如有疑惑，可以自己百度。</p>
<p>首先需要准备如下软件包或压缩包：</p>
<ul>
<li>texlive 或 tetex</li>
<li>CJK</li>
<li>字体，比如：nsung-tl,nkai-tl <em>（后面的tl应该表示texlive）</em></li>
</ul>
<p>下面逐个简单介绍各个包的功能和作用。</p>
<h3 id="1-texlive或tetex"><a href="#1-texlive或tetex" class="headerlink" title="1. texlive或tetex"></a>1. texlive或tetex</h3><p>这个包是整个排版系统的主要部分，它是排版系统的核心，texlive和tetex是两个发行版，但是它们实现功能基本相同，大同小异，只要有其中一个即可，下文以texlive为例，当然还有很多实现TeX系统的其他软件。</p>
<p>上述所述的texlive，虽然从理论上说，TeX已经可以完成排版，但是它只包含基本命令，使用起来会非常麻烦，很繁琐，要写更多的代码，这就类似于：在Windows环境里，用纯C写个GUI程序与用MFC写个GUI程序相比较，或者在Linux环境里，用纯C调用xlib的X Windows的API来写GUI程序与调用gtk+或qt(用C++)来写GUI程序。</p>
<p>LaTex同TeX一样，也是texlive的一个组件，Latex主要特色是其自动编号，包括章，节，段落，公式，图表等，这给排版工作带来极大的方便。</p>
<h3 id="2-CJK"><a href="#2-CJK" class="headerlink" title="2. CJK"></a>2. CJK</h3><p>原始的LaTex版本是不支持中文这些文字的，它只支持英文，即ASCII字符中小于0x80的字符。为了让LaTex能够支持中文，需要为LaTeX系统添加宏，使得其可以处理中文，而CJK，除了可以处理中文，还可处理日文，韩文，CJK意为Chinese，Japanese，Korean。</p>
<h3 id="3-字体"><a href="#3-字体" class="headerlink" title="3. 字体"></a>3. 字体</h3><p>仅仅安装了CJK宏包，仍然不能输出中文（编译.tex文件时会输出找不到字体的错误），这些字体中的汉字的标点符号会被当作汉字字体来处理的，不会影响到任何汉字标点符号的表示。字体同宏包一样，以压缩包形式存放。</p>
<h2 id="具体操作步骤"><a href="#具体操作步骤" class="headerlink" title="具体操作步骤"></a>具体操作步骤</h2><p>当以上软件包或压缩包都下载好后，首先，安装texlive，使系统具备TeX系统基础环境，如果是首次安装texlive，需要在安装前先安装一个install-tl-unx的包，这个包包含一些Perl脚本，用来设置在安装texlive之前的基本环境条件。</p>
<p>基本的TeX环境制好后，我们需要的LaTeX便就有了，必须需要它。LaTex也可理解为是TeX的拓展，使得TeX系统使用起来更加简单，方便。</p>
<p>把texlive软件安装好后，就是安装CJK宏包了，这是个压缩包，把它解压缩后，依据里面的texmf相对目录，在找到系统中的texmf系统的相对目录，把压缩包解开后的文件一一对应地复制到系统的texmf相对目录下的对应位置。这个texmf系统目录在不同的Linux发行版可能存在差别，我的texmf目录在<code>/usr/share/texmf</code>，还有的系统把它放到<code>/opt/texlive/texmf</code>，甚至<code>/usr/local/share/texmf</code>。</p>
<p>CJK宏包复制完毕过后，用texhash命令更新一下，这样刚才复制过去的宏包就可以被TeX系统找到了。<em>（在用texhash时，CJK下的目录及文件会被添加到ls-R的索引文件中）</em></p>
<p>到这里，基本快大功告成了。但是，没有字体还是不能输出中文字体的，字体文件的安装不同于上述的软件包或压缩包安装，它是直接安装在用户目录的，比如：<code>/home/xxx</code>，安装之后，用户目录会多出一个texmf文件夹，里面包含字体文件的相关数据，因此不要删除它，否则，字体就又没有了。</p>
<p>这里详述一下字体安装，解开字体的压缩包后，终端跳到解开后的压缩包的目录下，可以用<code>ls</code>命令看到有个<code>install.sh</code>和<code>uninstall.sh</code>。</p>
<p>若想安装该字体，只要输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./install.sh</span><br></pre></td></tr></table></figure>

<p>即可安装该字体，但不想要这个字体时，只要输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./uninstall.sh</span><br></pre></td></tr></table></figure>


<p>这些字体会安装在用户的<code>texmf</code>目录下，无需切换到root用户来安装，而且安装的字体也只对该用户有效。</p>
<blockquote>
<p>上面对于软件的安装没有详述，那些步骤都是常规软件安装步骤，在此略过，比如，rpm包用rpm来装，解决依赖项，如果是源代码编译安装，用<code>./configure</code>配置，生成Makefile，再<code>make</code>，再<code>make install</code>来安装，有的有许多选项，自己可以用<code>./configure --help</code>来参考一下，make那两个命令是最基本的，据如<code>make dist/test/pdf/...</code><em>（实际上，可以在Makefile中查看）</em>，普通非软件专业人不知也罢。</p>
</blockquote>
<h2 id="相关文件下载地址"><a href="#相关文件下载地址" class="headerlink" title="相关文件下载地址"></a>相关文件下载地址</h2><p><a href="http://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz">install-tl-unx</a><br><a href="ftp://tug.org/texlive/historic/2014/texlive-20140525-source.tar.xz">texlive</a><br><a href="http://ftp.gnu.org/pub/gnu/clisp/latest/clisp-2.49.tar.bz2">clisp</a><br><a href="http://sourceforge.net/projects/biblatex-biber/files/biblatex-biber/1.8/biblatex-biber.tar.gz">biblatex</a><br><a href="http://cjk.ffii.org/">CJK</a><br><a href="ftp://cle.linux.org.tw/pub2/tex/cjk/fonts/">字体文件</a></p>
<p><em>注：另外在tug.org站点(TeX User Group)上有很多有用的东西，自己在上面找一下</em></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>下面我写的一个代码实验：</p>
<pre><code>\documentclass[10pt]&#123;article&#125;
\usepackage&#123;CJK&#125;
\begin&#123;document&#125;
\begin&#123;CJK&#125;&#123;UTF8&#125;&#123;nsung&#125;
这是一个测试 
\section&#123;章标题&#125;
这是章的介绍
\subsection&#123;节的标题&#125;
这是节的介绍
\subsubsection&#123;子节的标题&#125;
这是子节的介绍 \\
数学公式的测试：\\
\Huge&#123;$y=2^x+\frac&#123;4&#125;&#123;6^z&#125;$&#125;
\footnote&#123;这仍然是个测试，一个脚注&#125;
\end&#123;CJK&#125;
\end&#123;document&#125;
</code></pre>
<p>实验打印出的.dvi文件：</p>
<p><img src="/2016/05/03/linuxlatex/dvi.png" alt="dvi"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>latex</tag>
      </tags>
  </entry>
  <entry>
    <title>JNI函数调用之线程安全问题</title>
    <url>/2021/11/29/jnithreadsafe/</url>
    <content><![CDATA[<h1 id="JNI-开发是什么"><a href="#JNI-开发是什么" class="headerlink" title="JNI 开发是什么"></a>JNI 开发是什么</h1><p>因本人以前工作中做过此类工作，再加上老同事的疑问，所以，今天抽出时间来探讨一下JNI的开发问题和特定细节（调用的线程安全问题），其实这种JNI层调用和任何其他语言调用C&#x2F;C++层结构都差不多，比如说CGO，其涉及到Golang和C&#x2F;C++层的调用，很多方面都存在类似之处。</p>
<p>JNI开发是使用Java提供的本地化接口，比如C&#x2F;C++（也可以是其他语言），允许Java虚拟机里面的已经编译的代码和外界的本地化代码进行交互。</p>
<span id="more"></span>

<blockquote>
<p>因为Java是推崇平台可移植性的，本地化代码看起来破坏了可移植性，但是很多时候却是不可避免的，因为很多时候Java是无法实现一些比较底层功能的。</p>
</blockquote>
<h1 id="JNI开发需要哪些工具"><a href="#JNI开发需要哪些工具" class="headerlink" title="JNI开发需要哪些工具"></a>JNI开发需要哪些工具</h1><p>在我的机器里面是安装的OpenJDK11和GCC11，运行平台是Linux环境，为了提高编码效率，我使用的是VSCode，外加Java插件，CMake插件和C++插件。</p>
<p>这里列举一下工具链：</p>
<ul>
<li>OpenJDK 11</li>
<li>GCC 11</li>
<li>CMake 3.21</li>
<li>VSCode 最新版</li>
</ul>
<p>截图：</p>
<p><img src="/2021/11/29/jnithreadsafe/devenv.png" alt="vscode"></p>
<blockquote>
<p>关于OpenJDK为何找不到javah，可以参考<a href="http://openjdk.java.net/jeps/313">这里</a>，意思就是javah已经被移除了，现在可以通过javac来完成同样的操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">javac -cp . -h abc MyCls.java</span><br></pre></td></tr></table></figure>

<p>以上假设在当前目录的MyCls.java存在本地调用，它会在当前目录下创建一个abc目录，并且写入C++层的JNI调用头文件，你只需要在写一个和之对应的C++源代码即可。</p>
</blockquote>
<h1 id="术语解释"><a href="#术语解释" class="headerlink" title="术语解释"></a>术语解释</h1><p>其实<strong>线程安全</strong>是什么意思都可以通过搜索找到，也许你已经知道什么意思，不过这里不妨碍我再叙述一遍：</p>
<p>线程安全是指某个函数在多线程的环境下被多次调用时，能够使得多线程的每个调用者都可以得到自己想要的正确结果。</p>
<h1 id="主要因素"><a href="#主要因素" class="headerlink" title="主要因素"></a>主要因素</h1><p>产生线程安全问题的原因是因为<strong>函数调用需要对公共变量进行修改</strong></p>
<p>这会涉及到四种情形：</p>
<ul>
<li>静态Java本地调用改C++层的公共数据</li>
<li>静态Java本地调用改Java层的公共数据</li>
<li>动态Java本地调用改C++层的公共数据</li>
<li>动态Java本地调用改Java层的公共数据</li>
</ul>
<p>所以说只要涉及到公共数据都会产生线程安全的问题。</p>
<blockquote>
<p>至于什么是静态&#x2F;动态Java本地调用？区别就是对应本地调用是否被static修饰，修饰者属于类的调用，否则属于被申请的对象的调用，与之分别对应静态&#x2F;动态调用。</p>
<p>还有C++&#x2F;Java层公共数据是什么？C++层的公共数据就是C++里面全局可以访问的变量，而这里的Java层公共变量指的是用C++访问&#x2F;修改在Java类或者Java对象中的公共变量。</p>
</blockquote>
<h1 id="实例操作"><a href="#实例操作" class="headerlink" title="实例操作"></a>实例操作</h1><p>以下我写了一个demo用于阐述JNI调用的线程安全的问题。</p>
<h2 id="Java部分"><a href="#Java部分" class="headerlink" title="Java部分"></a>Java部分</h2><p>java部分的代码写得很简单，声明了几个本地JNI接口，并在main中调用之：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCls</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (loadLibrary()) &#123;</span><br><span class="line">      sayHello();</span><br><span class="line"></span><br><span class="line">      <span class="type">ConSt</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConSt</span>();</span><br><span class="line"></span><br><span class="line">      threadSafe(st); <span class="comment">// 只要传进的st唯一即可达到线程安全的要求</span></span><br><span class="line"></span><br><span class="line">      System.out.println(mySafeInt);</span><br><span class="line">      System.out.println(st.mInt);</span><br><span class="line"></span><br><span class="line">      System.out.printf(<span class="string">&quot;unsafe int:%d\n&quot;</span>, threadUnsafe());</span><br><span class="line"></span><br><span class="line">      <span class="type">MyCls</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCls</span>();</span><br><span class="line">      obj.threadUnsafe2();</span><br><span class="line">      System.out.printf(<span class="string">&quot;unsafe int:%d\n&quot;</span>, obj.myUnsafeInt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载c动态库</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">loadLibrary</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      System.loadLibrary(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(SecurityException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(UnsatisfiedLinkError e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="variable">mySafeInt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">myUnsafeInt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本地化接口</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">threadSafe</span><span class="params">(ConSt st)</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">threadUnsafe</span><span class="params">()</span>; <span class="comment">// 使用了C++层的公共变量，且没有加锁机制</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">threadUnsafe2</span><span class="params">()</span>; <span class="comment">// 使用了Java层的公共变量，且没有加锁机制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的主体部分就是这三个本地调用的使用，<code>threadSafe()</code>实际上可以拆开成两个函数的，注意下面的C++部分的代码，为了省事，我把写在一块了。</p>
<p><code>threadSafe()</code>是线程安全的在任意调用次数后，都会返回正确的结果，而下面的<code>threadUnsafe()</code>和<code>threadUnsafe2()</code>则不是线程安全的，在很多线程执行时会得到混乱的结果。</p>
<h2 id="C-x2F-C-部分"><a href="#C-x2F-C-部分" class="headerlink" title="C&#x2F;C++部分"></a>C&#x2F;C++部分</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::mutex mu_thread_safe;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     MyCls</span></span><br><span class="line"><span class="comment"> * Method:    threadSafe</span></span><br><span class="line"><span class="comment"> * Signature: (LConSt;)V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_MyCls_threadSafe</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *env, jclass clz, jobject cons_st)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// -- 1 -- 使用C++的互斥锁来阻塞操作，这样可以保证线程安全</span></span><br><span class="line">    jfieldID _fieldId = env-&gt;<span class="built_in">GetStaticFieldID</span>(clz, <span class="string">&quot;mySafeInt&quot;</span>, <span class="string">&quot;J&quot;</span>); <span class="comment">// 获得类中的静态成员变量</span></span><br><span class="line"></span><br><span class="line">    mu_thread_safe.<span class="built_in">lock</span>();</span><br><span class="line">    env-&gt;<span class="built_in">SetStaticLongField</span>(clz, _fieldId, <span class="number">12345</span>); <span class="comment">// 这里通过互斥锁来达到线程安全</span></span><br><span class="line">    mu_thread_safe.<span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- 2 -- 通过形式参数形式传递变量进入，只要保证形参不同即可线程安全</span></span><br><span class="line">    jclass _cs_clz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;ConSt&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(_cs_clz != <span class="literal">nullptr</span>);</span><br><span class="line">    jfieldID _cs_fieldId = env-&gt;<span class="built_in">GetFieldID</span>(_cs_clz, <span class="string">&quot;mInt&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">    env-&gt;<span class="built_in">SetLongField</span>(cons_st, _cs_fieldId, <span class="number">12345</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     MyCls</span></span><br><span class="line"><span class="comment"> * Method:    threadUnsafe</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT jint JNICALL <span class="title">Java_MyCls_threadUnsafe</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *, jclass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// -- 3 -- 在C++层存储公共数据，并进行改写不加锁，不是线程安全的</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> _unsafe_int = <span class="number">0</span>;</span><br><span class="line">    _unsafe_int++; <span class="comment">// 这里不加任何互斥锁机制</span></span><br><span class="line">    <span class="keyword">return</span> _unsafe_int;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     MyCls</span></span><br><span class="line"><span class="comment"> * Method:    threadUnsafe2</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">JNIEXPORT <span class="type">void</span> JNICALL <span class="title">Java_MyCls_threadUnsafe2</span></span></span><br><span class="line"><span class="function">  <span class="params">(JNIEnv *env, jobject obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// -- 4 -- 或者C++层操作的公共数据是在java层的变量，亦不加锁，也不是线程安全的</span></span><br><span class="line">    jclass _clz = env-&gt;<span class="built_in">FindClass</span>(<span class="string">&quot;MyCls&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(_clz != <span class="literal">nullptr</span>);</span><br><span class="line">    jfieldID fieldId = env-&gt;<span class="built_in">GetFieldID</span>(_clz, <span class="string">&quot;myUnsafeInt&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">    <span class="built_in">assert</span>(fieldId != <span class="literal">nullptr</span>);</span><br><span class="line">    jlong myUnsafeInt = env-&gt;<span class="built_in">GetLongField</span>(obj, fieldId) + <span class="number">1</span>;</span><br><span class="line">    env-&gt;<span class="built_in">SetLongField</span>(obj, fieldId, myUnsafeInt);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>以上四处标识中，第一个函数<code>threadSafe()</code>处，通过C++的互斥锁来对公共变量修改是一种方案，但是它对于大量并发的操作而言，效率低下，因为它是互斥线性化的，所以一般推荐第二处标识的方案，它让用户传递一个自定义的类型对象，C++层就对这个对象进行修改，调用者负责它传递的对象唯一，那么对于大量的并发操作而言，得到的结果也必然是正确的。</p>
<p>对于第三处和第四处是线程安全要求下不能满足的反例，第三处是没有对C++层公共数据添加加锁机制，而第四处是和第三处类似的，不同之处在于它的修改是在Java代码里的变量。</p>
<blockquote>
<p>关于GetFiledID()的第四个参数<code>sign</code>是什么意思？它是Java代码对这个函数的表述，可以参照下面这张图（还是从别人的那里截图过来的），更多详情可以查找官方文档。</p>
<p><img src="/2021/11/29/jnithreadsafe/sign.png" alt="sign"></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>保证线程安全的要求是对<strong>公共资源</strong>恰当使用，最好不要用公共资源，让调用者传递参数值作为修改变量来使用，效果最佳。</p>
<p>链接：<br>demo<a href="src.tar.gz">下载</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>jni</tag>
        <tag>java</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统启动流程</title>
    <url>/2018/06/24/linuxstartup/</url>
    <content><![CDATA[<h1 id="内核加载"><a href="#内核加载" class="headerlink" title="内核加载"></a>内核加载</h1><p>在<a href="/2018/06/16/systemstartup">上篇博文</a>里面我说明过计算机如何从远古到近代的启动流程，然后，走到操作系统一层的时候就没有深入阐述了，在这篇博文我将以Linux系统为例来叙述操作系统是如何启动的。</p>
<p>通常在系统<code>/boot</code>目录下放着内核文件，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">initramfs-linux.img</span><br><span class="line">vmlinuz-linux</span><br></pre></td></tr></table></figure>

<p>GRUB（或者LILO）加载内核的时候，会把<code>vmlinuz-linux</code>映射到内存并会把它的一个初始根目录的文件镜像（<code>initramfs-linux.img</code>）作为文件系统加载到内存，系统会从这个迷你的初始化文件系统来启动，在这个迷你的文件系统里面又会加载真正的磁盘文件系统，带有这种<code>initramfs</code>的都是这种加载流程，但是，对于那种没有<code>initramfs</code>的（例如：Slackware发行版本），它是加载内核后，内核直接从磁盘加载文件系统，这种区分跟内核配置有关。</p>
<span id="more"></span>

<blockquote>
<p>内核初始化进行哪些操作？</p>
<p>内核初始操作属于操作系统内核部分的知识，一般来说，主体包括以下（还有很多细节可以参看Linux内核方面的书籍）：</p>
<ul>
<li>系统处于实模式需要切换到保护模式，所以需要设置GDT,LDT，设置平坦模式的内存寻址，在GDT,LDT寄存器里面，可以设置内存保护位，大小等等信息</li>
<li>原始的系统没有任何可以使用库，但是不要忘记BIOS提供的中断调用，还有BIOS设定好的各种IO端口，通过它们我们就可以获取和设置计算机信息，从而达到控制计算机，我们可以把它们封装出函数调用，为了兼容历史，我们需要保留部分低位中断，这样把这些函数写成中断调用（即设置IDT中断调用表），按UNIX规范提供一套SYSCALL</li>
<li>实际上，我们的计算机内存已经非常大了，所以我们往往需要一种快速定位寻址的机制，在没有硬件支持的时候用软件算法可以达到相似的效果，但是在Intel平台上，提供了Paging机制，利用这种机制我们只需要设置PDE表格（即页表），那么CPU就会自动就加载寻址，这就达到硬件加速的效果</li>
<li>但我们设置完了进程相关设置，内存相关设置后，接下来的就是文件系统，文件系统是操作系统的基本要素（目前来说是这样的），内核会按着磁盘上数据格式把文件信息读取，并在内存中构建一个文件存留信息的数据结构（一般不一定是位视图这种表格，多数情况要复杂一些，也就是多层次的可以拓展的树状构型）</li>
<li>外设是最复杂的部分，外设需要各种初始化，初始化过的外设才可以正常使用，一般这部分也叫设备驱动流程（这部分也可以延后加载，进行初始化）</li>
</ul>
</blockquote>
<h1 id="初始化程序加载"><a href="#初始化程序加载" class="headerlink" title="初始化程序加载"></a>初始化程序加载</h1><p>当内核加载流程全部完成后（只要没有发生出错都会加载完成），内核会启动系统的第一个进程，它就是著名的<code>init</code>进程（pid为1），而现在随着开源社区的发展，出现过好多版本的init程序了，最老也是最稳定的是sysvinit，除此之外还有Upstart之流，不过systemd还是更受青睐，它也是目前互动最多的init初始化开源项目。</p>
<p>Systemd和sysvinit有很大的区别，所以这里分别介绍两者：</p>
<blockquote>
<p>Upstart是一个基于事件触发的异步初始化方案，和Sysvinit高度兼容，但这里不作讨论，相关介绍可以查阅其他介绍Upstart的博客或技术Wiki等等</p>
</blockquote>
<h2 id="Sysvinit的流程"><a href="#Sysvinit的流程" class="headerlink" title="Sysvinit的流程"></a>Sysvinit的流程</h2><p>Sysvinit的启动可以把它看作两个部分：初始化，服务加载。</p>
<h3 id="初始化部分"><a href="#初始化部分" class="headerlink" title="初始化部分"></a>初始化部分</h3><p>在Systvinit中，它会读取系统中的 <code>/etc/inittab</code>信息，从而来确定系统下一步的启动步骤。为了判断下一步步骤，系统有一个概念，叫做“运行级别”（runlevel），意思就是要确定以何种场景来启动系统，一般而言，Linux有如下7种运行级别：</p>
<ul>
<li>0 - 关机模式</li>
<li>1 - 单用户模式</li>
<li>2 - 多用户模式</li>
<li>3 - 多用户网络模式</li>
<li>4 - 自定义模式</li>
<li>5 - 完全模式</li>
<li>6 - 重启模式</li>
</ul>
<blockquote>
<p>Runlevel的定义可以参考<a href="https://en.wikipedia.org/wiki/Runlevel">维基百科的介绍</a></p>
</blockquote>
<p>针对不同的Linux发行版本，上述的定义值不一定相同。</p>
<p>当init程序读取了<code>/etc/inittab</code>中的信息时，该配置文件里面存放了各种运行级别所要进行的操作，假设有如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">These are the default runlevels <span class="keyword">in</span> Slackware:</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  0 = halt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  1 = single user mode</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  2 = unused (but configured the same as runlevel 3)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  3 = multiuser mode (default Slackware runlevel)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  4 = X11 with KDM/GDM/XDM (session managers)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  5 = unused (but configured the same as runlevel 3)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  6 = reboot</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Default runlevel. (Do not <span class="built_in">set</span> to 0 or 6)</span></span><br><span class="line">id:3:initdefault:</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">System initialization (runs when system boots).</span></span><br><span class="line">si:S:sysinit:/etc/rc.d/rc.S</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Script to run when going single user (runlevel 1).</span></span><br><span class="line">su:1S:wait:/etc/rc.d/rc.K</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Script to run when going multi user.</span></span><br><span class="line">rc:2345:wait:/etc/rc.d/rc.M</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">What to <span class="keyword">do</span> at the <span class="string">&quot;Three Finger Salute&quot;</span>.</span></span><br><span class="line">ca::ctrlaltdel:/sbin/shutdown -t5 -r now</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Runlevel 0 halts the system.</span></span><br><span class="line">l0:0:wait:/etc/rc.d/rc.0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Runlevel 6 reboots the system.</span></span><br><span class="line">l6:6:wait:/etc/rc.d/rc.6</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">What to <span class="keyword">do</span> when power fails.</span></span><br><span class="line">pf::powerfail:/sbin/genpowerfail start</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">If power is back, cancel the running shutdown.</span></span><br><span class="line">pg::powerokwait:/sbin/genpowerfail stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">These are the standard console login getties <span class="keyword">in</span> multiuser mode:</span></span><br><span class="line">c1:12345:respawn:/sbin/agetty --noclear 38400 tty1 linux</span><br><span class="line">c2:12345:respawn:/sbin/agetty 38400 tty2 linux</span><br><span class="line">c3:12345:respawn:/sbin/agetty 38400 tty3 linux</span><br><span class="line">c4:12345:respawn:/sbin/agetty 38400 tty4 linux</span><br><span class="line">c5:12345:respawn:/sbin/agetty 38400 tty5 linux</span><br><span class="line">c6:12345:respawn:/sbin/agetty 38400 tty6 linux</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Local serial lines:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">s1:12345:respawn:/sbin/agetty -L ttyS0 9600 vt100</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">s2:12345:respawn:/sbin/agetty -L ttyS1 9600 vt100</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Dialup lines:</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">d1:12345:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS0 vt100</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">d2:12345:respawn:/sbin/agetty -mt60 38400,19200,9600,2400,1200 ttyS1 vt100</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Runlevel 4 also starts /etc/rc.d/rc.4 to run a display manager <span class="keyword">for</span> X.</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Display managers are preferred <span class="keyword">in</span> this order:  gdm, kdm, xdm</span></span><br><span class="line">x1:4:respawn:/etc/rc.d/rc.4</span><br></pre></td></tr></table></figure>

<p>每一行可以看作是一个函数。</p>
<p>这样以来，第一列对应单个函数的ID（2-4个字母数字组合，只要不重复即可），第二列对应函数Runlevel的值，第三列对应内部Runlevel操作入口（action），第四列是函数要执行的程序或者脚本。</p>
<blockquote>
<p>对于函数的操作入口（action）存在如下几种：initdefault, sysinit, boot, bootwait, wait, respawn</p>
</blockquote>
<p>例如，以这个函数举例来说：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure>

<p>当运行Runlevel为3时，就会执行initdefault的入口，它不需要执行脚本或程序，表示默认的Runlevel，其他的函数配置同理。</p>
<p>再看上面的inittab配置，如下这行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">si:S:sysinit:/etc/rc.d/rc.S</span><br></pre></td></tr></table></figure>

<p>它表示系统启动是就运行<code>/etc/rc.d/rc.S</code>脚本，在<code>/etc/rc.d/rc.S</code>脚本里面则包含：</p>
<ul>
<li>挂载<code>sysfs</code>文件目录节点</li>
<li>挂载<code>tmpfs</code>文件目录节点</li>
<li>挂载<code>proc</code>文件目录节点</li>
<li>挂载<code>cgroup</code>文件目录节点</li>
<li>启动其他的rc.XX脚本</li>
<li>加载需要的内核模块</li>
<li>检测文件系统</li>
<li>随机数设置</li>
<li>等等</li>
</ul>
<p>对于用多个Runlevel的函数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rc:2345:wait:/etc/rc.d/rc.M</span><br></pre></td></tr></table></figure>

<p>表示在<code>2345</code>这4个Runlevel下，都会执行<code>/etc/rc.d/rc.M</code>，并等待它执行完成。</p>
<p>init的配置非常的清晰明了，它的启动脚本可以在目录<code>/etc/rc.d</code>下查看。</p>
<p>系统就是这样加载rc.d下的初始化脚本，序列化地完成所有的init初始化流程。</p>
<h3 id="加载服务"><a href="#加载服务" class="headerlink" title="加载服务"></a>加载服务</h3><p>Sysvinit中对于服务的加载是通过<code>/etc/rc.d</code>下的初始化脚本来执行的，一般情况下，一个服务都编写一个服务管理的Shell脚本，它可以接受：<code>status</code>，<code>start</code>，<code>stop</code>，<code>restart</code>这样的参数，并把它放在<code>/etc/rc.d/init.d</code>目录下面。</p>
<p>例如，有如下服务（<code>/etc/rc.d/init.d/vbox-usb-service</code>）：</p>
<p>我们就可以执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/rc.d/init.d/vbox-usb-service status</span><br></pre></td></tr></table></figure>

<p>来查看此服务是否已经启动，但是一般情况下，系统会为了方便创建了一个软链接（如果系统没有创建该软链接，我们可以手动创建之）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d</span><br></pre></td></tr></table></figure>

<p>该软链接指向<code>/etc/rc.d/init.d</code>，因此，我们也可以这样重启服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/init.d/vbox-usb-service restart</span><br></pre></td></tr></table></figure>

<p>但是，这不是必须这样的组织方式，也可以把服务管理的脚本直接就放在<code>/etc/rc.d</code>目录下，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/rc.d/rc.httpd</span><br></pre></td></tr></table></figure>

<p>该脚本是用于Apache的httpd服务的管理脚本，执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/etc/rc.d/rc.httpd start</span><br></pre></td></tr></table></figure>

<p>即可完成httpd服务的启动。</p>
<blockquote>
<p>对于一些外部的第三方服务都是放在<code>/etc/rc.d/init.d</code>下面，这样这些脚本只要添加执行权限，就会被初始化脚本自动加载，而不用去更改初始化脚本；而在<code>/etc/rc.d</code>下的服务管理脚本则是Linux发行版本自带的服务，它已经在初始化脚本中做过判断设置，如果我们要把一个第三方的服务管理脚本放到<code>/etc/rc.d</code>下，就意味着我们必须要修改初始化脚本。</p>
</blockquote>
<h2 id="Systemd的流程"><a href="#Systemd的流程" class="headerlink" title="Systemd的流程"></a>Systemd的流程</h2><p>Systemd中，所有的都以单元组件的形式来加载，这些单元组件很多都可以并发执行，达到快速加载的目的，单元组件的前件和后件构成一套稳定的加载系统。</p>
<h3 id="初始化加载"><a href="#初始化加载" class="headerlink" title="初始化加载"></a>初始化加载</h3><blockquote>
<p>在以Systemd为init服务的Linux系统中，参看<code>man 7 bootup</code>，以了解更多有关Systemd的启动详情。</p>
</blockquote>
<h3 id="加载图示"><a href="#加载图示" class="headerlink" title="加载图示"></a>加载图示</h3><p><img src="/2018/06/24/linuxstartup/systemd.png" alt="systemd-graph"></p>
<p>由上图可见，在加载<code>sysinit</code>之前，可以加载很多的服务，而这些服务是互相独立无依赖的，因此可以并行地加载，当所有的服务都加载完后，<code>sysinit</code>服务就算加载成功，之后进行下面的服务加载，后面的加载逻辑以此类推。注意到，类似<code>rescue</code>这种是具有特殊用途的服务（这里的服务是用于系统崩溃后的拯救），还有一个独立依赖链，或者没有依赖的服务，被加载到目前的服务的情况，例如上图的<code>remote-fs</code>就是这种。</p>
<blockquote>
<p>上图绘制的systemd加载图比较粗糙，细节要复杂一些，有些一个单元的加载可能分好几个步骤来加载，有的可能细分更多的加载逻辑。</p>
</blockquote>
<h1 id="用户登录系统"><a href="#用户登录系统" class="headerlink" title="用户登录系统"></a>用户登录系统</h1><p>当系统必要的服务都启动后，会分为几种场景：</p>
<h2 id="Runlevel-3-登录"><a href="#Runlevel-3-登录" class="headerlink" title="Runlevel 3 登录"></a>Runlevel 3 登录</h2><p>在该模式下，用户自动进入ttyS1来登录系统，init会启动<code>/sbin/agetty</code>提示用户输入用户名和密码，getty和login判断用户合法就让用户进入系统，打开用户的Shell程序。</p>
<blockquote>
<p>上述配置，会产生6个用户可以同时登录。</p>
<p>此外，getty和login这种登录验证需要验证密码，通常是读取<code>/etc/passwd</code>下的保存设置来验证用户有效性。</p>
<p>（细节可以参考系统函数：<code>getpass</code>）</p>
</blockquote>
<h2 id="Runlevel-4-登录"><a href="#Runlevel-4-登录" class="headerlink" title="Runlevel 4 登录"></a>Runlevel 4 登录</h2><p>如果是多用户模式，会启动一个用于管理系统登录的服务（一般PolKit&#x2F;ConsoleKit最常见），这里以ConsoleKit举例来说，它允许用户在同一硬件设备登录的情况下，不用登出系统还可以再次登录，ConsoleKit以抽象化成会话的模型，从而实现这种登录机制。</p>
<p>在图形登录下，都会使用这种方式来登录系统。</p>
<blockquote>
<p>在ConsoleKit的登录验证下，也是通过读取<code>/etc/passwd</code>配置文件的信息来验证用户有效性的。</p>
<p>（对于如何验证的细节，可以参考一个系统提供的安全相关的函数：<code>crypt</code>）</p>
</blockquote>
<h1 id="打开用户SHELL-x2F-WDM程序"><a href="#打开用户SHELL-x2F-WDM程序" class="headerlink" title="打开用户SHELL&#x2F;WDM程序"></a>打开用户SHELL&#x2F;WDM程序</h1><p>当用户输入名称和密码通过验证后，init程序需要为用户执行一个Shell运行程序，以便使用户能够对系统来进行管理，Shell的种类很多，根据用户的爱好，可以自由选择一款适合的Shell。</p>
<blockquote>
<p>常见的Shell有：Bash, Csh, Ash, Tcsh, Zsh等等</p>
</blockquote>
<p>Shell被启动后，它就接管了用户的空间，用户可以通过它以命令方式来完成任何操作。</p>
<blockquote>
<p>Shell的启动会读取系统全局配置，再基于用户$HOME目录下的配置文件，读取自定义的配置。</p>
</blockquote>
<p>通常对于图形界面的登录有一些不同，图形界面的登录启动的不是Shell，而是一个XWindows的WDM，即一个窗口管理器，它接管用户空间，为用户初始化图形化设置，并展示图形界面。</p>
<blockquote>
<p>常见的 WDM有：GDM，SDDM，KDM等等</p>
</blockquote>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LZ77压缩算法</title>
    <url>/2018/03/31/lz77compalgo/</url>
    <content><![CDATA[<h1 id="LZ77算法简介"><a href="#LZ77算法简介" class="headerlink" title="LZ77算法简介"></a>LZ77算法简介</h1><p>LZ77算法是一种无损压缩算法，最早由两位以色列人于1977发表，它是一种典型的字典型压缩算法，目前几乎大多数的无损压缩算法都是基于这个LZ77算法，也就是在其基础上优化修改，此算法可以称得上是无损压缩算法界的鼻祖了。</p>
<span id="more"></span>

<blockquote>
<p>参考维基百科<a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">lz77</a></p>
</blockquote>
<h1 id="算法逻辑"><a href="#算法逻辑" class="headerlink" title="算法逻辑"></a>算法逻辑</h1><p>LZ77的算法核心就是一个滑动窗口，在滑动窗口里面搜索重复字节，并将匹配到的字节串用更短的字节串方式表示出来。</p>
<p>这里涉及到几个要素：</p>
<ul>
<li>滑动窗口缓冲区</li>
<li>滑窗的前部区域</li>
<li>滑窗的已编码区域</li>
</ul>
<h2 id="编码流程"><a href="#编码流程" class="headerlink" title="编码流程"></a>编码流程</h2><p>编码步骤：</p>
<ol>
<li>首先分配一块缓冲区域用来处理数据</li>
<li>初始的前部区域为空</li>
<li>初始的已编码区域也为空</li>
<li>加载的字节流到前部区域，是否最后一个字节，是则进行第8步，否则继续第5步</li>
<li>在已编码区域寻找匹配字节串，如果找到进行第6步，否则进行第7步</li>
<li>将匹配到的第一个字节的相对位置和长度，标记到已编码区域中，继续第4步</li>
<li>将前部区域的字节直接拷贝到已编码区域，继续第4步</li>
<li>编码结束</li>
</ol>
<p>编码图示：</p>
<p>当滑动窗口还没有处理数据时：</p>
<p><img src="/2018/03/31/lz77compalgo/stepprecomp.png" alt="stepprecomp"></p>
<p>当滑动窗口开始处理数据时：</p>
<p><img src="/2018/03/31/lz77compalgo/stepcomp.png" alt="stepcomp"></p>
<p>当滑动窗口正在处理数据时：</p>
<p><img src="/2018/03/31/lz77compalgo/stepcomping.png" alt="stepcomping"></p>
<p>当数据快要处理完时：</p>
<p><img src="/2018/03/31/lz77compalgo/stepcompfin.png" alt="stepcompfin"></p>
<p>整个过程如同字节流在这个滑动窗口的黑盒子里面流动过一样，然后，它被加工的数据是已经压缩的数据了。</p>
<blockquote>
<p>数据编码中，会涉及到如何标记数据，在lz77算法中是用2-3个字节来表示的，即：如果有两个自己是’\0’，则表示它是一个直译字节，是直接拷贝过来的字节，这两个’\0’后面的字节就是原始字节；否则，这两个字节是表示当前字节处应该填充的字节串应该在的相对位置和长度（你甚至可以为你自己的lz77编码器自定义数据标记方式）。</p>
</blockquote>
<h2 id="解码流程"><a href="#解码流程" class="headerlink" title="解码流程"></a>解码流程</h2><p>解码的过程是编码过程的逆过程。</p>
<p>解码步骤：</p>
<ol>
<li><p>字节流是否是最后字节，是则进行第5步，否则进行第2步</p>
</li>
<li><p>从字节流获取两个字节，如果是<code>\0x00\0x00</code>则进行第3步，否则进行第4步</p>
</li>
<li><p>将<code>\0x00\0x00</code>后面的一个字节复制到输出缓存区域，继续加载字节流，继续第1步</p>
</li>
<li><p>从两个字节的编码中得到在滑动窗口的相对偏移和内容长度，把偏移处的内容拷贝到当前输出缓存，继续第1步</p>
</li>
<li><p>解码结束</p>
</li>
</ol>
<blockquote>
<p>上面的输出缓存区域是指在字节处理位置处理过后的字节流存放的缓存区域就是输出缓存</p>
</blockquote>
<p>解码图示：</p>
<p>滑动窗口还没有输入数据的时候：</p>
<p><img src="/2018/03/31/lz77compalgo/steppreuncomp.png" alt="stepuncomp"></p>
<p>滑动窗口开始处理数据的时候：</p>
<p><img src="/2018/03/31/lz77compalgo/stepuncomp.png" alt="stepuncomp"></p>
<p>数据在滑动窗口中处理：</p>
<p><img src="/2018/03/31/lz77compalgo/stepuncomping.png" alt="stepuncomping"></p>
<p>数据快要处理完的时候：</p>
<p><img src="/2018/03/31/lz77compalgo/stepuncompfin.png" alt="stepuncompfin"></p>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h1><p>辅助函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">search_maxlen_p</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span>**  pt, \</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> <span class="type">char</span>* head, \</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> <span class="type">char</span>* tail, \</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> <span class="type">char</span>* end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* tmp = *pt;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> leng = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(tmp;tmp &gt;= head;tmp--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp[<span class="number">0</span>] == tail[<span class="number">0</span>])&#123;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span>;(i &lt; ((<span class="number">1</span> &lt;&lt; LENGTHBITS) - <span class="number">1</span>)) &amp;&amp; (&amp;tmp[i] &gt; head) &amp;&amp; (&amp;tmp[i] &lt; tail) &amp;&amp; (&amp;tail[i] &lt; end) &amp;&amp; (tmp[i] == tail[i]);i++);</span><br><span class="line">      <span class="keyword">if</span>(i &gt; leng)&#123;</span><br><span class="line">        leng = i;</span><br><span class="line">        *pt = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> leng;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lz77_encode</span><span class="params">(FILE* in,FILE* out)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* buf = <span class="number">0</span>,* head = <span class="number">0</span>,* tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(! in || ! out)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  get_filesize(in,size); <span class="comment">// get file size.</span></span><br><span class="line">  <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  buf = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(size* <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>)); <span class="comment">// allocate memory.</span></span><br><span class="line">  <span class="keyword">if</span>(! buf)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fread(buf,<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>),size,in) == size)&#123;</span><br><span class="line">    head = tail = buf;</span><br><span class="line">    fputc((size &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,out);</span><br><span class="line">    fputc((size &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>,out);</span><br><span class="line">    fputc((size &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0xff</span>,out);</span><br><span class="line">    fputc((size &gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0xff</span>,out);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123; <span class="comment">// loop block.</span></span><br><span class="line">      head = tail - WINDOWSIZE;</span><br><span class="line">      <span class="keyword">if</span>(buf  &gt; head)head = buf;</span><br><span class="line">      <span class="keyword">if</span>(tail &gt; buf + size - <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span>(tail &gt; head)&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* pt = tail - <span class="number">1</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> bytes = <span class="number">0</span>;</span><br><span class="line">        bytes = search_maxlen_p(&amp;pt,head,tail,buf + size);</span><br><span class="line">        <span class="comment">// search maximal matched bytes and position.</span></span><br><span class="line">        <span class="keyword">if</span>(bytes &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="type">unsigned</span> <span class="type">char</span> chars[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">          chars[<span class="number">0</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)(( (tail - pt) &gt;&gt; LENGTHBITS) &amp; <span class="number">0xff</span>);</span><br><span class="line">          chars[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">char</span>)((((tail - pt) &lt;&lt; LENGTHBITS) + bytes) &amp; <span class="number">0xff</span>);</span><br><span class="line">          fputc(chars[<span class="number">0</span>],out);</span><br><span class="line">          fputc(chars[<span class="number">1</span>],out);</span><br><span class="line">          <span class="comment">//fprintf(stderr,&quot;&#123;%d - %d&#125;&quot;,tail - pt,bytes);</span></span><br><span class="line">          tail += bytes;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          fputc(<span class="number">0</span>,out);</span><br><span class="line">          fputc(<span class="number">0</span>,out);</span><br><span class="line">          fputc(*tail,out);</span><br><span class="line">          tail++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fputc(<span class="number">0</span>,out);</span><br><span class="line">        fputc(<span class="number">0</span>,out);</span><br><span class="line">        fputc(*tail,out);</span><br><span class="line">        tail++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lz77_decode</span><span class="params">(FILE* in,FILE* out)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* nbuf = <span class="number">0</span>,* ori_buf = <span class="number">0</span>,* head = <span class="number">0</span>,* tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> ori_size = <span class="number">0</span>,nsize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(! in || ! out)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  get_filesize(in,nsize); <span class="comment">// get file size.</span></span><br><span class="line">  <span class="keyword">if</span>(nsize &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  ori_size  = (fgetc(in) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">  ori_size += (fgetc(in) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  ori_size += (fgetc(in) &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span>;</span><br><span class="line">  ori_size += (fgetc(in) &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(ori_size &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  nbuf = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(nsize* <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">  <span class="keyword">if</span>(! nbuf)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  ori_buf = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(ori_size* <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">  <span class="keyword">if</span>(ori_buf)&#123;</span><br><span class="line">    head = tail = ori_buf; <span class="comment">// store head and tail of slide-window.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fread(nbuf,<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>),nsize,in) == (nsize - <span class="number">4</span>))&#123;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span>* pt  = nbuf;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pt &gt;= (nbuf + nsize - <span class="number">4</span>))<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(! pt[<span class="number">0</span>] &amp;&amp; ! pt[<span class="number">1</span>] )&#123; <span class="comment">// \0\0\?</span></span><br><span class="line">          tail[<span class="number">0</span>] = pt[<span class="number">2</span>];</span><br><span class="line">          tail++;</span><br><span class="line">          pt += <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// \?\?</span></span><br><span class="line">          <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>,length = <span class="number">0</span>,i;</span><br><span class="line">          offset  =  pt[<span class="number">0</span>] &lt;&lt; LENGTHBITS;</span><br><span class="line">          offset += (pt[<span class="number">1</span>] &gt;&gt; LENGTHBITS) &amp; <span class="number">0x0f</span>;</span><br><span class="line">          length  =  pt[<span class="number">1</span>] &amp; <span class="number">0x0f</span>;</span><br><span class="line">          <span class="comment">//fprintf(stderr,&quot;&#123;%d - %d&#125;&quot;,offset,length);</span></span><br><span class="line">          <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">            tail[i] = ((<span class="type">unsigned</span> <span class="type">char</span>*)(tail - offset))[i];</span><br><span class="line">          &#125;</span><br><span class="line">          tail += length;</span><br><span class="line">          pt += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      fwrite(ori_buf,<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>),ori_size,out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ori_buf);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(nbuf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>在分析此算法压缩的数据效率如何时，可以看到和数据的内容有关，若重复率比较高，而且间隔距离短的内容，可以得到比较理想的压缩率，但是对于重复率低的内容就不一定能达到理想的压缩率，最差的情况就是，要压缩的内容刚刚好在滑动窗口大小的缓存都没有重复内容，那么压缩出来的数据不仅没有变小，而且增大到原来的3倍。</p>
<p>下图中的数据可以看到前面部分的非重复的数据就有许多的<code>&quot;\0x00\0x00&quot;</code>开头的直译复制过来的数据，这种数据过多就会导致压缩效率低下。</p>
<p><img src="/2018/03/31/lz77compalgo/hexdat.png" alt="hexdat"></p>
<p>一般来说，用LZ77算法压缩过的数据，为了抵消上面的劣势，可以将用LZ77压缩的数据再用哈夫曼编码再次编码，这样输出的数据压缩效率就高一些了。</p>
<p>链接：<a href="https://github.com/hchen90/lz77">Github上的代码</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>lz77</tag>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>LZSS压缩算法</title>
    <url>/2018/04/01/lzsscompalgo/</url>
    <content><![CDATA[<h1 id="LZSS算法简介"><a href="#LZSS算法简介" class="headerlink" title="LZSS算法简介"></a>LZSS算法简介</h1><p>LZSS算法是LZ77算法的改良版，由James A. Storer和Thomas Szymacski于1982年发表在ACM杂志上。LZSS算法充分地利用了位的标记，从而使得压缩效率相比较于LZ77而言，有了显著提高。</p>
<span id="more"></span>

<blockquote>
<p>参考维基百科<a href="https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski">lzss</a></p>
</blockquote>
<h1 id="算法逻辑"><a href="#算法逻辑" class="headerlink" title="算法逻辑"></a>算法逻辑</h1><p>在看本篇博文之前，需要知道LZ77算法的大体流程，如果不清楚可以点击<a href="/2018/03/31/lz77compalgo">这里</a>浏览。</p>
<p>LZSS算法和LZ77算法的编码&#x2F;解码流程逻辑是一致的，区别在于数据编码标记上，这里详细叙述一下LZSS的数据编码标记，可以看到它这种方式是如何显著提高压缩效率的。</p>
<p>在LZSS算法的数据编码里面有一个重要概念，就是：数据分组。</p>
<p>一个字节由8位组成，因此可以用一个字节来标记后面的至少8字节是否存在压缩编码，而不用<code>\0x00\0x00</code>的前缀来区分是否被压缩，从而节省了大量的<code>\0x00\0x00</code>前缀空间开销。</p>
<p>数据分组标记方式：</p>
<p><img src="/2018/04/01/lzsscompalgo/bits.png" alt="databits"></p>
<blockquote>
<p>由此看见，这种数据分组的方式，最坏的情况下，只会每8个字节增加一个字节的额外空间开销，比起每个字节另外需要2个字节的空间开销而言，效率大幅提升。</p>
</blockquote>
<h1 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h1><p>辅助函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">search_maxlen_p</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span>**  pt, \</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> <span class="type">char</span>* head, \</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> <span class="type">char</span>* tail, \</span></span><br><span class="line"><span class="params">                              <span class="type">unsigned</span> <span class="type">char</span>* end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* tmp = *pt;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> leng = <span class="number">0</span>, i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(tmp;tmp &gt;= head;tmp--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp[<span class="number">0</span>] == tail[<span class="number">0</span>])&#123;</span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span>;(i &lt; ((<span class="number">1</span> &lt;&lt; LENGTHBITS) + <span class="number">1</span>)) &amp;&amp; (&amp;tmp[i] &gt; head) &amp;&amp; (&amp;tmp[i] &lt; tail) &amp;&amp; (&amp;tail[i] &lt; end) &amp;&amp; (tmp[i] == tail[i]);i++);</span><br><span class="line">      <span class="keyword">if</span>(i &gt; leng)&#123;</span><br><span class="line">        leng = i;</span><br><span class="line">        *pt = tmp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> leng;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lzss_encode</span><span class="params">(FILE* in,FILE* out)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* buf = <span class="number">0</span>,* head = <span class="number">0</span>,* tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(! in || ! out)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  get_filesize(in,size);</span><br><span class="line">  <span class="keyword">if</span>(size &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  buf = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(size* <span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>));</span><br><span class="line">  <span class="keyword">if</span>(! buf)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(fread(buf,<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>),size,in) == size)&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>  np      =  <span class="number">1</span> ,control_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> suf[<span class="number">17</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 2*8 + 1</span></span><br><span class="line"></span><br><span class="line">    fputc((size &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>,out);</span><br><span class="line">    fputc((size &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>,out);</span><br><span class="line">    fputc((size &gt;&gt;  <span class="number">8</span>) &amp; <span class="number">0xff</span>,out);</span><br><span class="line">    fputc((size &gt;&gt;  <span class="number">0</span>) &amp; <span class="number">0xff</span>,out);</span><br><span class="line"></span><br><span class="line">    head = tail = buf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      head = tail - WINDOWSIZE;</span><br><span class="line">      <span class="keyword">if</span>(head &lt; buf)head = buf;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(control_count &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">        put_bytes(suf,np,out);</span><br><span class="line">        <span class="built_in">memset</span>(suf,<span class="number">0</span>,<span class="keyword">sizeof</span>(suf));</span><br><span class="line">        np = <span class="number">1</span>;</span><br><span class="line">        control_count = <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        control_count++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(tail &gt; buf + size - <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(head &lt; tail)&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> bytes = <span class="number">0</span>;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* pt = tail - <span class="number">1</span>;</span><br><span class="line">        bytes = search_maxlen_p(&amp;pt,head,tail,buf + size);</span><br><span class="line">        <span class="keyword">if</span>(bytes &gt; <span class="number">2</span>)&#123; <span class="comment">// if find a pattern more than 2 bytes, save its offset-length.</span></span><br><span class="line">          suf[<span class="number">0</span>]  &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          suf[<span class="number">0</span>]   |= OFFLENFLAG;</span><br><span class="line">          suf[np++] = (<span class="type">unsigned</span> <span class="type">char</span>)(( (tail - pt) &gt;&gt; LENGTHBITS) &amp; <span class="number">0xff</span>);</span><br><span class="line">          suf[np++] = (<span class="type">unsigned</span> <span class="type">char</span>)((((tail - pt) &lt;&lt; LENGTHBITS) + bytes - <span class="number">2</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">          tail += bytes;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          suf[<span class="number">0</span>]  &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">          suf[np++] = tail[<span class="number">0</span>];</span><br><span class="line">          tail++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        suf[<span class="number">0</span>]  &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        suf[np++] = tail[<span class="number">0</span>];</span><br><span class="line">        tail++;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(control_count;control_count &lt;= <span class="number">8</span>;control_count++)suf[<span class="number">0</span>] &lt;&lt;= <span class="number">1</span>; <span class="comment">// must keep highest bit is aligned to first byte.</span></span><br><span class="line">    put_bytes(suf,np,out);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lzss_decode</span><span class="params">(FILE* in,FILE* out)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>* in_buffer = <span class="number">0</span>,* out_buffer = <span class="number">0</span>,* head = <span class="number">0</span>,* tail = <span class="number">0</span>;</span><br><span class="line">  <span class="type">long</span> in_size = <span class="number">0</span>,out_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(! in || ! out)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  get_filesize(in,in_size);</span><br><span class="line">  <span class="keyword">if</span>(in_size &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  out_size  = (fgetc(in) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">  out_size += (fgetc(in) &amp; <span class="number">0xff</span>) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">  out_size += (fgetc(in) &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">8</span>;</span><br><span class="line">  out_size += (fgetc(in) &amp; <span class="number">0xff</span>) &lt;&lt;  <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(out_size &lt;= <span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  in_buffer = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>)* in_size);</span><br><span class="line">  <span class="keyword">if</span>(! in_buffer)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  out_buffer = (<span class="type">unsigned</span> <span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>)* out_size);</span><br><span class="line">  <span class="keyword">if</span>(out_buffer)&#123;</span><br><span class="line">    <span class="keyword">if</span>(fread(in_buffer,<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>),in_size,in) == in_size - <span class="number">4</span>)&#123;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span>  control_count = <span class="number">0</span>;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span> control_flags = <span class="number">0</span>;</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">char</span>*           pt = (<span class="type">unsigned</span> <span class="type">char</span>*)in_buffer;</span><br><span class="line"></span><br><span class="line">      head  = tail  = out_buffer;</span><br><span class="line">      control_flags = pt[<span class="number">0</span>];</span><br><span class="line">      pt++;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pt &gt;= (in_buffer + in_size - <span class="number">4</span>))<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(control_count &gt;= <span class="number">8</span>)&#123;</span><br><span class="line">          control_flags = pt[<span class="number">0</span>];</span><br><span class="line">          pt++;</span><br><span class="line">          control_count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          control_count++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(control_flags &gt;&gt; <span class="number">7</span>)&#123; <span class="comment">// offset-length.</span></span><br><span class="line">          <span class="type">unsigned</span> <span class="type">int</span> offset = <span class="number">0</span>,length = <span class="number">0</span>,i;</span><br><span class="line">          offset  =  pt[<span class="number">0</span>] &lt;&lt; LENGTHBITS;</span><br><span class="line">          offset += (pt[<span class="number">1</span>] &gt;&gt; LENGTHBITS) &amp; <span class="number">0x0f</span>;</span><br><span class="line">          length  = (pt[<span class="number">1</span>] &amp; <span class="number">0x0f</span>) + <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; length;i++)&#123;</span><br><span class="line">            tail[i] = ((<span class="type">unsigned</span> <span class="type">char</span>*)(tail - offset))[i];</span><br><span class="line">          &#125;</span><br><span class="line">          tail += length;</span><br><span class="line">          pt += <span class="number">2</span>;</span><br><span class="line">          control_flags &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// literal.</span></span><br><span class="line">          tail[<span class="number">0</span>] = pt[<span class="number">0</span>];</span><br><span class="line">          tail++;</span><br><span class="line">          pt++;</span><br><span class="line">          control_flags &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      fwrite(out_buffer,<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>),out_size,out);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(out_buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(in_buffer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>经过LZSS压缩的数据，已经算得上很不错的了，可见下图的十六进制展示：</p>
<p><img src="/2018/04/01/lzsscompalgo/hexdat.png" alt="hexdat"></p>
<p>但是，这里面的数据还有进一步空间优化，可以使用LZ77算法博文里面提到的哈夫曼编码进一步编码，就可以得到理想的压缩效果。</p>
<p>链接：<a href="https://github.com/hchen90/lzss">Github上的代码</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
        <tag>lzss</tag>
      </tags>
  </entry>
  <entry>
    <title>如何将处于虚拟机中的MINIX系统中的文件复制到实体机的LINUX系统中来</title>
    <url>/2016/10/03/minix/</url>
    <content><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>直接在虚拟机MINIX中阅读它的源代码，十分不便，修改调试做移植也非常困难，如果将MINIX系统中的部分源代码拷贝到实体机LINUX中，在LINUX系统中进行修改调试将会非常方便。</p>
<p>然而，MINIX系统是一种比较基本的系统，不能像vmware中使用Windows类系统那样，直接给它装VMTools（因为缺失XWindows，虽然理论上可以给MINIX装个XWindows，但是，太麻烦，而且仅仅为了几个源代码，有点大途小用）。因为vmware的磁盘文件（<code>.vmdk</code>）不是原始的磁盘数据文件，而且，vmware对据如MINIX这些生僻系统的文件系统的识别性不是太理想，造成用vmware无法挂载MINIX系统到实体主机上，仍然复制不到虚拟机中的MINIX的文件。</p>
<span id="more"></span>

<p>所以，我选择使用qemu，qemu的磁盘是原始数据文件，可以在LINUX直接挂载到系统文件树上（只要LINUX能够识别这个文件系统）。</p>
<h2 id="软件和系统准备"><a href="#软件和系统准备" class="headerlink" title="软件和系统准备"></a>软件和系统准备</h2><ul>
<li>MINIX系统：<code>minix_R3.2.0-116fcea.iso</code></li>
<li>QEMU: <code>qemu-system-i386</code></li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>下载好MINIX的ISO文件，在LINUX中启动qemu，把MINIX装好，命令如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -enable-kvm -sdl -cdrom minix_R3.2.0-116fcea.iso -hda minix.img</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果还没有准备minix.img的磁盘镜像，可以用<code>qemu-img create minix.img 2G</code>，或<code>touch minix.img &amp;&amp; truncate minix.img --size=2G</code>，来生成它。</p>
</blockquote>
<p>MINIX装好后，还需要准备一个备用的虚拟磁盘镜像，假如为<code>a.img</code>。这个磁盘就是用来存储需要的代码文件的，磁盘镜像创建好了以后，不要急着在LINUX中对它分区格式化等，这个操作应该在虚拟机中的MINIX系统里来完成。</p>
<p>当<code>minix.img</code>和<code>a.img</code>都准备好后，就可以再启动虚拟机来拷贝文件了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-i386 -enable-kvm -sdl -hda minix.img -hdb a.img</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的<code>minix.img</code>是通过上一步，已经在里面装好了MINIX系统了。</p>
</blockquote>
<p>QEMU虚拟机开启后，进入MINIX系统，输入<code>root</code>来登录，到了MINIX系统中，因为MINIX的设备组织方式和LINUX系统有所不同，它的磁盘格式通常为据如<code>c0d0p0</code>等这样的形式，第一个’c’表示’Controller’，数字表示序号，第三个’d’表示’Disk’，后面的’p’表示’Partition’，还有’s’表示’Subpartition’，可以用<code>man dev</code>来查看一下，里面介绍的很详细。</p>
<p>可以用<code>df</code>来判断系统的minix.img所占的是哪个磁盘，这时，虽然<code>a.img</code>已经连到了MINIX系统，但是还没有找到它在哪。首先，排除minix.img所占的哪个盘，假定为<code>c0d0</code>，这种已经挂载了的盘，若用<code>mount</code>来挂载的话，会显示忙而无法挂载，其中光驱一般是<code>c0d2</code>盘，可以试一试挂载<code>c0d1</code>盘，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/c0d1 /mnt</span><br></pre></td></tr></table></figure>

<p>注意它报出的是什么错误，如果显示为不存在的设备或地址的错误，就接着试下一个，比如<code>c0d3</code>，直到有个不再报这个错误的磁盘，依照上面的假设，这里要除掉<code>c0d0</code>和<code>c0d2</code>，假如<code>c0d1</code>不报这个不存在设备或地址的错误，那就说明<code>a.img</code>就是这个设备。</p>
<p>在MINIX中，用<code>fdisk</code>来给它分区，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fdisk /dev/c0d1</span><br></pre></td></tr></table></figure>

<p>在fdisk工具中，可以用<code>c</code>命令来修改分区信息，修改好后，用<code>w</code>命令来保存这些分区信息到<code>a.img</code>的镜像上。</p>
<p><code>a.img</code>被分区好后，还要用<code>mkfs</code>来进行文件系统的格式化，<strong>注意，这里一定要选择用<code>ext2</code>的文件格式，因为<code>ext2</code>在MINIX和LINUX中，都能较好的支持</strong>，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/sbin/mkfs.ext2 /dev/c0d1</span><br></pre></td></tr></table></figure>

<p>而后，<code>c0d1</code>就变成了可以挂载的设备了，可以用mount来挂载:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/c0d1 /mnt</span><br></pre></td></tr></table></figure>

<p>挂载后，转到<code>/mnt</code>目录，把自己要复制的文件，全部拷贝到这里。完了以后，卸载挂载点，关虚拟机。</p>
<p>现在，回到了LINUX系统中，<code>a.img</code>已经有刚才拷贝的文件了，我们只需要把<code>a.img</code>当作设备来进行挂载即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -t ext2 a.img /mnt</span><br></pre></td></tr></table></figure>

<blockquote>
<p>普通用户前面加<code>sudo</code>来升权，root用户无需加<code>sudo</code>。</p>
</blockquote>
<p>再转到<code>/mnt</code>中，文件是不是都在这。</p>
<blockquote>
<p>这个方法，是QEMU的文件复制通用方法，前提是虚拟机系统和实体主机系统都支持一种相同的文件系统，然后用这个共同的文件系统来作为传输媒介。</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>minix</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式服务系统概述</title>
    <url>/2020/12/20/redistributedservicesystem/</url>
    <content><![CDATA[<h1 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h1><p>关于分布式系统的定义，应该都不会陌生，它就是一些独立的计算机集合，这些计算机也称为节点，为了完成一项事务，由这一组计算节点协作完成。</p>
<p>而分布式还有另外一个特点，就是用户几乎感知不到它是很多节点来完成一项事务的，甚至可以说，站在用户的角度，它和集中式系统几乎雷同，用户不会觉得他&#x2F;她在请求的是集中式系统，亦或分布式系统，这是分布式系统的透明性。</p>
<span id="more"></span>

<h2 id="和传统的集中式C-x2F-S系统对比"><a href="#和传统的集中式C-x2F-S系统对比" class="headerlink" title="和传统的集中式C&#x2F;S系统对比"></a>和传统的集中式C&#x2F;S系统对比</h2><p>首先看一下传统的集中式C&#x2F;S系统：</p>
<p><img src="/2020/12/20/redistributedservicesystem/tra-cs-mod.png" alt="Tra-CS-System"></p>
<p>而对于分布式的系统而言，它是这样的：</p>
<p><img src="/2020/12/20/redistributedservicesystem/redi-rs-mod.png" alt="Redi-System"></p>
<p>比起传统集中式C&#x2F;S服务而言，分布式系统具有更强的拓展性，对于集中式的服务系统来说，需要不断升级集中式服务系统的硬件来提高系统的性能，这样做不仅成本高，而且对于整个系统的可靠性也不好；而对于分布式系统来说就简单多了，只需要增加节点即可，使系统的计算负载到新增的节点上，进而使得整个系统的性能得到提升。</p>
<blockquote>
<p>相比较于集中式系统，分布式节点的性能要求可能很低，只要满足基本要求即可</p>
</blockquote>
<p>对于系统的稳定性来说，分布式系统允许部分节点出现故障，而不会影响整个系统的有效性，如果整个系统出现很多节点故障，只要还有必要节点存活，这个系统就会一直有效，对外表现最多就是这个系统的性能有所下降；但是对于集中式系统来说，就没有办法这样了，它只有一个节点，这个节点崩掉了，整个系统就崩调了。</p>
<p>但是，分布式系统也有它的缺点，最大的问题就是数据一致性问题，因为计算需要的数据被分配到不同的节点上，如何保证各个节点对同一个数据的修改是一致的，所以，对于数据的设计就要比集中式的复杂些。</p>
<h1 id="具体的技术细节"><a href="#具体的技术细节" class="headerlink" title="具体的技术细节"></a>具体的技术细节</h1><p>上面说了一些分布式系统的优缺点，可见分布式的优点比起它的缺点更吸引人。</p>
<p>但是，如果我们要去实现这样的系统，我们就不得不考虑据多技术细节：</p>
<ul>
<li>分布式由许多子服务运行在这些节点上的，但是如何来划分这些子服务呢？</li>
<li>在任何跨站服务同步都少不了协同通信，如何设计一套同步通信呢？</li>
<li>上面说的数据一致性问题，应该如何解决呢？</li>
<li>分布式系统就是为了可以拓展，那么如何设计来达到可拓展性呢？</li>
</ul>
<p>如果上来我们就去解决这些问题，会非常棘手，不过好在这些技术都存在很多设计模板，和很多开源中间件，因此我们不用从零开始来设计这套系统，不然又要从入门到放弃了。</p>
<blockquote>
<p>在设计这样的系统时，我们还是另辟蹊径（或者说是我熟悉的一个领域），这种分布式在游戏服务端中很常见，说到底其实也很简单，只有那么几个技术（其实也在更新发展中，也许和我的版本有些许不同），因此我们只要借鉴游戏服务框架的设计思想即可也可设计一个我们自己的分布式服务系统。</p>
</blockquote>
<p>对于分布式系统，解决并发问题的核心是数据通讯问题，如果在同一个节点里，可以很容易实现数据共享，但是它的效率低下，实现复杂，而且通用性不强，对于节点与节点之间的数据共享就不得不借助套接字了；其次一个方案就是消息传递了，这种方案最常见了，各种开源的中间件，可以说已经是默认方案了，消息传递适用场景也更加广泛，可以是线程之间的同步，进程之间，或者是节点间，它都可以派上用场。</p>
<h2 id="Actor模型"><a href="#Actor模型" class="headerlink" title="Actor模型"></a>Actor模型</h2><p>说到消息传递，我们就要来复习一下Actor模型。</p>
<blockquote>
<p>可以参考一下维基百科的描述：<a href="https://en.wikipedia.org/wiki/Actor_model">Actor Model</a></p>
</blockquote>
<h3 id="什么是-Actor-模型"><a href="#什么是-Actor-模型" class="headerlink" title="什么是 Actor 模型"></a>什么是 Actor 模型</h3><p>Actor模型是一个基本的计算单元，它可以接收消息，并且基于消息执行计算，并将计算结果以消息的形式返回给调用它的Actor，Actor之间相互隔离，他们之间不共享资源。</p>
<p>Actor的本身是状态机模式的进一步封装，它由三部分组成：状态（State），行为（Behavior），邮箱（MailBox）</p>
<p>以上三部分很好理解，状态和行为是状态机的必要元素，邮箱是和外部Actor交互的通道。</p>
<p><img src="/2020/12/20/redistributedservicesystem/actor.drawio.png" alt="Actor Model"></p>
<p>由此可见最上方展示过的那张图中的”<strong>服务N</strong>“，这些都可以抽象化成为Actor模型，每个服务可以对应一个或者多个服务。</p>
<h3 id="状态机模式"><a href="#状态机模式" class="headerlink" title="状态机模式"></a>状态机模式</h3><p>Actor模型用到了状态机模式，状态机模式是一种很常见，很实用的设计模式。</p>
<p>状态机包含最基本的四要素：状态（State），事件（Event），动作（Action），变换（Transition）</p>
<ul>
<li>状态（State）：当前状态机的状态</li>
<li>事件（Event）：触发操作的条件</li>
<li>动作（Action）：所触发的操作</li>
<li>变换（Transition）：从一个状态变成另一个状态的转化表</li>
</ul>
<blockquote>
<p>一个状态机至少包含两个状态：开始态，结束态</p>
</blockquote>
<p>状态机是刚开始的时候，设置为开始态，然后，根据输入的事件触发进行下一个状态，每一个状态都有对应的操作（动作），每种状态的变换，都是根据变换条件来设定的，一直到状态机走到结束态，这个状态机就属于终结了。</p>
<p>由此可见，我们可以把状态机想象成一个黑盒，它接收任何可能的输入，各种不同的输入会触发黑盒内部的状态改变，从而进行下一步操作，从而状态机的维护了它内部的信息隔离，状态安全的优点，也便于外部使用它。</p>
<p>而Actor模型就是内部嵌套着这样的一个状态机，再加一个邮件队列，从结构看来，非常简单明了。</p>
<h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>在说到分布式系统一个很令人头疼的问题那就是数据一致性问题了，虽然为了达到分布式系统数据一致性的方法五花八门，但是这里我推荐一款非常适用的方案，那就是这款MongoDB数据库，这个基于分布式文件存储的数据库天生为了分布式系统而打造的，很多大型分布式游戏服务端用的都是这套系统。</p>
<p>MongoDB提出文档（Document），集合（Collection）概念，其数据模型结构类似于JSON，非常适合实际环境下读写，其次MongoDB支持数据集分片的功能，从而可以把数据分摊到多个用于存储数据的节点上，最后，因为它的数据模型是基于面向对象的，所以可以表达很丰富，层次较多的数据结构。</p>
<p><img src="/2020/12/20/redistributedservicesystem/mongo-cli.png" alt="mongo-db"></p>
<h2 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h2><p>在我们的分布式系统里面，Redis的作用是用来缓存数据的，因为我们的Actor它要操作数据库进行读写操作，这里的Actor可以是一个专门负责数据存储的Actor，它来读写数据库，读写数据库如果是同节点的数据库，那速度应该不会很慢，但是仍然不如Redis这种内存数据库的快速，而往往有一种更加复杂的情形，那就是读取MongoDB实际上不在本地，而是在另一个节点上，这读写一次数据还要经过网络，所以时间较长，这时Redis的角色就更不可或缺了。</p>
<p><img src="/2020/12/20/redistributedservicesystem/redis-cli.png" alt="redis"></p>
<h1 id="分布式适用场景"><a href="#分布式适用场景" class="headerlink" title="分布式适用场景"></a>分布式适用场景</h1><p>分布式系统适合用户量很大，数据存储量庞大的场景，对于庞大的用户接入，如果是集中式的服务系统，那么它的负载压力就会很大，很容易触及性能瓶颈，而去提升它的话，所要支出较大，而且灵活性也很差，但是对于分布式系统而言，系统可以存在多个网关服务节点，用户只需要接入网关节点，把网关节点当作服务节点用即可。</p>
<p>网关节点则是从其他节点获取实际请求的资源，得到结果后，把它返回给用户。</p>
<p>通常来说这样的分布式系统是存在一个内部网络中的，它是由很多节点组成的系统，系统中的网关节点是存在公网IP的，可以被外部访问，而内部其他的功能服务节点，视其功能可以不对外开放访问，它只会把结果交给网关服务节点，网关会把数据请求发给对应的内部服务节点。</p>
<p><img src="/2020/12/20/redistributedservicesystem/diagram.png" alt="diagram"></p>
<h1 id="技术总结"><a href="#技术总结" class="headerlink" title="技术总结"></a>技术总结</h1><p>这种分布式的服务系统相对来说可以接收很大的接入量，比如200k，1000k都可以做到，只需要增加网关节点即可，数据量也可以变得非常庞大，这时我们只需要增加MongoDB的数据分片即可。总的来说，就是性能不够增加节点即可。</p>
<p>这里我们所需要的技术全部都是非常明了，中间件也非常完善，唯独在Actor模型，和服务分类上面稍作设计就可以达到我们所需要的目的，尤其在同构的服务上，如何实现协作要精心设计一下。</p>
<blockquote>
<p>这里的技术概要就写道这里，我会在下一篇技术博文使用具体的设计工具，并且编写代码，制作一个微型的分布式服务系统。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>Actor</tag>
        <tag>MongoDB</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB Cloud云平台简单使用简介</title>
    <url>/2022/04/03/mongodbcloudcluster/</url>
    <content><![CDATA[<h1 id="什么是MongoDB-Cloud"><a href="#什么是MongoDB-Cloud" class="headerlink" title="什么是MongoDB Cloud"></a>什么是MongoDB Cloud</h1><p>MongoDB Cloud 的核心是 <a href="https://www.mongodb.com/zh-cn/cloud/atlas">MongoDB Atlas</a> ，这是一个适用于现代应用程序的完全托管的云数据库。Atlas 是运行领先的现代数据库 MongoDB 的最佳方式。<a href="https://www.mongodb.com/zh-cn/what-is-mongodb">MongoDB</a> 的文档模型是一种更快的创新方式，可为数据库带来灵活性和易用性。</p>
<span id="more"></span>

<p>这是官网的简介，然后，再看一下它的价格，如下图：</p>
<p><img src="/2022/04/03/mongodbcloudcluster/price.png" alt="price"></p>
<p>可以看到，其存在一个可以共享的免费版，它是一个运行沙盒的环境，其包含基本的数据存储功能了，如果对存储大小，网络隔离等等有需求的话，可以考虑另外两个。</p>
<h1 id="创建DB-Cluster"><a href="#创建DB-Cluster" class="headerlink" title="创建DB Cluster"></a>创建DB Cluster</h1><h2 id="登录账号"><a href="#登录账号" class="headerlink" title="登录账号"></a>登录账号</h2><p>首先是登录MongoDB Cloud的账号了，如果没有的话，可以创建一个账号，并登录之，并进入到Dashboard，如下图：</p>
<p><img src="/2022/04/03/mongodbcloudcluster/dashboard.png" alt="dashboard"></p>
<blockquote>
<p>注意：上图中是已经创建了一个Cluster</p>
</blockquote>
<h2 id="创建一个Cluster"><a href="#创建一个Cluster" class="headerlink" title="创建一个Cluster"></a>创建一个Cluster</h2><p>在进入Dashboard后，可以创建一个Cluster，并进行一系列的配置，包括数据存放区域地点，供应商信息，等等一些信息。<img src="/2022/04/03/mongodbcloudcluster/createcluster.png" alt="createcluster"></p>
<p>根据业务服务需求，选择低延迟数据存放点：</p>
<p><img src="/2022/04/03/mongodbcloudcluster/location.png" alt="location"></p>
<p>以及云供应商：</p>
<p><img src="/2022/04/03/mongodbcloudcluster/provider.png" alt="privider"></p>
<p>除此之外，还可以对Cluster进行一些额外的信息配置（例如：所使用的数据库版本信息）：</p>
<p><img src="/2022/04/03/mongodbcloudcluster/settings.png" alt="settings"></p>
<h2 id="配置创建的Cluster"><a href="#配置创建的Cluster" class="headerlink" title="配置创建的Cluster"></a>配置创建的Cluster</h2><p>配置上面，内容比较简洁，主要是分两个部分，数据部分的是触发器配置，安全部分的是数据库用户配置和网络访问配置。</p>
<p>数据库的用户配置用于添加访问数据库的用户，包括设置用户登录名和密码，也可以是证书验证方式来登录：</p>
<p><img src="/2022/04/03/mongodbcloudcluster/adduser.png" alt="adduser"></p>
<p>创建了用户后，我们其实还不能进行数据库的登录，还需要把我们登录客户端的IP添加到白名单列表之中：</p>
<p><img src="/2022/04/03/mongodbcloudcluster/ipwhitelist.png" alt="ipwhitelist"></p>
<blockquote>
<p>注意事项：</p>
<p>不要忘记把IP添加到白名单中，不然会出现连接失败的问题。</p>
</blockquote>
<h1 id="连接DB-Cluster并使用"><a href="#连接DB-Cluster并使用" class="headerlink" title="连接DB Cluster并使用"></a>连接DB Cluster并使用</h1><p>客户端使用mongo进行连接刚刚创建的云端Cluster，效果如下：</p>
<p><img src="/2022/04/03/mongodbcloudcluster/connectcloud.png" alt="connectcloud"></p>
<p>连上后就可以向里面写入一些数据了：</p>
<p><img src="/2022/04/03/mongodbcloudcluster/collection.png" alt="collection"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件壳的设计过程</title>
    <url>/2013/10/26/mspeshell/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>今天来讨论一下PE文件的壳，壳主要用于PE文件的商业保护，以此达到软件不被暴掉的可能性，随着破解知识的普及，软件的壳也愈加复杂才可勉强不被暴。</p>
<p>壳的一个加载过程在许多书上都将过，这里就以图来复习一次：</p>
<span id="more"></span>

<p><img src="/2013/10/26/mspeshell/pic1.png" alt="pic1"></p>
<p>这张图其实是一种情形，原程序被压缩引擎压过，还可以是在EXE文件上直接加壳不压缩，这样到省了壳的大小，但原EXE代码没有压缩，反而变大了一点，还有一种是在EXE文件的节区的空隙中添加，这样压缩过的文件和原文件一样大，但是对节区的大小有要求。这是三种常规的加壳思路。</p>
<p>如果单单是加一个简单的壳，象罗云彬的<em>《windows32位环境下的汇编语言程序设计》</em>中的那个<code>AddCode</code>就是一个典型代表。主要步骤如下：</p>
<p>首先在节区表上添加一个节区表信息，把代码写到文件的最后面（已经与新的节区表信息对应），主要注意一下，节区的<code>SectionAlignment</code>和<code>FileAlignment</code>，按照这两个参数写节区信息表，跳到节区表中对应文件偏移位置处，写入代码，代码在节区写不满，要填充<code>0</code>，保持文件对齐的值，通常<code>200</code>，最后是收尾工作，PE文件的<code>NumberOfSections</code>加<code>1</code>，<code>SizeOfImage</code>要加上新节区按照<code>SectionAlignment</code>的值对齐后的大小的值，<code>SizeOfHeaders</code>要按照<code>FileAlignment</code>对齐的，如果加上一个<code>IMAGE_SECTION_HEADER</code>，大小不过<code>FileAlignment</code>，就可能不用修改其值的，还有个<code>SizeOfCode</code>是添加代码的大小，就是将含有代码的节区的大小值相加（这个值已经按<code>FileAlignment</code>对齐，载节区表中）。</p>
<p>刚才讲的是上面说的第二个思路，还有两个思路，在下面的附件中有个与此类似的思路的一个，还有个是第三个思路的方法。</p>
<p>上面的这个方法实现是比较简单的，但是这种方法没有什么程序保护功能，下面讲一下又保护功能的方法。</p>
<p>要实现保护功能，可以保护的内容常见的有，导入函数，导出函数，代码段，数据段等。</p>
<h1 id="如何实现导入函数的保护"><a href="#如何实现导入函数的保护" class="headerlink" title="如何实现导入函数的保护?"></a>如何实现导入函数的保护?</h1><p>在PE文件的头中的<code>DataDirectory</code>有个导入函数的列表，指定<code>RVA</code>和大小，许多PE文件分析，如PEID，LoadPE，还有我的PE Scanner,都是根据这里找到函数的信息的。</p>
<p>这个RVA，在PE文件加载后，会指定到一个<code>IMAGE_IMPORT_DESCRIPTOR</code>，这个结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminatin gnull import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>在这个结构体中<code>OriginalFirstThunk</code>和<code>FirstThunk</code>虽然不指同一位置，但是它们指向的<code>ThunkData</code>所知的位置是相同的，等于一个是另一个的备份，在Windows的装载器加载时，会将<code>FirstThunk</code>指向的所有的<code>ThunkData</code>替换成<code>ThunkData</code>指向的函数的真正的地址，如下图：</p>
<p><img src="/2013/10/26/mspeshell/pic2.png" alt="pic2"></p>
<p>在程序未加载时，可以看到磁盘文件如下：</p>
<p><img src="/2013/10/26/mspeshell/pic3.png" alt="pic3"></p>
<p><code>402014</code>的位置是<code>000020F4</code>，这个是<code>RVA</code>，在看这个<code>ThunkData</code>指向哪里，如下：</p>
<p><img src="/2013/10/26/mspeshell/pic4.png" alt="pic4"></p>
<p>可以看出再过去两个字节就是<code>ExitProcess</code>的函数名，这是个<code>IMAGE_IMPORT_BY_NAME</code>的结构，前两个字节是<code>HINT</code>，是个无关紧要的<code>WORD</code>字段，大致熟悉了一下PE的加载原理，如果自己写保护导入表的保护的话，这些过程需要自己代码“手动”完成。</p>
<p>再来看一下PE文件加载后的情形，用windbg打开文件。</p>
<p><img src="/2013/10/26/mspeshell/pic5.png" alt="pic5"></p>
<p>这些<code>402014</code>的位置已经被填充数据，而不再是原来的<code>RVA</code>：<code>000020F4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP DWORD DS：[402014]</span><br></pre></td></tr></table></figure>

<p>也就成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JMP 754879f8</span><br></pre></td></tr></table></figure>

<p>再看看<code>754879f8</code>处的数据：</p>
<p><img src="/2013/10/26/mspeshell/pic6.png" alt="pic6"></p>
<p>可以看到这里到了<code>Kernel32</code>中的<code>ExitProcessStub</code>，整个加载过程也就明了了。</p>
<h2 id="如何加载“藏”的导入表"><a href="#如何加载“藏”的导入表" class="headerlink" title="如何加载“藏”的导入表"></a>如何加载“藏”的导入表</h2><p>因此如果要保护输入表里的函数，就必须把原来的导入表的那些信息（包括<code>IMAGE_IMPORT_DESCRIPTOR</code>和一系列的<code>ThunkData</code>）“藏”起来，自己定义一个<code>IMAGE_IMPORT_DESCRIPTOR</code>和<code>ThunkData</code>，用于定义自己必须的API函数，这样自己就不用再堆中找Kernel32的基址，查导出函数等一系列的复杂工作，比如自己定义两个位于Kernel32.dll中的函数：<code>LoadLibraryA</code>和<code>GetProcAddressA</code>，自己把原来的导入函数信息表“藏”了起来，自己在程序加载时要把找出来，并且在<code>FirstThunk</code>中找函数，因为导入表被“藏”，PE的装载器没有为程序将<code>ThunkData</code>的值换成据如<code>754879f8</code>等这样的真正的函数地址，所以自己要找函数（有按序号导入的和按名称导入的两种），需要注意的是若找到的函数是序号导入的话，需去掉高位用于检测的<code>1</code>（即与<code>80000000H</code>检测），然后直接将其作为函数的名称，用<code>GetProcAddressA</code>来获取地址，DLL的名称获取更加简单，直接，用Name的<code>RVA</code>加基址，即可，获取DLL名称的字符串，可用<code>LoadLibraryA</code>，来加载。</p>
<p>通过上面这些步骤，举例来说，使先前的<code>402014</code>的这些位置得到修正，自己用<code>LoadLibrary</code>加载<code>Kernel32.dll</code>，获取<code>ExitProcess</code>的地址，并且把得到的地址填到<code>402014</code>的位置处，这样<code>ExitProcess</code>函数才得以顺利执行，其他的函数其次类推，要把所有的<code>IMAGE_IMPORT_DESCRIPTOR</code>找遍，保证所有的函数地址都被填到恰当的位置。</p>
<h2 id="关于加密数据和代码"><a href="#关于加密数据和代码" class="headerlink" title="关于加密数据和代码"></a>关于加密数据和代码</h2><p>上面的这些方法，其实只保护了导入表，但只要会点反汇编的人都能知道前面的代码，因为程序的入口虽改变，但是代码任在那里，可以改变偏移即可看到，如下两个对比图：</p>
<p>没有加密代码段的情况（start处是我的代码）：</p>
<p><img src="/2013/10/26/mspeshell/pic7.png" alt="pic7"></p>
<p>加密代码段的情况（start是我的代码）：</p>
<p><img src="/2013/10/26/mspeshell/pic8.png" alt="pic8"></p>
<p>加密代码段的情况下，需要在自己的代码里有揭秘代码的内容，以便代码得以执行，我的这个例子只是简单的转位，<code>rol</code>，<code>ror</code>，所以解密相当简单，如果要复杂的话，可以用压缩引擎压缩代码（<code>lz77</code>，<code>lzss</code>，或者复杂点的哈弗曼编码等等），这样还能更多节省空间，还可以用其他的密码学原理来加密等，具体细节，自由发挥。</p>
<p>但是这种方式基本上还是经不住考验，ASPack，UPX，Pecompact等，还有附件中我自己编写的这个，用的都是这种方法。</p>
<p>这种类型壳非常好脱，下面举个例子：</p>
<p><img src="/2013/10/26/mspeshell/pic9.png" alt="pic9"></p>
<p>这是个ASPack的壳，刚开始的时候，断点处<code>push</code>后面的还是<code>0</code>，到此处已经变为<code>004013da</code>，这个正是原来程序的<code>ep</code>，其实ASPack前面的工作跟我的那个壳差不多，无非就是填充<code>ThunkData</code>和解密数据。</p>
<p><img src="/2013/10/26/mspeshell/pic10.png" alt="pic10"></p>
<p>到此处，可见，ASPack把所有的<code>ThunkData</code>都填充了，用OllyDump顺便dump下，在看一下，导入表信息，借助LoadPE将其中的<code>NtDllDefWindowProc_A</code>改成<code>DefWindowProcA</code>，程序脱壳完成。</p>
<p>这种壳之所以好脱，是因为，外壳代码，在程序揭秘后又将代码写到原来的位置，相当于把一件东西藏进一个多么可靠的容器中来保护它，但是要使用它就必须拿出来（壳的自解密），而就在拿出来时，我们可以把它恢复原始形态！！！</p>
<p>如果设计一种机制，这个机制是每次需要执行代码时，先读取加密的数据，揭秘一条指令长的数据，然后再执行，然后再取，再揭秘，在执行，这个循环的过程一直执行下去，直到最后，而且用的空间只是一个指令长的地址空间，后面执行的代码覆盖前面的代码，短的指令，填充<code>90H</code>（<code>nop</code>），这样揭秘的数据不会记录，提高了安全性，但这个方法，需要面临下个数据的指令的长度，就需要个小型反汇编引擎嵌在壳上，还有<code>eip</code>跳转位置等的问题，但是就复杂了。</p>
<h2 id="虚拟机的构想"><a href="#虚拟机的构想" class="headerlink" title="虚拟机的构想"></a>虚拟机的构想</h2><p>上面的问题引起这个问题的产生，虚拟机就是模仿CPU指令执行，I&#x2F;O环境等的一种机制，这种机制在虚拟机软件较常见，如：vmware，vbox等，壳也可以用虚拟机这种机制，只不过它主要模仿CPU的指令，也可模仿I&#x2F;O环境等，将上面的机制设置的复杂一点，如：<code>pop eax</code>，转到虚拟机执行，变成，<code>dec eax</code>，<code>inc eax</code>转到虚拟机变成<code>push eax</code>，还可以更复杂，自己模拟一个I&#x2F;O环境，每次<code>IN 45H</code>，表示<code>eax</code>加<code>1</code>，每次<code>IN 46H</code>表示<code>eax</code>减去<code>1</code>，<code>IN 50H</code>表示<code>ebx</code>加<code>1</code>等等（简而言之，就是模拟一套新的指令集，前面几个设想是自己天马行空，不必当真：）。</p>
<p>虚拟机还可以参入密码学加密机制，等。</p>
<p>总的来说，内容较多，涉及范围较广，而且若要设计起来，将是一个大的工程，估计壳的添加代码也较多。</p>
<h2 id="最后一点补充"><a href="#最后一点补充" class="headerlink" title="最后一点补充"></a>最后一点补充</h2><p>如果加壳的程序是个随机加载基址的程序，可能会影响到自己的揭秘后的代码正常执行，这时需要修正PE，去掉<code>.reloc</code>的节，主要是要将<code>DataDirectory</code>的随机加载的数据项清零，<code>NumberOfSections</code>减掉<code>1</code>，修正<code>SizeOfHeaders</code>，也有可能不需要修正，但是最重要的是要把<code>OptionalHeader</code>中的<code>DllCharacteristics</code>的值清零。</p>
<p>附件中有两个是向程序的空余间隙添加代码，因此程序的空余间隙必须大一点，否则会失败。</p>
<blockquote>
<p>链接：<a href="https://bbs.pediy.com/thread-180609.htm">我在看雪上的帖子</a></p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>EXE</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机系统启动流程</title>
    <url>/2018/06/16/systemstartup/</url>
    <content><![CDATA[<h1 id="远古时代"><a href="#远古时代" class="headerlink" title="远古时代"></a>远古时代</h1><p> 这个时期，计算机是处于电气化高度相关的环境下，几乎没有软件的概念（这里有点瑕疵，稍后补充）。</p>
<p>计算机这个时候会进行一系列针对硬件的自测试，尤其检测一些必要硬件是否可用，这个过程成为POST自检，如果检测通过就会进行下一个步骤：BIOS模式，或者UEFI模式。</p>
<span id="more"></span>

<blockquote>
<p>一般计算机硬件出现故障，都会在这里的硬件自检阶段无法通过而被迫中断。此阶段的自检包括CPU的检测，内存，IO芯片模块，例如什么8255等等（现代的这些外设芯片性能更加优越，功能更加丰富，不一定是8255这些老古董）。</p>
</blockquote>
<p>以上部分是纯粹硬件部分的自检，几乎没有软件掺入，到了下一步的BIOS或UEFI步骤，就会正式有软件程序的加入。</p>
<blockquote>
<p>但是对于一些异构平台，例如嵌入式设备，这里的设计可能就会不一样了，它的自检可能是透明的，几乎不可察觉的，因为它都是在一块SOC芯片里面完成的，而且很大成分是基于软件的，这里不讨论嵌入式的流程。</p>
</blockquote>
<h2 id="传统BIOS方式"><a href="#传统BIOS方式" class="headerlink" title="传统BIOS方式"></a>传统BIOS方式</h2><p>系统通过自检后，会启动一个ROM上的BIOS程序，BIOS是运行在实模式下的，程序从几百K到几M不等。它是最底层对硬件的控制层，可以在计算机启动的时候进入BIOS界面，可以对计算机系统进行各种设置，其可设置的信息因厂商不同也丰富多样。</p>
<p>BIOS程序被启动后，就会进行初始化操作，主要包含创建中断IRQ表，各种寄存器的设置，还有IO端口分配等等。</p>
<p>当上述操作都完成后，BIOS就会复制BIOS设置里面的启动分区到RAM中（启动MBR分区程序），并加载其中的引导程序（引导程序会被复制到RAM地址0x00007c00的开始处）。</p>
<h2 id="现代UEFI方式"><a href="#现代UEFI方式" class="headerlink" title="现代UEFI方式"></a>现代UEFI方式</h2><p>UEFI是现代计算机都采用的接口，作为替换BIOS的方案。UEFI的翻译就是<strong>统一可拓展固件接口</strong>,它采用了模块化的设计，而且，它可以运行在AMD64, IA32, IA64等多种架构平台上。</p>
<blockquote>
<p>为什么要UEFI？</p>
<p>因为BIOS的发展缓慢，经过几十年，还是需要通过必须进入16位的实模式，然后初始化设置。而且对于各种多样的厂商，也没有统一的固件接口规范，所以就一直依赖于老的BIOS方案，但后来Intel设计的UEFI，确定了统一的接口规范，从设计上提高了软件操作性，并解决了BIOS的局限性，这些高级的功能拓展打破了BIOS下遇到的困局。</p>
</blockquote>
<p>UEFI的方式和BIOS基本类似，只不过它具备了更加高级的特性，而且可以很方便地更新硬件固件。</p>
<p>UEFI的初始化完成后，也是在设置里面找到一个磁盘，不过不是启动分区上的MBR程序，而是会找到EFI的分区，从分区的对应目录下去启动EFI程序，而EFI启动程序就是计算机系统的引导程序了。</p>
<blockquote>
<p>可见这种加载方式更加安全，以往有些病毒可以修改MBR分区程序，进而把自己深深地植入系统之中，而在UEFI下，如果启动程序是添加签名加载的话，UEFI对启动程序会进行验签，使得病毒无法通过修改启动程序来植入系统了。</p>
</blockquote>
<h1 id="古代文明"><a href="#古代文明" class="headerlink" title="古代文明"></a>古代文明</h1><p>这一部分是启动的引导程序。</p>
<h2 id="一些常见的引导程序"><a href="#一些常见的引导程序" class="headerlink" title="一些常见的引导程序"></a>一些常见的引导程序</h2><h3 id="GRUB"><a href="#GRUB" class="headerlink" title="GRUB"></a>GRUB</h3><p>GRUB是一款非常受欢迎的Linux启动引导程序，它是可以引导不同的操作系统来启动，比如：Linux，Windows，FreeBSD等等。</p>
<p>当GRUB被启动后，它会加载模块，并读取配置文件，展示可以启动的选项；或者也可以切换到它的命令交互模式，可以像使用Shell那样来发送命令，指定如何启动系统。</p>
<h3 id="LILO"><a href="#LILO" class="headerlink" title="LILO"></a>LILO</h3><p>LILO是一个比GRUB更早的Linux启动引导程序，至今还有一些发行版本在延用它，它也可以加载不同的操作系统，不过在功能方面相比于GRUB更加简洁一些。</p>
<h3 id="BOOTMGR"><a href="#BOOTMGR" class="headerlink" title="BOOTMGR"></a>BOOTMGR</h3><p>BOOTMGR是大概Windows Vista发行后，出现的启动引导，它是NTLDR的衍生版本，通过读取BCD文件配置来加载系统内核，同时，BOOTMGR也是为了更好地于64位系统兼容而设计的。</p>
<h3 id="NTLDR"><a href="#NTLDR" class="headerlink" title="NTLDR"></a>NTLDR</h3><p>这个Windows XP以及之前的Windows版本采用的引导程序，它的职责就是解析BOOT.INI配置文件，并加载系统内核。</p>
<h2 id="引导程序做什么"><a href="#引导程序做什么" class="headerlink" title="引导程序做什么"></a>引导程序做什么</h2><p>这里为了方便起见，就拿GRUB举例，在GRUB被启动后，它首先读取相应的配置，并向屏幕打印一个菜单，菜单列举了可以启动的系统选项，当用户选中一个菜单进入后，它就按照菜单项所设置的参数来启动系统内核，而且这些传递给操作系统的参数可以直接进行修改的，修改后的参数设置会被传递给内核。</p>
<h3 id="GRUB的加载流程"><a href="#GRUB的加载流程" class="headerlink" title="GRUB的加载流程"></a>GRUB的加载流程</h3><p>这里的GRUB加载指的是以BIOS启动后的加载</p>
<ul>
<li>当GRUB程序在MGR分区被拷贝到RAM地址的0x00007c00后，GRUB就被接着运行</li>
<li>这个小段的GRUB程序是实模式的，它会设置自己栈空间</li>
<li>从磁盘读取配置，加载Linux内核文件的前面512字节，拷贝到系统的RAM地址为0x00090000处（这段内核按特定的约定设置好在相对偏移为0x0200处即为它的入口，即：0x00090200）</li>
<li>再把Linux后面剩余部分拷贝到0x00010000处（用make zImage编译的内核），或者拷贝到0x00100000处（用make bzImage编译的内核）</li>
<li>当上述拷贝完成后，直接跳到0x00090200处执行代码，就是上面所说的内核入口</li>
</ul>
<blockquote>
<p>对于UEFI启动的内核而言就不需要自己去拷贝再跳转代码了，因为UEFI加载的是PE文件，通过PE文件信息是可以指定让UEFI如何来加载PE内核的，例如：入口地址是多少等等</p>
</blockquote>
<h3 id="引导程序扮演的角色"><a href="#引导程序扮演的角色" class="headerlink" title="引导程序扮演的角色"></a>引导程序扮演的角色</h3><p>GRUB本身不是操作系统，它只是一个操作系统的加载工具，通过这种方式，就可以很方便地维护和修复系统内核因错误无法启动而进行回滚到以前的版本的操作。</p>
<p>引导程序作为操作系统和BIOS&#x2F;UEFI的中间层，它提供了一种衔接机制，避免了因操作系统内核出错原因而无法进行操作系统修复的尴尬。</p>
<blockquote>
<p>在Windows中的NTLDR和BOOTMGR，都是类似的方式启动操作系统内核的，如果启动出现故障，也会展示一个启动出错的页面，那就是引导程序做的事。</p>
</blockquote>
<h1 id="近代时期"><a href="#近代时期" class="headerlink" title="近代时期"></a>近代时期</h1><p>经过这么多流程，终于走到了操作系统的部分了，这部分各个操作系统不同而所进行的操作也各异，但是一般都会涉及到的操作可能有：</p>
<h2 id="操作系统初始化"><a href="#操作系统初始化" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h2><p>从实模式切换到保护模式，包括：</p>
<ul>
<li>初始化GDT, LDT寄存器</li>
<li>Paging需要设置PTE映射</li>
<li>设置TSS任务管理机制</li>
<li>设置IDT表来管理IRQ中断</li>
<li>初始化文件系统</li>
<li>初始化IO设备</li>
</ul>
<blockquote>
<p>至于操作系统这部分内容比较多，我可以选择下一篇博文叙述。</p>
<p>另外，我有一个未完成的demo在GitHub上，可以点击<a href="https://github.com/hchen90/msys_x86">这里</a>查看。</p>
</blockquote>
<p>相关参考链接：</p>
<ul>
<li><a href="https://wiki.osdev.org/">wiki.osdev.org</a></li>
</ul>
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>GRUB</tag>
        <tag>UEFI</tag>
        <tag>BIOS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Visual Studio 2010中使用SQL Server 2008</title>
    <url>/2014/08/02/vssqlserver2008/</url>
    <content><![CDATA[<p>SQL Server是微软的数据库产品，也是一个较为众所周知的数据库产品，其中SQL Server 2000深受广大的用户的青睐，知名度较高，SQL Server 2008是其的后继产品之一，废话不多说了（本文不讨论VS或SQL Server的安装，假设预制环境就绪）。</p>
<p>首先在菜单的<code>视图</code>-&gt;<code>其他窗口</code>-&gt;<code>服务器资源管理器</code>，打开一个小的浮动窗口，就像这个样：</p>
<span id="more"></span>

<p><img src="/2014/08/02/vssqlserver2008/pic1.png" alt="pic1"></p>
<p>可以在<code>数据连接</code>项，右击，<code>创建新SQL Server数据库</code>，出现以下这个对话框：</p>
<p><img src="/2014/08/02/vssqlserver2008/pic2.png" alt="pic2"></p>
<p>点击一下<code>刷新</code>，在左边的输入控件的下拉菜单可以选择一个服务器，如果没有，说明本地的服务段（假设你的计算机处于脱机状态）未启动，通常像这种庞大的，高稳定的数据库都是一个服务端负责监听，并且在内部完成数据库的数据改动，相当于将数据库的逻辑模式和内部模式放到了服务器端（就像一个Apache服务器，在服务端工作一样）。</p>
<p>如果服务器没有启动，则要启动服务，这个跟mysql在Linux系统中用<code>service mysqld start</code>是一样的性质，在windows的开始菜单找到<code>服务</code>（Win7在<code>管理员工具</code>下面），或者在命令行输入<code>services.msc</code>，在<code>服务</code>工具的窗口中找到<code>SQL Server （SQLEXPRESS）</code>，</p>
<p><code>SQL Server Browser</code>和<code>SQL Server VSS Writer</code>，将这些服务启动，再回到上面的对话框，点击<code>刷新</code>，再单击下拉菜单应该就可看到服务器名了，说明服务器端已经启动，可以连接了。</p>
<p>在上面的服务器端选择后，输入新的数据库名，点击<code>确定</code>，就完成一个数据库的创建。<br>数据库创建后，就来连接刚才创建的数据。</p>
<p>依然在<code>数据连接</code>项上，右击，<code>添加连接</code>，会出现一个<code>选择数据源</code>的对话框：</p>
<p><img src="/2014/08/02/vssqlserver2008/pic3.png" alt="pic3"></p>
<p>这里选择<code>Microsoft SQL Server</code>，单击<code>继续</code>，之后出现一个<code>添加连接</code>的对话框：</p>
<p><img src="/2014/08/02/vssqlserver2008/pic4.png" alt="pic4"></p>
<p>服务器名就是刚才启动服务后添加的服务器名，点击下拉菜单可以看到，数据名项就输入刚才创建的那个数据库，也可以点击下拉菜单来选择自己的数据库，在未确定前也可以单击<code>测试连接</code>来验证一下，而后单击<code>确定</code>。</p>
<p>其实也可以在上面的<code>添加连接</code>，选择数据库名前不用创建一个新的数据库也可以，在<code>添加连接</code>对话框中的数据库名项，随便选个其他的数据库，登陆到数据库系统中，当登陆成功后，在查询栏中输入<code>create database XXX;</code>也可以创建数据库，其中XXX是数据库的名称，当要删除&#x2F;摧毁这个数据库时，用<code>drop database XXX;</code>即可删掉XXX数据库。</p>
<p>在<code>服务器资源管理器</code>可以看到新建的数据库已经添加到<code>数据连接</code>的下面：</p>
<p><img src="/2014/08/02/vssqlserver2008/pic5.png" alt="pic5"></p>
<p>在<code>数据资源管理器</code>中的<code>数据连接</code>的下面，右击刚才的数据库，出现的菜单里有很多内容，选择<code>新建查询</code>，即可用SQL语言对数据库进行操作了。</p>
<p>要关闭数据库连接时，同样右击数据库名，单击<code>关闭连接</code>即可。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
</search>
