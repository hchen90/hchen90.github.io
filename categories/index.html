<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="stylesheet" href="/_next/static/css/283bb1ed86b49fd2.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/09ec4099fb721b31.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/09dfadb69bdaa005.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/acd799ec929775fa.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-ede82f7d0ae11dac.js"/><script src="/_next/static/chunks/4bd1b696-299743f5624cdabe.js" async=""></script><script src="/_next/static/chunks/684-481501000630d05e.js" async=""></script><script src="/_next/static/chunks/main-app-338894f2f2966ee4.js" async=""></script><script src="/_next/static/chunks/766-f505dbd3efffaa4c.js" async=""></script><script src="/_next/static/chunks/226-13d4d3f1fc18ceb6.js" async=""></script><script src="/_next/static/chunks/app/layout-07bb40856ea7a35b.js" async=""></script><script src="/_next/static/chunks/874-e909718850e7282e.js" async=""></script><script src="/_next/static/chunks/app/categories/page-0318fd5069c95311.js" async=""></script><title>HCHEN90 博客</title><meta name="description" content="HCHEN90 博客"/><link rel="alternate" type="application/atom+xml" href="https://hchen90.top/atom.xml"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script>document.querySelectorAll('body link[rel="icon"], body link[rel="apple-touch-icon"]').forEach(el => document.head.appendChild(el))</script><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="antialiased relative"><div class="fixed top-4 right-4 z-50"><a href="https://github.com/hchen90" target="_blank" rel="noopener noreferrer" class="flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300" title="Visit my GitHub profile"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a></div><div class="flex flex-col min-h-screen font-[family-name:var(--font-geist-sans)]"><header class="relative w-full"><div class="relative h-[120px] overflow-hidden"><div class="absolute inset-0"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></div><div class="absolute inset-0 flex flex-col items-center justify-center"><h1 class="text-3xl font-bold text-white drop-shadow-lg z-10">文章分类</h1><nav class="mt-2 z-10"><ul class="flex space-x-6"><li><a class="text-white hover:text-gray-200 transition-colors" href="/">首页</a></li><li><a class="text-white hover:text-gray-200 transition-colors" href="/categories/">分类</a></li><li></li><li><a class="text-white hover:text-gray-200 transition-colors" href="/about/">关于</a></li></ul></nav></div></div></header><main class="flex flex-col gap-[32px] items-center w-full max-w-4xl mx-auto p-8 sm:p-20"><div class="w-full"><div class="mb-8"><h2 class="text-xl font-semibold mb-4">所有分类</h2><div class="flex flex-wrap gap-3"><a href="#总结" class="bg-gray-100 hover:bg-gray-200 px-4 py-2 rounded-full text-sm transition-colors">总结<!-- --> (<!-- -->10<!-- -->)</a><a href="#算法" class="bg-gray-100 hover:bg-gray-200 px-4 py-2 rounded-full text-sm transition-colors">算法<!-- --> (<!-- -->2<!-- -->)</a><a href="#随笔" class="bg-gray-100 hover:bg-gray-200 px-4 py-2 rounded-full text-sm transition-colors">随笔<!-- --> (<!-- -->15<!-- -->)</a></div></div><section id="总结" class="mb-12 scroll-mt-24"><h2 class="text-2xl font-bold mb-6 pb-2 border-b border-gray-200">总结<span class="text-gray-500 text-lg ml-2">(<!-- -->10<!-- -->篇)</span></h2><div class="space-y-4"><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/mltraningfittingissues/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">机器学习中模型训练的拟合问题</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">机器学习中模型训练的拟合问题   拟合问题简介  拟合问题可以归纳为模型对数据的规律学得好不好，对于学得好的就称为拟合适中，对于学得不好的可以分类两种：过拟合，欠拟合。  拟合就是用模型函数去逼近数据之间的关系，拟合程度反映了模型函数和实际数据的贴合程度。   过拟合问题  过拟合的意思是模型在...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/ai2-studylog-ml/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">人工智能笔记 - 机器学习</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">人工智能 - 机器学习  人工智能的基础是机器学习，顾名思义就是让机器能够处理数据，并在处理的数据中进行学习，从而能够自主地做出决策。简单来说，机器学习是让机器能够在不需要特别编程的情况下进行学习和改进。  而机器学习，大体上分为三种，分别为：监督式学习，无监督式学习，和深度学习。     监督...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/ai1-studylog-dataanalysis/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">人工智能笔记 - 数据分析和决策</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">人工智能 - 数据分析和决策  这部分主要分为四个层次：  - 数据收集 - 数据清理 - 数据分析 - 决策     数据收集  在人工智能领域数据收集是至关重要的一个环节，它是用于训练模式的输入来源。  作为基础的概念复习，数据收集无非是把目标进行采样，同时我们需要使用科学的方法使样本接近于...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/linuxstartup/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">Linux系统启动流程</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">内核加载  在里面我说明过计算机如何从远古到近代的启动流程，然后，走到操作系统一层的时候就没有深入阐述了，在这篇博文我将以Linux系统为例来叙述操作系统是如何启动的。  通常在系统/boot目录下放着内核文件，如下：  shell initramfs-linux.img vmlinuz-lin...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/systemstartup/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">计算机系统启动流程</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">远古时代   这个时期，计算机是处于电气化高度相关的环境下，几乎没有软件的概念（这里有点瑕疵，稍后补充）。  计算机这个时候会进行一系列针对硬件的自测试，尤其检测一些必要硬件是否可用，这个过程成为POST自检，如果检测通过就会进行下一个步骤：BIOS模式，或者UEFI模式。    &gt; 一般计算机...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/linuxsystemasyncio/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">Linux系统中的异步I/O问题</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">Linux系统中的异步I/O问题  系统编程中，I/O（输入/输出）模型决定了如何和数据进行交互，它对整个系统性能影响至关重要。I/O模型会直接影响如下几大方面：   吞吐量  机器资源利用率，例如：CPU使用率  系统的可拓展性  编程复杂性  I/O模型在网络编程中，是高性能服务器的基础，如...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/softwaredesignpattern4/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">软件设计模式 - 行为模式</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">软件设计模式 - 行为模式  行为模式负责对象之间的高效沟通和职责委派。  行为模式包括：责任链，命令，迭代器，中介者，备忘录，观察者，状态，策略，模版方法，访问者。     责任链模式（Chain of Responsibility/CoR）  责任链模式允许你将请求沿着处理者链进行传递。每个...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/softwaredesignpattern3/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">软件设计模式 - 结构型模式</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">软件设计模式 - 结构型模式  结构型模式介绍类和对象的组装方式，同时保持较大的灵活性和高效性。  结构型模式包括：适配器，桥接，组合，装饰，外观，享元，代理。     适配器模式（Adapter）  适配器模式是为了解决不同接口之间的适配问题。  适配器通常分为两类：对象适配器，类适配器。...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/softwaredesignpattern2/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">软件设计模式 - 创建型模式</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">软件设计模式 - 创建型模式  创建型模式分为：工厂方法，抽象工厂，生成器，原型，单例。     工厂方法模式（Factory Method）  工厂方法模式是一种在父类声明方法，在子类实例化该对象的方法。在C++中通常以虚函数形式来表示，在其他语言，例如Java中则是抽象函数来表示。  工厂方...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/softwaredesignpattern1/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">软件设计模式简介</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">软件设计模式简介  软件设计模式属于软件工程领域的解决问题的基本方法，它提供了一种合理地达成目标的处理步骤。本文主要简单提出为何需要它，它的作用，以及它的主要组成元素。     什么是软件设计模式  软件设计模式其实就是为了解决问题，而制定的一种抽象层面的合理地达到目标的处理步骤。  设计模式的...</p></div></a></article></div></section><section id="算法" class="mb-12 scroll-mt-24"><h2 class="text-2xl font-bold mb-6 pb-2 border-b border-gray-200">算法<span class="text-gray-500 text-lg ml-2">(<!-- -->2<!-- -->篇)</span></h2><div class="space-y-4"><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/lzsscompalgo/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">LZSS压缩算法</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">LZSS算法简介  LZSS算法是LZ77算法的改良版，由James A. Storer和Thomas Szymacski于1982年发表在ACM杂志上。LZSS算法充分地利用了位的标记，从而使得压缩效率相比较于LZ77而言，有了显著提高。    &gt; 参考维基百科   算法逻辑  在看本篇博文之...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/lz77compalgo/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">LZ77压缩算法</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">LZ77算法简介  LZ77算法是一种无损压缩算法，最早由两位以色列人于1977发表，它是一种典型的字典型压缩算法，目前几乎大多数的无损压缩算法都是基于这个LZ77算法，也就是在其基础上优化修改，此算法可以称得上是无损压缩算法界的鼻祖了。    &gt; 参考维基百科   算法逻辑  LZ77的算法核...</p></div></a></article></div></section><section id="随笔" class="mb-12 scroll-mt-24"><h2 class="text-2xl font-bold mb-6 pb-2 border-b border-gray-200">随笔<span class="text-gray-500 text-lg ml-2">(<!-- -->15<!-- -->篇)</span></h2><div class="space-y-4"><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/llmappfunctioncallingmech/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">LLM应用中的Function Calling机制</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">LLM应用中的Function Calling机制  LLM在当下应用非常广泛，从最常见的聊天问答（例如：Chatgpt，DeekSeek聊天），到基于内容检索的问答系统，处处可见它的身影。  在LLM（大型语言模型）应用开发中，Function Calling（函数调用）是一项强大的机制，它使...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/advlangmemmanagement/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">高级语言内存管理那些事：C++、Go 与 Rust 的对决</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">高级语言内存管理那些事：C++、Go 与 Rust 的对决  高级语言C++，Go，和Rust，是三种典型不同的内存管理风格的语言，它的风格也间接展示高级语言的发展历程，其中重要一项就是内存管理的变化。   一、前言：为什么内存管理很重要  内存管理是高级编程语言的基石，它影响程序的性能，安全和...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/openaiapirsh/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">OpenAI之OpenAPI初探</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">简介  人工智能并非是一个新鲜事物，早在多年前就就已有 TensorFlow，配合一套数值，矩阵，图形，和相关算法库，就可以实现一个简单的人工智能。  其实人工智能经历了许多年的发展，目前逐渐成熟，平时大众与其在生活的交叉并不多，所以难以引人注目，不过这次的 ChatGPT 展现出它强大的语言功...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/deploygitlabcerunner/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">玩转自搭建 GitLab 社区版</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">玩转自搭建 GitLab 社区版  本文的自搭建是基于docker容器技术而实现的，其中包括gitlab-ce和gitlab-runner两个部分。   什么是 GitLab  GitLab是一个代码仓库管理系统（它是一套开源项目），使用 Git 作为代码管理工具，集成 Web 管理的服务，Gi...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/codemodification/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">程序的代码修改问题</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">什么是代码改动  在软件项目中都存在一个生命周期，无论周期长短，都会涉及到代码改动，不管是对以前缺陷的修复，还是在敏捷开发中（每一个故事的迭代），都会或多或少地产生代码修改。     为什么会发生代码改动  代码修改其实是很常见的，但代码修改却是要尽量避免的，我们可以使用极限思维，一种是无比兼容...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/mongodbcloudcluster/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">MongoDB Cloud云平台简单使用简介</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">什么是MongoDB Cloud  MongoDB Cloud 的核心是  ，这是一个适用于现代应用程序的完全托管的云数据库。Atlas 是运行领先的现代数据库 MongoDB 的最佳方式。 的文档模型是一种更快的创新方式，可为数据库带来灵活性和易用性。    这是官网的简介，然后，再看一下它的...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/jnithreadsafe/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">JNI函数调用之线程安全问题</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">JNI 开发是什么  因本人以前工作中做过此类工作，再加上老同事的疑问，所以，今天抽出时间来探讨一下JNI的开发问题和特定细节（调用的线程安全问题），其实这种JNI层调用和任何其他语言调用C/C++层结构都差不多，比如说CGO，其涉及到Golang和C/C++层的调用，很多方面都存在类似之处。...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/redistributedservicesystem/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">分布式服务系统概述</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">什么是分布式系统  关于分布式系统的定义，应该都不会陌生，它就是一些独立的计算机集合，这些计算机也称为节点，为了完成一项事务，由这一组计算节点协作完成。  而分布式还有另外一个特点，就是用户几乎感知不到它是很多节点来完成一项事务的，甚至可以说，站在用户的角度，它和集中式系统几乎雷同，用户不会觉得...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/githuboauthappintro/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">GitHub的OAuth App的使用</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">Github的App有两种，一种是普通的App，一般用以制作自动化机器人，另一种是利用用户登录的App，它可以操作登录用户的Github里面的API定义的操作，包括：用户信息获取，仓库信息修改，用户信息修改，等等。   OAuth2的定义  OAuth（开放授权）是一个开放标准，允许用户授权第三方...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/linuxcoredumptofindbug/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">利用Linux的coredump机制快速定位程序BUG</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">什么是coredump？  Coredump是继承于UNIX系统的机制，它用于保存程序出错而崩溃时的栈，内存，PID，UID，GID，时间等等信息的快照，通常用于程序诊断和调试，Coredump的信息在计算机中一般保存三天左右（依系统设定而定），如果出错的程序BUG不及时查找，超过三天系统会吧这...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/enablesbonlinux/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">如何在 Linux 系统启用 UEFI 的 Secure Boot</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">概述  Secure Boot 作为 UEFI 的一个选项，它可以被设置为开启或关闭 ( 有少数的计算机里面， Secure Boot 被设置为开启，却不存在关闭它的选项，但系统主板内置有 Windows 系统的公钥证书签名，使其只能加载 Windows ，其他系统一律不以加载，用户没有选项，不...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/minix/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">如何将处于虚拟机中的MINIX系统中的文件复制到实体机的LINUX系统中来</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">问题来源  直接在虚拟机MINIX中阅读它的源代码，十分不便，修改调试做移植也非常困难，如果将MINIX系统中的部分源代码拷贝到实体机LINUX中，在LINUX系统中进行修改调试将会非常方便。  然而，MINIX系统是一种比较基本的系统，不能像vmware中使用Windows类系统那样，直接给它...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/linuxlatex/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">Linux环境搭建中文LaTeX排版系统</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">TeX系统简介  TeX系统最早由Stanford大学教授Donald E. Kunth制成的计算机排版软件系统，大家对他的《The Art of Computer Programming》应该不会陌生。  实际上，TeX的制成正是由于上述的书出版样本，令他不满意，所以激发了他创制了TeX排版系...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/vssqlserver2008/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">如何在Visual Studio 2010中使用SQL Server 2008</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">SQL Server是微软的数据库产品，也是一个较为众所周知的数据库产品，其中SQL Server 2000深受广大的用户的青睐，知名度较高，SQL Server 2008是其的后继产品之一，废话不多说了（本文不讨论VS或SQL Server的安装，假设预制环境就绪）。  首先在菜单的视图-&gt;其他...</p></div></a></article><article class="border rounded-lg overflow-hidden hover:shadow-md transition-shadow"><a class="block p-5" href="/post/mspeshell/"><div class="flex flex-col w-full"><h3 class="text-xl font-semibold hover:text-blue-600 transition-colors">PE文件壳的设计过程</h3><time dateTime="" class="text-sm text-gray-500 block mt-2"></time><p class="mt-3 text-gray-700">简介  今天来讨论一下PE文件的壳，壳主要用于PE文件的商业保护，以此达到软件不被暴掉的可能性，随着破解知识的普及，软件的壳也愈加复杂才可勉强不被暴。  壳的一个加载过程在许多书上都将过，这里就以图来复习一次：    !  这张图其实是一种情形，原程序被压缩引擎压过，还可以是在EXE文件上直接加...</p></div></a></article></div></section></div></main><footer class="mt-auto flex flex-col gap-[24px] items-center justify-center p-8"><div class="flex gap-[24px] flex-wrap items-center justify-center"><a class="flex items-center gap-2 hover:underline hover:underline-offset-4" href="/"><i class="bi bi-house" aria-hidden="true"></i>返回首页</a><a class="flex items-center gap-2 hover:underline hover:underline-offset-4" href="https://nextjs.org?utm_source=create-next-app&amp;utm_medium=appdir-template-tw&amp;utm_campaign=create-next-app" target="_blank" rel="noopener noreferrer"><i class="bi bi-globe text-gray-600"></i>Powered by NEXT.js</a></div><div class="pt-4 border-t border-gray-200 dark:border-gray-700 text-center text-gray-500 text-sm w-full max-w-lg">© 2013 – <!-- -->2025<!-- --> 陈祥</div></footer></div><!--$--><!--/$--><!--$--><!--/$--><script src="/_next/static/chunks/webpack-ede82f7d0ae11dac.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[7555,[],\"\"]\n3:I[1295,[],\"\"]\n4:I[415,[\"766\",\"static/chunks/766-f505dbd3efffaa4c.js\",\"226\",\"static/chunks/226-13d4d3f1fc18ceb6.js\",\"177\",\"static/chunks/app/layout-07bb40856ea7a35b.js\"],\"default\"]\n5:I[9243,[\"766\",\"static/chunks/766-f505dbd3efffaa4c.js\",\"226\",\"static/chunks/226-13d4d3f1fc18ceb6.js\",\"177\",\"static/chunks/app/layout-07bb40856ea7a35b.js\"],\"\"]\n8:I[9665,[],\"MetadataBoundary\"]\na:I[9665,[],\"OutletBoundary\"]\nd:I[4911,[],\"AsyncMetadataOutlet\"]\nf:I[9665,[],\"ViewportBoundary\"]\n11:I[6614,[],\"\"]\n:HL[\"/_next/static/css/283bb1ed86b49fd2.css\",\"style\"]\n:HL[\"/_next/static/css/09ec4099fb721b31.css\",\"style\"]\n:HL[\"/_next/static/css/09dfadb69bdaa005.css\",\"style\"]\n:HL[\"/_next/static/css/acd799ec929775fa.css\",\"style\"]\n6:T4a2,\n          function copyCode(button) {\n            // Find the code element within the same wrapper\n            const codeWrapper = button.closest('.code-block-wrapper');\n            if (!codeWrapper) return;\n            \n            const codeElement = codeWrapper.querySelector('code');\n            if (!codeElement) return;\n            \n            // Get the text content\n            const text = codeElement.textContent;\n            \n            // Use the clipboard API to copy the text\n            navigator.clipboard.writeText(text).then(() =\u003e {\n              // Update the button state to show \"Copied!\"\n              button.setAttribute('data-copy-state', 'copied');\n              const buttonText = button.querySelector('.copy-button-text');\n              if (buttonText) buttonText.textContent = 'Copied!';\n              \n              // Reset after 2 seconds\n              setTimeout(() =\u003e {\n                button.setAttribute('data-copy-state', 'copy');\n                if (buttonText) buttonText.textContent = 'Copy';\n              }, 2000);\n            }).catch(err =\u003e {\n              console.error('Failed to copy text: ', err);\n            });\n          }\n          "])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ppQBZ_hjs78de-RY41wpR\",\"p\":\"\",\"c\":[\"\",\"categories\",\"\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"categories\",{\"children\":[\"__PAGE__\",{}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/283bb1ed86b49fd2.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09ec4099fb721b31.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/09dfadb69bdaa005.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"antialiased relative\",\"children\":[[\"$\",\"div\",null,{\"className\":\"fixed top-4 right-4 z-50\",\"children\":[\"$\",\"a\",null,{\"href\":\"https://github.com/hchen90\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"className\":\"flex items-center justify-center p-2 bg-white rounded-full shadow-md hover:shadow-lg transition-shadow duration-300\",\"title\":\"Visit my GitHub profile\",\"children\":[\"$\",\"svg\",null,{\"xmlns\":\"http://www.w3.org/2000/svg\",\"width\":\"24\",\"height\":\"24\",\"viewBox\":\"0 0 24 24\",\"fill\":\"currentColor\",\"children\":[\"$\",\"path\",null,{\"d\":\"M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z\"}]}]}]}],[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}],[\"$\",\"$L4\",null,{}],[\"$\",\"$L5\",null,{\"id\":\"code-copy\",\"children\":\"$6\"}]]}]}]]}],{\"children\":[\"categories\",[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L7\",[\"$\",\"$L8\",null,{\"children\":\"$L9\"}],[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/acd799ec929775fa.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"$La\",null,{\"children\":[\"$Lb\",\"$Lc\",[\"$\",\"$Ld\",null,{\"promise\":\"$@e\"}]]}]]}],{},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"lG7iKYaX1ILM8ioqXicrS\",{\"children\":[[\"$\",\"$Lf\",null,{\"children\":\"$L10\"}],null]}],null]}],false]],\"m\":\"$undefined\",\"G\":[\"$11\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"12:\"$Sreact.suspense\"\n13:I[4911,[],\"AsyncMetadata\"]\n15:I[4363,[\"874\",\"static/chunks/874-e909718850e7282e.js\",\"379\",\"static/chunks/app/categories/page-0318fd5069c95311.js\"],\"default\"]\n16:I[6874,[\"874\",\"static/chunks/874-e909718850e7282e.js\",\"379\",\"static/chunks/app/categories/page-0318fd5069c95311.js\"],\"\"]\n9:[\"$\",\"$12\",null,{\"fallback\":null,\"children\":[\"$\",\"$L13\",null,{\"promise\":\"$@14\"}]}]\n"])</script><script>self.__next_f.push([1,"7:[\"$\",\"div\",null,{\"className\":\"flex flex-col min-h-screen font-[family-name:var(--font-geist-sans)]\",\"children\":[[\"$\",\"$L15\",null,{\"title\":\"文章分类\"}],[\"$\",\"main\",null,{\"className\":\"flex flex-col gap-[32px] items-center w-full max-w-4xl mx-auto p-8 sm:p-20\",\"children\":[\"$\",\"div\",null,{\"className\":\"w-full\",\"children\":[[\"$\",\"div\",null,{\"className\":\"mb-8\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"text-xl font-semibold mb-4\",\"children\":\"所有分类\"}],[\"$\",\"div\",null,{\"className\":\"flex flex-wrap gap-3\",\"children\":[[\"$\",\"a\",\"总结\",{\"href\":\"#总结\",\"className\":\"bg-gray-100 hover:bg-gray-200 px-4 py-2 rounded-full text-sm transition-colors\",\"children\":[\"总结\",\" (\",10,\")\"]}],[\"$\",\"a\",\"算法\",{\"href\":\"#算法\",\"className\":\"bg-gray-100 hover:bg-gray-200 px-4 py-2 rounded-full text-sm transition-colors\",\"children\":[\"算法\",\" (\",2,\")\"]}],[\"$\",\"a\",\"随笔\",{\"href\":\"#随笔\",\"className\":\"bg-gray-100 hover:bg-gray-200 px-4 py-2 rounded-full text-sm transition-colors\",\"children\":[\"随笔\",\" (\",15,\")\"]}]]}]]}],[[\"$\",\"section\",\"总结\",{\"id\":\"总结\",\"className\":\"mb-12 scroll-mt-24\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"text-2xl font-bold mb-6 pb-2 border-b border-gray-200\",\"children\":[\"总结\",[\"$\",\"span\",null,{\"className\":\"text-gray-500 text-lg ml-2\",\"children\":[\"(\",10,\"篇)\"]}]]}],[\"$\",\"div\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"article\",\"mltraningfittingissues\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/mltraningfittingissues\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"机器学习中模型训练的拟合问题\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"机器学习中模型训练的拟合问题   拟合问题简介  拟合问题可以归纳为模型对数据的规律学得好不好，对于学得好的就称为拟合适中，对于学得不好的可以分类两种：过拟合，欠拟合。  拟合就是用模型函数去逼近数据之间的关系，拟合程度反映了模型函数和实际数据的贴合程度。   过拟合问题  过拟合的意思是模型在...\"}],false]}]}]}],[\"$\",\"article\",\"ai2-studylog-ml\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/ai2-studylog-ml\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"人工智能笔记 - 机器学习\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"人工智能 - 机器学习  人工智能的基础是机器学习，顾名思义就是让机器能够处理数据，并在处理的数据中进行学习，从而能够自主地做出决策。简单来说，机器学习是让机器能够在不需要特别编程的情况下进行学习和改进。  而机器学习，大体上分为三种，分别为：监督式学习，无监督式学习，和深度学习。     监督...\"}],false]}]}]}],[\"$\",\"article\",\"ai1-studylog-dataanalysis\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/ai1-studylog-dataanalysis\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"人工智能笔记 - 数据分析和决策\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"人工智能 - 数据分析和决策  这部分主要分为四个层次：  - 数据收集 - 数据清理 - 数据分析 - 决策     数据收集  在人工智能领域数据收集是至关重要的一个环节，它是用于训练模式的输入来源。  作为基础的概念复习，数据收集无非是把目标进行采样，同时我们需要使用科学的方法使样本接近于...\"}],false]}]}]}],[\"$\",\"article\",\"linuxstartup\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/linuxstartup\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"Linux系统启动流程\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"内核加载  在里面我说明过计算机如何从远古到近代的启动流程，然后，走到操作系统一层的时候就没有深入阐述了，在这篇博文我将以Linux系统为例来叙述操作系统是如何启动的。  通常在系统/boot目录下放着内核文件，如下：  shell initramfs-linux.img vmlinuz-lin...\"}],false]}]}]}],[\"$\",\"article\",\"systemstartup\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/systemstartup\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"计算机系统启动流程\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"远古时代   这个时期，计算机是处于电气化高度相关的环境下，几乎没有软件的概念（这里有点瑕疵，稍后补充）。  计算机这个时候会进行一系列针对硬件的自测试，尤其检测一些必要硬件是否可用，这个过程成为POST自检，如果检测通过就会进行下一个步骤：BIOS模式，或者UEFI模式。    \u003e 一般计算机...\"}],false]}]}]}],[\"$\",\"article\",\"linuxsystemasyncio\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/linuxsystemasyncio\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"Linux系统中的异步I/O问题\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"Linux系统中的异步I/O问题  系统编程中，I/O（输入/输出）模型决定了如何和数据进行交互，它对整个系统性能影响至关重要。I/O模型会直接影响如下几大方面：   吞吐量  机器资源利用率，例如：CPU使用率  系统的可拓展性  编程复杂性  I/O模型在网络编程中，是高性能服务器的基础，如...\"}],false]}]}]}],[\"$\",\"article\",\"softwaredesignpattern4\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/softwaredesignpattern4\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"软件设计模式 - 行为模式\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"软件设计模式 - 行为模式  行为模式负责对象之间的高效沟通和职责委派。  行为模式包括：责任链，命令，迭代器，中介者，备忘录，观察者，状态，策略，模版方法，访问者。     责任链模式（Chain of Responsibility/CoR）  责任链模式允许你将请求沿着处理者链进行传递。每个...\"}],false]}]}]}],[\"$\",\"article\",\"softwaredesignpattern3\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/softwaredesignpattern3\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"软件设计模式 - 结构型模式\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"软件设计模式 - 结构型模式  结构型模式介绍类和对象的组装方式，同时保持较大的灵活性和高效性。  结构型模式包括：适配器，桥接，组合，装饰，外观，享元，代理。     适配器模式（Adapter）  适配器模式是为了解决不同接口之间的适配问题。  适配器通常分为两类：对象适配器，类适配器。...\"}],false]}]}]}],[\"$\",\"article\",\"softwaredesignpattern2\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/softwaredesignpattern2\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"软件设计模式 - 创建型模式\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"软件设计模式 - 创建型模式  创建型模式分为：工厂方法，抽象工厂，生成器，原型，单例。     工厂方法模式（Factory Method）  工厂方法模式是一种在父类声明方法，在子类实例化该对象的方法。在C++中通常以虚函数形式来表示，在其他语言，例如Java中则是抽象函数来表示。  工厂方...\"}],false]}]}]}],[\"$\",\"article\",\"softwaredesignpattern1\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/softwaredesignpattern1\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"软件设计模式简介\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"软件设计模式简介  软件设计模式属于软件工程领域的解决问题的基本方法，它提供了一种合理地达成目标的处理步骤。本文主要简单提出为何需要它，它的作用，以及它的主要组成元素。     什么是软件设计模式  软件设计模式其实就是为了解决问题，而制定的一种抽象层面的合理地达到目标的处理步骤。  设计模式的...\"}],false]}]}]}]]}]]}],[\"$\",\"section\",\"算法\",{\"id\":\"算法\",\"className\":\"mb-12 scroll-mt-24\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"text-2xl font-bold mb-6 pb-2 border-b border-gray-200\",\"children\":[\"算法\",[\"$\",\"span\",null,{\"className\":\"text-gray-500 text-lg ml-2\",\"children\":[\"(\",2,\"篇)\"]}]]}],[\"$\",\"div\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"article\",\"lzsscompalgo\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/lzsscompalgo\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"LZSS压缩算法\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"LZSS算法简介  LZSS算法是LZ77算法的改良版，由James A. Storer和Thomas Szymacski于1982年发表在ACM杂志上。LZSS算法充分地利用了位的标记，从而使得压缩效率相比较于LZ77而言，有了显著提高。    \u003e 参考维基百科   算法逻辑  在看本篇博文之...\"}],false]}]}]}],[\"$\",\"article\",\"lz77compalgo\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/lz77compalgo\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"LZ77压缩算法\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"LZ77算法简介  LZ77算法是一种无损压缩算法，最早由两位以色列人于1977发表，它是一种典型的字典型压缩算法，目前几乎大多数的无损压缩算法都是基于这个LZ77算法，也就是在其基础上优化修改，此算法可以称得上是无损压缩算法界的鼻祖了。    \u003e 参考维基百科   算法逻辑  LZ77的算法核...\"}],false]}]}]}]]}]]}],[\"$\",\"section\",\"随笔\",{\"id\":\"随笔\",\"className\":\"mb-12 scroll-mt-24\",\"children\":[[\"$\",\"h2\",null,{\"className\":\"text-2xl font-bold mb-6 pb-2 border-b border-gray-200\",\"children\":[\"随笔\",[\"$\",\"span\",null,{\"className\":\"text-gray-500 text-lg ml-2\",\"children\":[\"(\",15,\"篇)\"]}]]}],[\"$\",\"div\",null,{\"className\":\"space-y-4\",\"children\":[[\"$\",\"article\",\"llmappfunctioncallingmech\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/llmappfunctioncallingmech\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"LLM应用中的Function Calling机制\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"LLM应用中的Function Calling机制  LLM在当下应用非常广泛，从最常见的聊天问答（例如：Chatgpt，DeekSeek聊天），到基于内容检索的问答系统，处处可见它的身影。  在LLM（大型语言模型）应用开发中，Function Calling（函数调用）是一项强大的机制，它使...\"}],false]}]}]}],[\"$\",\"article\",\"advlangmemmanagement\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/advlangmemmanagement\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"高级语言内存管理那些事：C++、Go 与 Rust 的对决\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"高级语言内存管理那些事：C++、Go 与 Rust 的对决  高级语言C++，Go，和Rust，是三种典型不同的内存管理风格的语言，它的风格也间接展示高级语言的发展历程，其中重要一项就是内存管理的变化。   一、前言：为什么内存管理很重要  内存管理是高级编程语言的基石，它影响程序的性能，安全和...\"}],false]}]}]}],[\"$\",\"article\",\"openaiapirsh\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/openaiapirsh\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"OpenAI之OpenAPI初探\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"简介  人工智能并非是一个新鲜事物，早在多年前就就已有 TensorFlow，配合一套数值，矩阵，图形，和相关算法库，就可以实现一个简单的人工智能。  其实人工智能经历了许多年的发展，目前逐渐成熟，平时大众与其在生活的交叉并不多，所以难以引人注目，不过这次的 ChatGPT 展现出它强大的语言功...\"}],false]}]}]}],[\"$\",\"article\",\"deploygitlabcerunner\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/deploygitlabcerunner\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"玩转自搭建 GitLab 社区版\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"玩转自搭建 GitLab 社区版  本文的自搭建是基于docker容器技术而实现的，其中包括gitlab-ce和gitlab-runner两个部分。   什么是 GitLab  GitLab是一个代码仓库管理系统（它是一套开源项目），使用 Git 作为代码管理工具，集成 Web 管理的服务，Gi...\"}],false]}]}]}],[\"$\",\"article\",\"codemodification\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/codemodification\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"程序的代码修改问题\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"什么是代码改动  在软件项目中都存在一个生命周期，无论周期长短，都会涉及到代码改动，不管是对以前缺陷的修复，还是在敏捷开发中（每一个故事的迭代），都会或多或少地产生代码修改。     为什么会发生代码改动  代码修改其实是很常见的，但代码修改却是要尽量避免的，我们可以使用极限思维，一种是无比兼容...\"}],false]}]}]}],[\"$\",\"article\",\"mongodbcloudcluster\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/mongodbcloudcluster\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"MongoDB Cloud云平台简单使用简介\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"什么是MongoDB Cloud  MongoDB Cloud 的核心是  ，这是一个适用于现代应用程序的完全托管的云数据库。Atlas 是运行领先的现代数据库 MongoDB 的最佳方式。 的文档模型是一种更快的创新方式，可为数据库带来灵活性和易用性。    这是官网的简介，然后，再看一下它的...\"}],false]}]}]}],[\"$\",\"article\",\"jnithreadsafe\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/jnithreadsafe\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"JNI函数调用之线程安全问题\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"JNI 开发是什么  因本人以前工作中做过此类工作，再加上老同事的疑问，所以，今天抽出时间来探讨一下JNI的开发问题和特定细节（调用的线程安全问题），其实这种JNI层调用和任何其他语言调用C/C++层结构都差不多，比如说CGO，其涉及到Golang和C/C++层的调用，很多方面都存在类似之处。...\"}],false]}]}]}],[\"$\",\"article\",\"redistributedservicesystem\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/redistributedservicesystem\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"分布式服务系统概述\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"什么是分布式系统  关于分布式系统的定义，应该都不会陌生，它就是一些独立的计算机集合，这些计算机也称为节点，为了完成一项事务，由这一组计算节点协作完成。  而分布式还有另外一个特点，就是用户几乎感知不到它是很多节点来完成一项事务的，甚至可以说，站在用户的角度，它和集中式系统几乎雷同，用户不会觉得...\"}],false]}]}]}],[\"$\",\"article\",\"githuboauthappintro\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/githuboauthappintro\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"GitHub的OAuth App的使用\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"Github的App有两种，一种是普通的App，一般用以制作自动化机器人，另一种是利用用户登录的App，它可以操作登录用户的Github里面的API定义的操作，包括：用户信息获取，仓库信息修改，用户信息修改，等等。   OAuth2的定义  OAuth（开放授权）是一个开放标准，允许用户授权第三方...\"}],false]}]}]}],[\"$\",\"article\",\"linuxcoredumptofindbug\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/linuxcoredumptofindbug\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"利用Linux的coredump机制快速定位程序BUG\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"什么是coredump？  Coredump是继承于UNIX系统的机制，它用于保存程序出错而崩溃时的栈，内存，PID，UID，GID，时间等等信息的快照，通常用于程序诊断和调试，Coredump的信息在计算机中一般保存三天左右（依系统设定而定），如果出错的程序BUG不及时查找，超过三天系统会吧这...\"}],false]}]}]}],[\"$\",\"article\",\"enablesbonlinux\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/enablesbonlinux\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"如何在 Linux 系统启用 UEFI 的 Secure Boot\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"概述  Secure Boot 作为 UEFI 的一个选项，它可以被设置为开启或关闭 ( 有少数的计算机里面， Secure Boot 被设置为开启，却不存在关闭它的选项，但系统主板内置有 Windows 系统的公钥证书签名，使其只能加载 Windows ，其他系统一律不以加载，用户没有选项，不...\"}],false]}]}]}],[\"$\",\"article\",\"minix\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/minix\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"如何将处于虚拟机中的MINIX系统中的文件复制到实体机的LINUX系统中来\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"问题来源  直接在虚拟机MINIX中阅读它的源代码，十分不便，修改调试做移植也非常困难，如果将MINIX系统中的部分源代码拷贝到实体机LINUX中，在LINUX系统中进行修改调试将会非常方便。  然而，MINIX系统是一种比较基本的系统，不能像vmware中使用Windows类系统那样，直接给它...\"}],false]}]}]}],[\"$\",\"article\",\"linuxlatex\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/linuxlatex\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"Linux环境搭建中文LaTeX排版系统\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"TeX系统简介  TeX系统最早由Stanford大学教授Donald E. Kunth制成的计算机排版软件系统，大家对他的《The Art of Computer Programming》应该不会陌生。  实际上，TeX的制成正是由于上述的书出版样本，令他不满意，所以激发了他创制了TeX排版系...\"}],false]}]}]}],[\"$\",\"article\",\"vssqlserver2008\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/vssqlserver2008\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"如何在Visual Studio 2010中使用SQL Server 2008\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"SQL Server是微软的数据库产品，也是一个较为众所周知的数据库产品，其中SQL Server 2000深受广大的用户的青睐，知名度较高，SQL Server 2008是其的后继产品之一，废话不多说了（本文不讨论VS或SQL Server的安装，假设预制环境就绪）。  首先在菜单的视图-\u003e其他...\"}],false]}]}]}],[\"$\",\"article\",\"mspeshell\",{\"className\":\"border rounded-lg overflow-hidden hover:shadow-md transition-shadow\",\"children\":[\"$\",\"$L16\",null,{\"href\":\"/post/mspeshell\",\"className\":\"block p-5\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full\",\"children\":[[\"$\",\"h3\",null,{\"className\":\"text-xl font-semibold hover:text-blue-600 transition-colors\",\"children\":\"PE文件壳的设计过程\"}],[\"$\",\"time\",null,{\"dateTime\":\"\",\"className\":\"text-sm text-gray-500 block mt-2\",\"children\":\"\"}],[\"$\",\"p\",null,{\"className\":\"mt-3 text-gray-700\",\"children\":\"简介  今天来讨论一下PE文件的壳，壳主要用于PE文件的商业保护，以此达到软件不被暴掉的可能性，随着破解知识的普及，软件的壳也愈加复杂才可勉强不被暴。  壳的一个加载过程在许多书上都将过，这里就以图来复习一次：    !  这张图其实是一种情形，原程序被压缩引擎压过，还可以是在EXE文件上直接加...\"}],false]}]}]}]]}]]}]]]}]}],[\"$\",\"footer\",null,{\"className\":\"mt-auto flex flex-col gap-[24px] items-center justify-center p-8\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex gap-[24px] flex-wrap items-center justify-center\",\"children\":[[\"$\",\"$L16\",null,{\"href\":\"/\",\"className\":\"flex items-center gap-2 hover:underline hover:underline-offset-4\",\"children\":[[\"$\",\"i\",null,{\"className\":\"bi bi-house\",\"aria-hidden\":\"true\"}],\"返回首页\"]}],[\"$\",\"a\",null,{\"className\":\"flex items-center gap-2 hover:underline hover:underline-offset-4\",\"href\":\"https://nextjs.org?utm_source=create-next-app\u0026utm_medium=appdir-template-tw\u0026utm_campaign=create-next-app\",\"target\":\"_blank\",\"rel\":\"noopener noreferrer\",\"children\":[[\"$\",\"i\",null,{\"className\":\"bi bi-globe text-gray-600\"}],\"Powered by NEXT.js\"]}]]}],[\"$\",\"div\",null,{\"className\":\"pt-4 border-t border-gray-200 dark:border-gray-700 text-center text-gray-500 text-sm w-full max-w-lg\",\"children\":[\"© 2013 – \",2025,\" 陈祥\"]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"c:null\n"])</script><script>self.__next_f.push([1,"10:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\nb:null\n"])</script><script>self.__next_f.push([1,"14:{\"metadata\":[[\"$\",\"title\",\"0\",{\"children\":\"HCHEN90 博客\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"HCHEN90 博客\"}],[\"$\",\"link\",\"2\",{\"rel\":\"alternate\",\"type\":\"application/atom+xml\",\"href\":\"https://hchen90.top/atom.xml\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]],\"error\":null,\"digest\":\"$undefined\"}\ne:{\"metadata\":\"$14:metadata\",\"error\":null,\"digest\":\"$undefined\"}\n"])</script></body></html>