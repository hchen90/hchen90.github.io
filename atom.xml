<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hchen90.top</id>
    <title>HCHEN90 博客</title>
    <updated>2025-04-20T02:12:08.000Z</updated>
    <generator>Feed for Node.js</generator>
    <author>
        <name>Hsiang Chen</name>
        <email>master@hchen90.top</email>
        <uri>https://hchen90.top</uri>
    </author>
    <link rel="alternate" href="https://hchen90.top"/>
    <link rel="self" href="https://hchen90.top/atom.xml"/>
    <subtitle>HCHEN90 博客</subtitle>
    <logo>https://hchen90.top/favicon.ico</logo>
    <icon>https://hchen90.top/favicon.ico</icon>
    <rights>All rights reserved 2025, Hsiang Chen</rights>
    <entry>
        <title type="html"><![CDATA[LLM应用中的Function Calling机制]]></title>
        <id>https://hchen90.top/post/llmappfunctioncallingmech</id>
        <link href="https://hchen90.top/post/llmappfunctioncallingmech"/>
        <updated>2025-04-20T02:12:08.000Z</updated>
        <summary type="html"><![CDATA[
# LLM应用中的Function Calling机制

LLM在当下应用非常广泛，从最常见的聊天问答（例如：Chatgpt，DeekSeek聊天），到基于内容检索的问答系统，处处可见它的身影。

在LLM（大型语言模型）应用开发中，**Function Calling**（函数调用）是一项强大的机制，它使得大模型不再局限于单纯的文本生成，而是能够与外部世界进行更深层次的交互。通过这种机制，我们可以赋予LLM调用特定工具或API的能力，从而解锁无数复杂且实用的应用场景。

## 什么是Function Calling

简单来说，Function Calling是一种让LLM模型理解并生成特...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[机器学习中模型训练的拟合问题]]></title>
        <id>https://hchen90.top/post/mltraningfittingissues</id>
        <link href="https://hchen90.top/post/mltraningfittingissues"/>
        <updated>2024-09-15T20:03:12.000Z</updated>
        <summary type="html"><![CDATA[
# 机器学习中模型训练的拟合问题

## 拟合问题简介

拟合问题可以归纳为模型对数据的规律学得好不好，对于学得好的就称为拟合适中，对于学得不好的可以分类两种：过拟合，欠拟合。

拟合就是用模型函数去逼近数据之间的关系，拟合程度反映了模型函数和实际数据的贴合程度。

## 过拟合问题

过拟合的意思是模型在数据上表现非常好，但是在测试数据上表现很差。通常是原因是在训练集合上拟合太高，以至于学习到了集合上的噪音细节，导致推广到新数据时出现很大的偏差。

### 过拟合现象说明

下面举例说明，以bigml上的训练实例说明，下面的案例是一个用于预测预定酒店用户，是否会预定后又取消订单的预测模型。...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[人工智能笔记 - 机器学习]]></title>
        <id>https://hchen90.top/post/ai2-studylog-ml</id>
        <link href="https://hchen90.top/post/ai2-studylog-ml"/>
        <updated>2024-07-02T11:36:12.000Z</updated>
        <summary type="html"><![CDATA[
# 人工智能 - 机器学习

人工智能的基础是机器学习，顾名思义就是让机器能够处理数据，并在处理的数据中进行学习，从而能够自主地做出决策。简单来说，机器学习是让机器能够在不需要特别编程的情况下进行学习和改进。

而机器学习，大体上分为三种，分别为：监督式学习，无监督式学习，和深度学习。



## 监督式学习

监督式学习是一种机器学习方法，它通过使用带有标签的训练数据（也就是已知的输入和输出）来学习一种模型或函数。然后，这种模型或函数可以用于预测新的、未知的数据。在训练过程中，如果模型的预测结果与实际结果出现差异，就会进行调整，以减小这种差异。这种学习方式就好比有一位“监督者”指导机器如何...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[人工智能笔记 - 数据分析和决策]]></title>
        <id>https://hchen90.top/post/ai1-studylog-dataanalysis</id>
        <link href="https://hchen90.top/post/ai1-studylog-dataanalysis"/>
        <updated>2024-06-12T21:36:12.000Z</updated>
        <summary type="html"><![CDATA[
# 人工智能 - 数据分析和决策

这部分主要分为四个层次：

- 数据收集
- 数据清理
- 数据分析
- 决策



## 数据收集

在人工智能领域数据收集是至关重要的一个环节，它是用于训练模式的输入来源。

作为基础的概念复习，数据收集无非是把目标进行采样，同时我们需要使用科学的方法使样本接近于目标。

作为采样的方法，通常可以分为三种：

1. 简单随机采样
2. 系统采样
3. 分层采样

简单随机采样最好理解，使用随机数发生器对目标空间随机采取样本；对于系统采样，通常强调一种顺序性质；但是往往我们的真实世界并不都是顺序可以表示的，所以这时可以使用分层采样来进行，它先对目标进行分...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[高级语言内存管理那些事：C++、Go 与 Rust 的对决]]></title>
        <id>https://hchen90.top/post/advlangmemmanagement</id>
        <link href="https://hchen90.top/post/advlangmemmanagement"/>
        <updated>2024-04-20T20:14:02.000Z</updated>
        <summary type="html"><![CDATA[
# 高级语言内存管理那些事：C++、Go 与 Rust 的对决

高级语言C++，Go，和Rust，是三种典型不同的内存管理风格的语言，它的风格也间接展示高级语言的发展历程，其中重要一项就是内存管理的变化。

## 一、前言：为什么内存管理很重要

内存管理是高级编程语言的基石，它影响程序的性能，安全和稳定。

* 性能问题：编制不良的程序会申请大量的内存，但是却很少使用，导致实际使用的内存利用率很低，这样的程序会导致性能问题。
* 安全问题：安全性问题主要是申请的内存没有恰当释放引起的，然后引用它的指针被其他值覆盖，导致它指向的内存，以后永远不会被访问，这种问题较内存泄露，内存泄露的内存区...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[OpenAI之OpenAPI初探]]></title>
        <id>https://hchen90.top/post/openaiapirsh</id>
        <link href="https://hchen90.top/post/openaiapirsh"/>
        <updated>2023-03-28T22:11:08.000Z</updated>
        <summary type="html"><![CDATA[
# 简介

人工智能并非是一个新鲜事物，早在多年前就就已有 TensorFlow，配合一套数值，矩阵，图形，和相关算法库，就可以实现一个简单的人工智能。

其实人工智能经历了许多年的发展，目前逐渐成熟，平时大众与其在生活的交叉并不多，所以难以引人注目，不过这次的 ChatGPT 展现出它强大的语言功能，配合逐渐的人工智能算法，让它大火了一把。



对于 ChatGPT 可以直接从[网页访问](https://chat.openai.com/)，打开后可以用聊天方式进行问答。

这种问答的通过调用核心的服务（引擎）来完成，OpenAI 把这部分以 API 形式展现出来的，在网页端即是如此，通...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[玩转自搭建 GitLab 社区版]]></title>
        <id>https://hchen90.top/post/deploygitlabcerunner</id>
        <link href="https://hchen90.top/post/deploygitlabcerunner"/>
        <updated>2022-07-02T10:03:12.000Z</updated>
        <summary type="html"><![CDATA[
# 玩转自搭建 GitLab 社区版

本文的自搭建是基于docker容器技术而实现的，其中包括`gitlab-ce`和`gitlab-runner`两个部分。

## 什么是 GitLab

**GitLab**是一个代码仓库管理系统（它是一套开源项目），使用 Git 作为代码管理工具，集成 Web 管理的服务，**GitLab**被广泛用于基于 Git 代码管理平台，在很多一些结构不是复杂的组织结构中都会优先使用它。



## 它能做什么

**GitLab**是代码仓库管理系统，它实现了一个更加界面友好的交互方式来对项目代码进行管理，除此之外，它还可以集成CI/CD特性，通过部署 *...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[程序的代码修改问题]]></title>
        <id>https://hchen90.top/post/codemodification</id>
        <link href="https://hchen90.top/post/codemodification"/>
        <updated>2022-06-11T08:53:02.000Z</updated>
        <summary type="html"><![CDATA[
# 什么是代码改动

在软件项目中都存在一个生命周期，无论周期长短，都会涉及到代码改动，不管是对以前缺陷的修复，还是在敏捷开发中（每一个故事的迭代），都会或多或少地产生代码修改。



# 为什么会发生代码改动

代码修改其实是很常见的，但代码修改却是要尽量避免的，我们可以使用极限思维，一种是无比兼容的代码，它不需要任何修改，即可满足业务需求，这种代码在我们生活中是可见的，如果把业务代码不算作真正的代码，而是业务逻辑流程，那么脚本驱动的服务框架，其底层是用高效的原生语言编写（例如：C++），其使用通用设计模型和抽象方法，这种底层很少改动，上层的脚本业务受之驱动，那么这种代码就是几乎不需要修改...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB Cloud云平台简单使用简介]]></title>
        <id>https://hchen90.top/post/mongodbcloudcluster</id>
        <link href="https://hchen90.top/post/mongodbcloudcluster"/>
        <updated>2022-04-03T14:22:06.000Z</updated>
        <summary type="html"><![CDATA[
# 什么是MongoDB Cloud

MongoDB Cloud 的核心是 [MongoDB Atlas](https://www.mongodb.com/zh-cn/cloud/atlas) ，这是一个适用于现代应用程序的完全托管的云数据库。Atlas 是运行领先的现代数据库 MongoDB 的最佳方式。[MongoDB](https://www.mongodb.com/zh-cn/what-is-mongodb) 的文档模型是一种更快的创新方式，可为数据库带来灵活性和易用性。



这是官网的简介，然后，再看一下它的价格，如下图：

![price](price.png)

可以看到，...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[JNI函数调用之线程安全问题]]></title>
        <id>https://hchen90.top/post/jnithreadsafe</id>
        <link href="https://hchen90.top/post/jnithreadsafe"/>
        <updated>2021-11-29T23:03:02.000Z</updated>
        <summary type="html"><![CDATA[
# JNI 开发是什么

因本人以前工作中做过此类工作，再加上老同事的疑问，所以，今天抽出时间来探讨一下JNI的开发问题和特定细节（调用的线程安全问题），其实这种JNI层调用和任何其他语言调用C/C++层结构都差不多，比如说CGO，其涉及到Golang和C/C++层的调用，很多方面都存在类似之处。

JNI开发是使用Java提供的本地化接口，比如C/C++（也可以是其他语言），允许Java虚拟机里面的已经编译的代码和外界的本地化代码进行交互。



> 因为Java是推崇平台可移植性的，本地化代码看起来破坏了可移植性，但是很多时候却是不可避免的，因为很多时候Java是无法实现一些比较底层功能...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[分布式服务系统概述]]></title>
        <id>https://hchen90.top/post/redistributedservicesystem</id>
        <link href="https://hchen90.top/post/redistributedservicesystem"/>
        <updated>2020-12-20T10:05:12.000Z</updated>
        <summary type="html"><![CDATA[
# 什么是分布式系统

关于分布式系统的定义，应该都不会陌生，它就是一些独立的计算机集合，这些计算机也称为节点，为了完成一项事务，由这一组计算节点协作完成。

而分布式还有另外一个特点，就是用户几乎感知不到它是很多节点来完成一项事务的，甚至可以说，站在用户的角度，它和集中式系统几乎雷同，用户不会觉得他/她在请求的是集中式系统，亦或分布式系统，这是分布式系统的透明性。



## 和传统的集中式C/S系统对比

首先看一下传统的集中式C/S系统：

![Tra-CS-System](tra-cs-mod.png)

而对于分布式的系统而言，它是这样的：

![Redi-System](redi...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[GitHub的OAuth App的使用]]></title>
        <id>https://hchen90.top/post/githuboauthappintro</id>
        <link href="https://hchen90.top/post/githuboauthappintro"/>
        <updated>2020-04-15T14:23:07.000Z</updated>
        <summary type="html"><![CDATA[
Github的App有两种，一种是普通的App，一般用以制作自动化机器人，另一种是利用用户登录的App，它可以操作登录用户的Github里面的API定义的操作，包括：用户信息获取，仓库信息修改，用户信息修改，等等。

# OAuth2的定义

OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0 是 OAuth 协议的延续版本，但不向后兼容 OAuth 1.0，即完全废止了 OAuth1.0。



# Github OAuth App

通过 OAuth2...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用Linux的coredump机制快速定位程序BUG]]></title>
        <id>https://hchen90.top/post/linuxcoredumptofindbug</id>
        <link href="https://hchen90.top/post/linuxcoredumptofindbug"/>
        <updated>2019-11-12T09:12:29.000Z</updated>
        <summary type="html"><![CDATA[
# 什么是coredump？

**Coredump**是继承于UNIX系统的机制，它用于保存程序出错而崩溃时的栈，内存，PID，UID，GID，时间等等信息的快照，通常用于程序诊断和调试，**Coredump**的信息在计算机中一般保存三天左右（依系统设定而定），如果出错的程序BUG不及时查找，超过三天系统会吧这些**Coredump**删除。



# 需要些什么工具？

一般来说，只需要objdump和gdb即可，诊断时源代码以原始为佳（core dumped时的未修改的代码）。

# 案例分析

下面是我展示的一个出错事例，供参考观摩。

## 程序崩溃了

这个程序运行时，一点问题...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux系统启动流程]]></title>
        <id>https://hchen90.top/post/linuxstartup</id>
        <link href="https://hchen90.top/post/linuxstartup"/>
        <updated>2018-06-24T11:50:03.000Z</updated>
        <summary type="html"><![CDATA[
# 内核加载

在[上篇博文](/2018/06/16/systemstartup)里面我说明过计算机如何从远古到近代的启动流程，然后，走到操作系统一层的时候就没有深入阐述了，在这篇博文我将以Linux系统为例来叙述操作系统是如何启动的。

通常在系统`/boot`目录下放着内核文件，如下：

```shell
initramfs-linux.img
vmlinuz-linux
```

GRUB（或者LILO）加载内核的时候，会把`vmlinuz-linux`映射到内存并会把它的一个初始根目录的文件镜像（`initramfs-linux.img`）作为文件系统加载到内存，系统会从这个迷你的...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机系统启动流程]]></title>
        <id>https://hchen90.top/post/systemstartup</id>
        <link href="https://hchen90.top/post/systemstartup"/>
        <updated>2018-06-16T20:40:10.000Z</updated>
        <summary type="html"><![CDATA[
# 远古时代

 这个时期，计算机是处于电气化高度相关的环境下，几乎没有软件的概念（这里有点瑕疵，稍后补充）。

计算机这个时候会进行一系列针对硬件的自测试，尤其检测一些必要硬件是否可用，这个过程成为POST自检，如果检测通过就会进行下一个步骤：BIOS模式，或者UEFI模式。



> 一般计算机硬件出现故障，都会在这里的硬件自检阶段无法通过而被迫中断。此阶段的自检包括CPU的检测，内存，IO芯片模块，例如什么8255等等（现代的这些外设芯片性能更加优越，功能更加丰富，不一定是8255这些老古董）。

以上部分是纯粹硬件部分的自检，几乎没有软件掺入，到了下一步的BIOS或UEFI步骤，就会...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[LZSS压缩算法]]></title>
        <id>https://hchen90.top/post/lzsscompalgo</id>
        <link href="https://hchen90.top/post/lzsscompalgo"/>
        <updated>2018-04-01T21:12:32.000Z</updated>
        <summary type="html"><![CDATA[
# LZSS算法简介

LZSS算法是LZ77算法的改良版，由James A. Storer和Thomas Szymacski于1982年发表在ACM杂志上。LZSS算法充分地利用了位的标记，从而使得压缩效率相比较于LZ77而言，有了显著提高。



> 参考维基百科[lzss](https://en.wikipedia.org/wiki/Lempel%E2%80%93Ziv%E2%80%93Storer%E2%80%93Szymanski)

# 算法逻辑

在看本篇博文之前，需要知道LZ77算法的大体流程，如果不清楚可以点击[这里](/2018/03/31/lz77compalgo)浏览...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[LZ77压缩算法]]></title>
        <id>https://hchen90.top/post/lz77compalgo</id>
        <link href="https://hchen90.top/post/lz77compalgo"/>
        <updated>2018-03-31T20:38:24.000Z</updated>
        <summary type="html"><![CDATA[
# LZ77算法简介

LZ77算法是一种无损压缩算法，最早由两位以色列人于1977发表，它是一种典型的字典型压缩算法，目前几乎大多数的无损压缩算法都是基于这个LZ77算法，也就是在其基础上优化修改，此算法可以称得上是无损压缩算法界的鼻祖了。



> 参考维基百科[lz77](https://en.wikipedia.org/wiki/LZ77_and_LZ78)

# 算法逻辑

LZ77的算法核心就是一个滑动窗口，在滑动窗口里面搜索重复字节，并将匹配到的字节串用更短的字节串方式表示出来。

这里涉及到几个要素：

* 滑动窗口缓冲区
* 滑窗的前部区域
* 滑窗的已编码区域

## 编...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在 Linux 系统启用 UEFI 的 Secure Boot]]></title>
        <id>https://hchen90.top/post/enablesbonlinux</id>
        <link href="https://hchen90.top/post/enablesbonlinux"/>
        <updated>2017-09-02T00:17:02.000Z</updated>
        <summary type="html"><![CDATA[
## 概述

Secure Boot 作为 UEFI 的一个选项，它可以被设置为开启或关闭 ( 有少数的计算机里面， Secure Boot 被设置为开启，却不存在关闭它的选项，但系统主板内置有 Windows 系统的公钥证书签名，使其只能加载 Windows ，其他系统一律不以加载，用户没有选项，不能关闭，还没法换系统，无法适用本博客介绍内容）。 Secure Boot 所需要的公钥证书被保存在计算机的主板的 FLASH 里面（注意不是磁盘里面哦），在主板的一小块 FLASH 里面保存着 PK ， KEK， db， dbx 的证书链，所以， **在操作开始前请确保你的计算机 UEFI-BI...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux系统中的异步I/O问题]]></title>
        <id>https://hchen90.top/post/linuxsystemasyncio</id>
        <link href="https://hchen90.top/post/linuxsystemasyncio"/>
        <updated>2017-07-08T00:02:11.000Z</updated>
        <summary type="html"><![CDATA[
# Linux系统中的异步I/O问题

系统编程中，I/O（输入/输出）模型决定了如何和数据进行交互，它对整个系统性能影响至关重要。I/O模型会直接影响如下几大方面：

* 吞吐量
* 机器资源利用率，例如：CPU使用率
* 系统的可拓展性
* 编程复杂性

I/O模型在网络编程中，是高性能服务器的基础，如果设计的不好，不管上层如何设计精巧都会在I/O层卡住，成为性能瓶颈。

本文将重点讨论Linux环境下的两种核心I/O模型：同步I/O模型和异步I/O模型，并结合相关的套接字函数进行阐述。

## 第一部分：同步I/O，那些我们熟悉的“阻塞”和“非阻塞”

同步I/O的通俗解释是：调用方发...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[软件设计模式 - 行为模式]]></title>
        <id>https://hchen90.top/post/softwaredesignpattern4</id>
        <link href="https://hchen90.top/post/softwaredesignpattern4"/>
        <updated>2017-06-08T22:01:03.000Z</updated>
        <summary type="html"><![CDATA[
# 软件设计模式 - 行为模式

行为模式负责对象之间的高效沟通和职责委派。

行为模式包括：责任链，命令，迭代器，中介者，备忘录，观察者，状态，策略，模版方法，访问者。



## 责任链模式（Chain of Responsibility/CoR）

责任链模式允许你将请求沿着处理者链进行传递。每个节点上的处理者收到请求后，可对请求进行处理，或者将请求继续传递给链上的下个处理者。

例如：

![CoR](cor.png)

这里只是两级责任链。

示例代码：

```cpp
class Handler {
public:
    void handle() = 0;
};

class...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[软件设计模式 - 结构型模式]]></title>
        <id>https://hchen90.top/post/softwaredesignpattern3</id>
        <link href="https://hchen90.top/post/softwaredesignpattern3"/>
        <updated>2017-06-05T21:11:12.000Z</updated>
        <summary type="html"><![CDATA[
# 软件设计模式 - 结构型模式

结构型模式介绍类和对象的组装方式，同时保持较大的灵活性和高效性。

结构型模式包括：适配器，桥接，组合，装饰，外观，享元，代理。



## 适配器模式（Adapter）

适配器模式是为了解决不同接口之间的适配问题。

适配器通常分为两类：对象适配器，类适配器。

### 对象适配器

对象适配器是通过实现接口来做到适配的，如下：

![Object Adapter](objadp.png)

示例代码：

```cpp
class DrawService {
    // 绘图服务
public:
    void paint(Graphics&) {...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[软件设计模式 - 创建型模式]]></title>
        <id>https://hchen90.top/post/softwaredesignpattern2</id>
        <link href="https://hchen90.top/post/softwaredesignpattern2"/>
        <updated>2017-06-04T19:04:11.000Z</updated>
        <summary type="html"><![CDATA[
# 软件设计模式 - 创建型模式

创建型模式分为：工厂方法，抽象工厂，生成器，原型，单例。



## 工厂方法模式（Factory Method）

工厂方法模式是**一种在父类声明方法，在子类实例化该对象的方法**。在C++中通常以虚函数形式来表示，在其他语言，例如Java中则是抽象函数来表示。

工厂方法模式中更加关注目标“产品”本身，一般使用统一的接口来实例化对象的属性。

例如一个图形绘制的场景应用，对于夫类，我们只关注高层次需求（图形的绘制），这里的对应为图形，结构如下：

![Factory Method - Graphics](fmgrap.png)

定义代码如下：

`...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[软件设计模式简介]]></title>
        <id>https://hchen90.top/post/softwaredesignpattern1</id>
        <link href="https://hchen90.top/post/softwaredesignpattern1"/>
        <updated>2017-06-02T20:12:01.000Z</updated>
        <summary type="html"><![CDATA[
# 软件设计模式简介

软件设计模式属于软件工程领域的解决问题的基本方法，它提供了一种合理地达成目标的处理步骤。本文主要简单提出为何需要它，它的作用，以及它的主要组成元素。



## 什么是软件设计模式

软件设计模式其实就是为了解决问题，而制定的一种抽象层面的合理地达到目标的处理步骤。

设计模式的不同需要更具特定的业务场景来决定，每一种模式都包含特定的意图，动机和结构。

> 谁发明了设计模式
>> 模式的概念源自于建筑学概念，最早由克里斯托佛·亚历山大提出。后来该概念被应用到软件开发领域以解决程序设计中遇到的各种问题，最初代表就是GoF四人组的书，从上个世纪末以来，这种方法一直在大中...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何将处于虚拟机中的MINIX系统中的文件复制到实体机的LINUX系统中来]]></title>
        <id>https://hchen90.top/post/minix</id>
        <link href="https://hchen90.top/post/minix"/>
        <updated>2016-10-03T00:16:13.000Z</updated>
        <summary type="html"><![CDATA[
## 问题来源

直接在虚拟机MINIX中阅读它的源代码，十分不便，修改调试做移植也非常困难，如果将MINIX系统中的部分源代码拷贝到实体机LINUX中，在LINUX系统中进行修改调试将会非常方便。

然而，MINIX系统是一种比较基本的系统，不能像vmware中使用Windows类系统那样，直接给它装VMTools（因为缺失XWindows，虽然理论上可以给MINIX装个XWindows，但是，太麻烦，而且仅仅为了几个源代码，有点大途小用）。因为vmware的磁盘文件（`.vmdk`）不是原始的磁盘数据文件，而且，vmware对据如MINIX这些生僻系统的文件系统的识别性不是太理想，造成用...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux环境搭建中文LaTeX排版系统]]></title>
        <id>https://hchen90.top/post/linuxlatex</id>
        <link href="https://hchen90.top/post/linuxlatex"/>
        <updated>2016-05-03T04:12:20.000Z</updated>
        <summary type="html"><![CDATA[
## TeX系统简介

**TeX**系统最早由Stanford大学教授Donald E. Kunth制成的计算机排版软件系统，大家对他的《The Art of Computer Programming》应该不会陌生。

实际上，TeX的制成正是由于上述的书出版样本，令他不满意，所以激发了他创制了TeX排版系统。正所谓：一个确定性的需求比十所大学更能把握前进的方向。

大家可能经常以据如MS Word等这类简单排版的所见即所得的软件，或者在Linux中以LibreOffice中的Word这样的软件，来完成文字排版等操作，但是对于论文，书籍这样的文档，和TeX相比，MS Word这些软件就成了...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何在Visual Studio 2010中使用SQL Server 2008]]></title>
        <id>https://hchen90.top/post/vssqlserver2008</id>
        <link href="https://hchen90.top/post/vssqlserver2008"/>
        <updated>2014-08-02T12:54:52.000Z</updated>
        <summary type="html"><![CDATA[
SQL Server是微软的数据库产品，也是一个较为众所周知的数据库产品，其中SQL Server 2000深受广大的用户的青睐，知名度较高，SQL Server 2008是其的后继产品之一，废话不多说了（本文不讨论VS或SQL Server的安装，假设预制环境就绪）。

首先在菜单的`视图`->`其他窗口`->`服务器资源管理器`，打开一个小的浮动窗口，就像这个样：



![pic1](pic1.png)

可以在`数据连接`项，右击，`创建新SQL Server数据库`，出现以下这个对话框：

![pic2](pic2.png)

点击一下`刷新`，在左边的输入控件的下拉菜单可以选择一...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
    <entry>
        <title type="html"><![CDATA[PE文件壳的设计过程]]></title>
        <id>https://hchen90.top/post/mspeshell</id>
        <link href="https://hchen90.top/post/mspeshell"/>
        <updated>2013-10-26T23:44:15.000Z</updated>
        <summary type="html"><![CDATA[
# 简介

今天来讨论一下PE文件的壳，壳主要用于PE文件的商业保护，以此达到软件不被暴掉的可能性，随着破解知识的普及，软件的壳也愈加复杂才可勉强不被暴。

壳的一个加载过程在许多书上都将过，这里就以图来复习一次：



![pic1](pic1.png)

这张图其实是一种情形，原程序被压缩引擎压过，还可以是在EXE文件上直接加壳不压缩，这样到省了壳的大小，但原EXE代码没有压缩，反而变大了一点，还有一种是在EXE文件的节区的空隙中添加，这样压缩过的文件和原文件一样大，但是对节区的大小有要求。这是三种常规的加壳思路。

如果单单是加一个简单的壳，象罗云彬的*《windows32位环境下的汇...]]></summary>
        <author>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </author>
        <contributor>
            <name>Hsiang Chen</name>
            <email>master@hchen90.top</email>
            <uri>https://hchen90.top</uri>
        </contributor>
    </entry>
</feed>