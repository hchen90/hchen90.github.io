<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人站点</title>
  
  <subtitle>陈祥的个人站点</subtitle>
  <link href="https://hchen90.github.io/atom.xml" rel="self"/>
  
  <link href="https://hchen90.github.io/"/>
  <updated>2021-11-29T16:48:12.290Z</updated>
  <id>https://hchen90.github.io/</id>
  
  <author>
    <name>陈祥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JNI函数调用之线程安全问题</title>
    <link href="https://hchen90.github.io/2021/11/29/jnithreadsafe/"/>
    <id>https://hchen90.github.io/2021/11/29/jnithreadsafe/</id>
    <published>2021-11-29T15:03:02.000Z</published>
    <updated>2021-11-29T16:48:12.290Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;JNI-开发是什么&quot;&gt;&lt;a href=&quot;#JNI-开发是什么&quot; class=&quot;headerlink&quot; title=&quot;JNI 开发是什么&quot;&gt;&lt;/a&gt;JNI 开发是什么&lt;/h1&gt;&lt;p&gt;因本人以前工作中做过此类工作，再加上老同事的疑问，所以，今天抽出时间来探讨一下JNI的开发问题和特定细节（调用的线程安全问题），其实这种JNI层调用和任何其他语言调用C/C++层结构都差不多，比如说CGO，其涉及到Golang和C/C++层的调用，很多方面都存在类似之处。&lt;/p&gt;
&lt;p&gt;JNI开发是使用Java提供的本地化接口，比如C/C++（也可以是其他语言），允许Java虚拟机里面的已经编译的代码和外界的本地化代码进行交互。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="jni" scheme="https://hchen90.github.io/tags/jni/"/>
    
    <category term="java" scheme="https://hchen90.github.io/tags/java/"/>
    
    <category term="cpp" scheme="https://hchen90.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>分布式服务系统概述</title>
    <link href="https://hchen90.github.io/2020/12/20/redistributedservicesystem/"/>
    <id>https://hchen90.github.io/2020/12/20/redistributedservicesystem/</id>
    <published>2020-12-20T02:05:12.000Z</published>
    <updated>2021-11-14T13:16:34.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是分布式系统&quot;&gt;&lt;a href=&quot;#什么是分布式系统&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式系统&quot;&gt;&lt;/a&gt;什么是分布式系统&lt;/h1&gt;&lt;p&gt;关于分布式系统的定义，应该都不会陌生，它就是一些独立的计算机集合，这些计算机也称为节点，为了完成一项事务，由这一组计算节点协作完成。&lt;/p&gt;
&lt;p&gt;而分布式还有另外一个特点，就是用户几乎感知不到它是很多节点来完成一项事务的，甚至可以说，站在用户的角度，它和集中式系统几乎雷同，用户不会觉得他/她在请求的是集中式系统，亦或分布式系统，这是分布式系统的透明性。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://hchen90.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="SQL" scheme="https://hchen90.github.io/tags/SQL/"/>
    
    <category term="Actor" scheme="https://hchen90.github.io/tags/Actor/"/>
    
    <category term="MongoDB" scheme="https://hchen90.github.io/tags/MongoDB/"/>
    
    <category term="Redis" scheme="https://hchen90.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>利用Linux的coredump机制快速定位程序BUG</title>
    <link href="https://hchen90.github.io/2019/11/12/linuxcoredumptofindbug/"/>
    <id>https://hchen90.github.io/2019/11/12/linuxcoredumptofindbug/</id>
    <published>2019-11-12T01:12:29.000Z</published>
    <updated>2019-11-12T01:12:29.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是coredump？&quot;&gt;&lt;a href=&quot;#什么是coredump？&quot; class=&quot;headerlink&quot; title=&quot;什么是coredump？&quot;&gt;&lt;/a&gt;什么是coredump？&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Coredump&lt;/strong&gt;是继承于UNIX系统的机制，它用于保存程序出错而崩溃时的栈，内存，PID，UID，GID，时间等等信息的快照，通常用于程序诊断和调试，&lt;strong&gt;Coredump&lt;/strong&gt;的信息在计算机中一般保存三天左右（依系统设定而定），如果出错的程序BUG不及时查找，超过三天系统会吧这些&lt;strong&gt;Coredump&lt;/strong&gt;删除。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
    <category term="debug" scheme="https://hchen90.github.io/tags/debug/"/>
    
    <category term="coredump" scheme="https://hchen90.github.io/tags/coredump/"/>
    
    <category term="gdb" scheme="https://hchen90.github.io/tags/gdb/"/>
    
    <category term="objdump" scheme="https://hchen90.github.io/tags/objdump/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统启动流程</title>
    <link href="https://hchen90.github.io/2018/06/16/systemstartup/"/>
    <id>https://hchen90.github.io/2018/06/16/systemstartup/</id>
    <published>2018-06-16T12:40:10.000Z</published>
    <updated>2018-06-16T12:40:10.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;远古时代&quot;&gt;&lt;a href=&quot;#远古时代&quot; class=&quot;headerlink&quot; title=&quot;远古时代&quot;&gt;&lt;/a&gt;远古时代&lt;/h1&gt;&lt;p&gt; 这个时期，计算机是处于电气化高度相关的环境下，几乎没有软件的概念（这里有点瑕疵，稍后补充）。&lt;/p&gt;
&lt;p&gt;计算机这个时候会进行一系列针对硬件的自测试，尤其检测一些必要硬件是否可用，这个过程成为POST自检，如果检测通过就会进行下一个步骤：BIOS模式，或者UEFI模式。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="GRUB" scheme="https://hchen90.github.io/tags/GRUB/"/>
    
    <category term="UEFI" scheme="https://hchen90.github.io/tags/UEFI/"/>
    
    <category term="BIOS" scheme="https://hchen90.github.io/tags/BIOS/"/>
    
  </entry>
  
  <entry>
    <title>LZSS压缩算法</title>
    <link href="https://hchen90.github.io/2018/04/01/lzsscompalgo/"/>
    <id>https://hchen90.github.io/2018/04/01/lzsscompalgo/</id>
    <published>2018-04-01T13:12:32.000Z</published>
    <updated>2018-04-01T13:12:32.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;LZSS算法简介&quot;&gt;&lt;a href=&quot;#LZSS算法简介&quot; class=&quot;headerlink&quot; title=&quot;LZSS算法简介&quot;&gt;&lt;/a&gt;LZSS算法简介&lt;/h1&gt;&lt;p&gt;LZSS算法是LZ77算法的改良版，由James A. Storer和Thomas Szymacski于1982年发表在ACM杂志上。LZSS算法充分地利用了位的标记，从而使得压缩效率相比较于LZ77而言，有了显著提高。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://hchen90.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="algorithm" scheme="https://hchen90.github.io/tags/algorithm/"/>
    
    <category term="lzss" scheme="https://hchen90.github.io/tags/lzss/"/>
    
  </entry>
  
  <entry>
    <title>LZ77压缩算法</title>
    <link href="https://hchen90.github.io/2018/03/31/lz77compalgo/"/>
    <id>https://hchen90.github.io/2018/03/31/lz77compalgo/</id>
    <published>2018-03-31T12:38:24.000Z</published>
    <updated>2018-03-31T12:38:24.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;LZ77算法简介&quot;&gt;&lt;a href=&quot;#LZ77算法简介&quot; class=&quot;headerlink&quot; title=&quot;LZ77算法简介&quot;&gt;&lt;/a&gt;LZ77算法简介&lt;/h1&gt;&lt;p&gt;LZ77算法是一种无损压缩算法，最早由两位以色列人于1977发表，它是一种典型的字典型压缩算法，目前几乎大多数的无损压缩算法都是基于这个LZ77算法，也就是在其基础上优化修改，此算法可以称得上是无损压缩算法界的鼻祖了。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://hchen90.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="lz77" scheme="https://hchen90.github.io/tags/lz77/"/>
    
    <category term="algorithm" scheme="https://hchen90.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux 系统启用 UEFI 的 Secure Boot</title>
    <link href="https://hchen90.github.io/2017/09/02/enablesbonlinux/"/>
    <id>https://hchen90.github.io/2017/09/02/enablesbonlinux/</id>
    <published>2017-09-01T16:17:02.000Z</published>
    <updated>2017-09-01T16:17:02.000Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Secure Boot 作为 UEFI 的一个选项，它可以被设置为开启或关闭 ( 有少数的计算机里面， Secure Boot 被设置为开启，却不存在关闭它的选项，但系统主板内置有 Windows 系统的公钥证书签名，使其只能加载 Windows ，其他系统一律不以加载，用户没有选项，不能关闭，还没法换系统，无法适用本博客介绍内容）。 Secure Boot 所需要的公钥证书被保存在计算机的主板的 FLASH 里面（注意不是磁盘里面哦），在主板的一小块 FLASH 里面保存着 PK ， KEK， db， dbx 的证书链，所以， &lt;strong&gt;在操作开始前请确保你的计算机 UEFI-BIOS 的 Secure Boot 能够被关闭，否则，发生操作失误，将导致证书不能匹配任何程序代码文件，而使主板拒绝加载任何程序代码文件，就会导致主板变砖&lt;/strong&gt; (虽然它不是 BIOS ，但是许多人都这么称呼它为 UEFI-BIOS ，所以，这里也这么称呼其为 UEFI-BIOS) 。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
    <category term="uefi" scheme="https://hchen90.github.io/tags/uefi/"/>
    
    <category term="openssl" scheme="https://hchen90.github.io/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>如何将处于虚拟机中的MINIX系统中的文件复制到实体机的LINUX系统中来</title>
    <link href="https://hchen90.github.io/2016/10/03/minix/"/>
    <id>https://hchen90.github.io/2016/10/03/minix/</id>
    <published>2016-10-02T16:16:13.000Z</published>
    <updated>2016-10-02T16:16:13.000Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;问题来源&quot;&gt;&lt;a href=&quot;#问题来源&quot; class=&quot;headerlink&quot; title=&quot;问题来源&quot;&gt;&lt;/a&gt;问题来源&lt;/h2&gt;&lt;p&gt;直接在虚拟机MINIX中阅读它的源代码，十分不便，修改调试做移植也非常困难，如果将MINIX系统中的部分源代码拷贝到实体机LINUX中，在LINUX系统中进行修改调试将会非常方便。&lt;/p&gt;
&lt;p&gt;然而，MINIX系统是一种比较基本的系统，不能像vmware中使用Windows类系统那样，直接给它装VMTools（因为缺失XWindows，虽然理论上可以给MINIX装个XWindows，但是，太麻烦，而且仅仅为了几个源代码，有点大途小用）。因为vmware的磁盘文件（&lt;code&gt;.vmdk&lt;/code&gt;）不是原始的磁盘数据文件，而且，vmware对据如MINIX这些生僻系统的文件系统的识别性不是太理想，造成用vmware无法挂载MINIX系统到实体主机上，仍然复制不到虚拟机中的MINIX的文件。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="minix" scheme="https://hchen90.github.io/tags/minix/"/>
    
    <category term="qemu" scheme="https://hchen90.github.io/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境搭建中文LaTeX排版系统</title>
    <link href="https://hchen90.github.io/2016/05/03/linuxlatex/"/>
    <id>https://hchen90.github.io/2016/05/03/linuxlatex/</id>
    <published>2016-05-02T20:12:20.000Z</published>
    <updated>2016-05-02T20:12:20.000Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;TeX系统简介&quot;&gt;&lt;a href=&quot;#TeX系统简介&quot; class=&quot;headerlink&quot; title=&quot;TeX系统简介&quot;&gt;&lt;/a&gt;TeX系统简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;TeX&lt;/strong&gt;系统最早由Stanford大学教授Donald E. Kunth制成的计算机排版软件系统，大家对他的《The Art of Computer Programming》应该不会陌生。&lt;/p&gt;
&lt;p&gt;实际上，TeX的制成正是由于上述的书出版样本，令他不满意，所以激发了他创制了TeX排版系统。正所谓：一个确定性的需求比十所大学更能把握前进的方向。&lt;/p&gt;
&lt;p&gt;大家可能经常以据如MS Word等这类简单排版的所见即所得的软件，或者在Linux中以LibreOffice中的Word这样的软件，来完成文字排版等操作，但是对于论文，书籍这样的文档，和TeX相比，MS Word这些软件就成了小儿科了。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
    <category term="latex" scheme="https://hchen90.github.io/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>如何在Visual Studio 2010中使用SQL Server 2008</title>
    <link href="https://hchen90.github.io/2014/08/02/vssqlserver2008/"/>
    <id>https://hchen90.github.io/2014/08/02/vssqlserver2008/</id>
    <published>2014-08-02T04:54:52.000Z</published>
    <updated>2014-08-02T04:54:52.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;SQL Server是微软的数据库产品，也是一个较为众所周知的数据库产品，其中SQL Server 2000深受广大的用户的青睐，知名度较高，SQL Server 2008是其的后继产品之一，废话不多说了（本文不讨论VS或SQL Server的安装，假设预制环境就绪）。&lt;/p&gt;
&lt;p&gt;首先在菜单的&lt;code&gt;视图&lt;/code&gt;-&amp;gt;&lt;code&gt;其他窗口&lt;/code&gt;-&amp;gt;&lt;code&gt;服务器资源管理器&lt;/code&gt;，打开一个小的浮动窗口，就像这个样：&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="SQL" scheme="https://hchen90.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>PE文件壳的设计过程</title>
    <link href="https://hchen90.github.io/2013/10/26/mspeshell/"/>
    <id>https://hchen90.github.io/2013/10/26/mspeshell/</id>
    <published>2013-10-26T15:44:15.000Z</published>
    <updated>2013-10-26T15:44:15.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;今天来讨论一下PE文件的壳，壳主要用于PE文件的商业保护，以此达到软件不被暴掉的可能性，随着破解知识的普及，软件的壳也愈加复杂才可勉强不被暴。&lt;/p&gt;
&lt;p&gt;壳的一个加载过程在许多书上都将过，这里就以图来复习一次：&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="Windows" scheme="https://hchen90.github.io/tags/Windows/"/>
    
    <category term="EXE" scheme="https://hchen90.github.io/tags/EXE/"/>
    
  </entry>
  
</feed>
