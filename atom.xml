<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人站点</title>
  
  <subtitle>陈祥的个人站点</subtitle>
  <link href="https://hchen90.github.io/atom.xml" rel="self"/>
  
  <link href="https://hchen90.github.io/"/>
  <updated>2022-07-02T02:03:12.000Z</updated>
  <id>https://hchen90.github.io/</id>
  
  <author>
    <name>陈祥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>玩转自搭建 GitLab 社区版</title>
    <link href="https://hchen90.github.io/2022/07/02/deploygitlabcerunner/"/>
    <id>https://hchen90.github.io/2022/07/02/deploygitlabcerunner/</id>
    <published>2022-07-02T02:03:12.000Z</published>
    <updated>2022-07-02T02:03:12.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;玩转自搭建-GitLab-社区版&quot;&gt;&lt;a href=&quot;#玩转自搭建-GitLab-社区版&quot; class=&quot;headerlink&quot; title=&quot;玩转自搭建 GitLab 社区版&quot;&gt;&lt;/a&gt;玩转自搭建 GitLab 社区版&lt;/h1&gt;&lt;p&gt;本文的自搭建是基于docker容器技术而实现的，其中包括&lt;code&gt;gitlab-ce&lt;/code&gt;和&lt;code&gt;gitlab-runner&lt;/code&gt;两个部分。&lt;/p&gt;
&lt;h2 id=&quot;什么是-GitLab&quot;&gt;&lt;a href=&quot;#什么是-GitLab&quot; class=&quot;headerlink&quot; title=&quot;什么是 GitLab&quot;&gt;&lt;/a&gt;什么是 GitLab&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;GitLab&lt;/strong&gt;是一个代码仓库管理系统（它是一套开源项目），使用 Git 作为代码管理工具，集成 Web 管理的服务，&lt;strong&gt;GitLab&lt;/strong&gt;被广泛用于基于 Git 代码管理平台，在很多一些结构不是复杂的组织结构中都会优先使用它。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="git" scheme="https://hchen90.github.io/tags/git/"/>
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>程序的代码修改问题</title>
    <link href="https://hchen90.github.io/2022/06/11/codemodification/"/>
    <id>https://hchen90.github.io/2022/06/11/codemodification/</id>
    <published>2022-06-11T00:53:02.000Z</published>
    <updated>2022-06-11T00:53:02.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是代码改动&quot;&gt;&lt;a href=&quot;#什么是代码改动&quot; class=&quot;headerlink&quot; title=&quot;什么是代码改动&quot;&gt;&lt;/a&gt;什么是代码改动&lt;/h1&gt;&lt;p&gt;在软件项目中都存在一个生命周期，无论周期长短，都会涉及到代码改动，不管是对以前缺陷的修复，还是在敏捷开发中（每一个故事的迭代），都会或多或少地产生代码修改。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="expr" scheme="https://hchen90.github.io/tags/expr/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB Cloud云平台简单使用简介</title>
    <link href="https://hchen90.github.io/2022/04/03/mongodbcloudcluster/"/>
    <id>https://hchen90.github.io/2022/04/03/mongodbcloudcluster/</id>
    <published>2022-04-03T06:22:06.000Z</published>
    <updated>2022-04-03T09:44:02.894Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是MongoDB-Cloud&quot;&gt;&lt;a href=&quot;#什么是MongoDB-Cloud&quot; class=&quot;headerlink&quot; title=&quot;什么是MongoDB Cloud&quot;&gt;&lt;/a&gt;什么是MongoDB Cloud&lt;/h1&gt;&lt;p&gt;MongoDB Cloud 的核心是 &lt;a href=&quot;https://www.mongodb.com/zh-cn/cloud/atlas&quot;&gt;MongoDB Atlas&lt;/a&gt; ，这是一个适用于现代应用程序的完全托管的云数据库。Atlas 是运行领先的现代数据库 MongoDB 的最佳方式。&lt;a href=&quot;https://www.mongodb.com/zh-cn/what-is-mongodb&quot;&gt;MongoDB&lt;/a&gt; 的文档模型是一种更快的创新方式，可为数据库带来灵活性和易用性。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="MongoDB" scheme="https://hchen90.github.io/tags/MongoDB/"/>
    
    <category term="SQL" scheme="https://hchen90.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>JNI函数调用之线程安全问题</title>
    <link href="https://hchen90.github.io/2021/11/29/jnithreadsafe/"/>
    <id>https://hchen90.github.io/2021/11/29/jnithreadsafe/</id>
    <published>2021-11-29T15:03:02.000Z</published>
    <updated>2021-11-29T16:48:12.290Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;JNI-开发是什么&quot;&gt;&lt;a href=&quot;#JNI-开发是什么&quot; class=&quot;headerlink&quot; title=&quot;JNI 开发是什么&quot;&gt;&lt;/a&gt;JNI 开发是什么&lt;/h1&gt;&lt;p&gt;因本人以前工作中做过此类工作，再加上老同事的疑问，所以，今天抽出时间来探讨一下JNI的开发问题和特定细节（调用的线程安全问题），其实这种JNI层调用和任何其他语言调用C&amp;#x2F;C++层结构都差不多，比如说CGO，其涉及到Golang和C&amp;#x2F;C++层的调用，很多方面都存在类似之处。&lt;/p&gt;
&lt;p&gt;JNI开发是使用Java提供的本地化接口，比如C&amp;#x2F;C++（也可以是其他语言），允许Java虚拟机里面的已经编译的代码和外界的本地化代码进行交互。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="jni" scheme="https://hchen90.github.io/tags/jni/"/>
    
    <category term="java" scheme="https://hchen90.github.io/tags/java/"/>
    
    <category term="cpp" scheme="https://hchen90.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>分布式服务系统概述</title>
    <link href="https://hchen90.github.io/2020/12/20/redistributedservicesystem/"/>
    <id>https://hchen90.github.io/2020/12/20/redistributedservicesystem/</id>
    <published>2020-12-20T02:05:12.000Z</published>
    <updated>2021-11-14T13:16:34.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是分布式系统&quot;&gt;&lt;a href=&quot;#什么是分布式系统&quot; class=&quot;headerlink&quot; title=&quot;什么是分布式系统&quot;&gt;&lt;/a&gt;什么是分布式系统&lt;/h1&gt;&lt;p&gt;关于分布式系统的定义，应该都不会陌生，它就是一些独立的计算机集合，这些计算机也称为节点，为了完成一项事务，由这一组计算节点协作完成。&lt;/p&gt;
&lt;p&gt;而分布式还有另外一个特点，就是用户几乎感知不到它是很多节点来完成一项事务的，甚至可以说，站在用户的角度，它和集中式系统几乎雷同，用户不会觉得他&amp;#x2F;她在请求的是集中式系统，亦或分布式系统，这是分布式系统的透明性。&lt;/p&gt;</summary>
    
    
    
    <category term="技术" scheme="https://hchen90.github.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="MongoDB" scheme="https://hchen90.github.io/tags/MongoDB/"/>
    
    <category term="SQL" scheme="https://hchen90.github.io/tags/SQL/"/>
    
    <category term="Actor" scheme="https://hchen90.github.io/tags/Actor/"/>
    
    <category term="Redis" scheme="https://hchen90.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>GitHub的OAuth App的使用</title>
    <link href="https://hchen90.github.io/2020/04/15/githuboauthappintro/"/>
    <id>https://hchen90.github.io/2020/04/15/githuboauthappintro/</id>
    <published>2020-04-15T06:23:07.000Z</published>
    <updated>2020-04-15T06:23:07.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Github的App有两种，一种是普通的App，一般用以制作自动化机器人，另一种是利用用户登录的App，它可以操作登录用户的Github里面的API定义的操作，包括：用户信息获取，仓库信息修改，用户信息修改，等等。&lt;/p&gt;
&lt;h1 id=&quot;OAuth2的定义&quot;&gt;&lt;a href=&quot;#OAuth2的定义&quot; class=&quot;headerlink&quot; title=&quot;OAuth2的定义&quot;&gt;&lt;/a&gt;OAuth2的定义&lt;/h1&gt;&lt;p&gt;OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0 是 OAuth 协议的延续版本，但不向后兼容 OAuth 1.0，即完全废止了 OAuth1.0。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="github" scheme="https://hchen90.github.io/tags/github/"/>
    
    <category term="oauth" scheme="https://hchen90.github.io/tags/oauth/"/>
    
  </entry>
  
  <entry>
    <title>利用Linux的coredump机制快速定位程序BUG</title>
    <link href="https://hchen90.github.io/2019/11/12/linuxcoredumptofindbug/"/>
    <id>https://hchen90.github.io/2019/11/12/linuxcoredumptofindbug/</id>
    <published>2019-11-12T01:12:29.000Z</published>
    <updated>2019-11-12T01:12:29.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是coredump？&quot;&gt;&lt;a href=&quot;#什么是coredump？&quot; class=&quot;headerlink&quot; title=&quot;什么是coredump？&quot;&gt;&lt;/a&gt;什么是coredump？&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Coredump&lt;/strong&gt;是继承于UNIX系统的机制，它用于保存程序出错而崩溃时的栈，内存，PID，UID，GID，时间等等信息的快照，通常用于程序诊断和调试，&lt;strong&gt;Coredump&lt;/strong&gt;的信息在计算机中一般保存三天左右（依系统设定而定），如果出错的程序BUG不及时查找，超过三天系统会吧这些&lt;strong&gt;Coredump&lt;/strong&gt;删除。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
    <category term="debug" scheme="https://hchen90.github.io/tags/debug/"/>
    
    <category term="coredump" scheme="https://hchen90.github.io/tags/coredump/"/>
    
    <category term="gdb" scheme="https://hchen90.github.io/tags/gdb/"/>
    
    <category term="objdump" scheme="https://hchen90.github.io/tags/objdump/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统启动流程</title>
    <link href="https://hchen90.github.io/2018/06/24/linuxstartup/"/>
    <id>https://hchen90.github.io/2018/06/24/linuxstartup/</id>
    <published>2018-06-24T03:50:03.000Z</published>
    <updated>2018-06-24T03:50:03.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;内核加载&quot;&gt;&lt;a href=&quot;#内核加载&quot; class=&quot;headerlink&quot; title=&quot;内核加载&quot;&gt;&lt;/a&gt;内核加载&lt;/h1&gt;&lt;p&gt;在&lt;a href=&quot;/2018/06/16/systemstartup&quot;&gt;上篇博文&lt;/a&gt;里面我说明过计算机如何从远古到近代的启动流程，然后，走到操作系统一层的时候就没有深入阐述了，在这篇博文我将以Linux系统为例来叙述操作系统是如何启动的。&lt;/p&gt;
&lt;p&gt;通常在系统&lt;code&gt;/boot&lt;/code&gt;目录下放着内核文件，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;initramfs-linux.img&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vmlinuz-linux&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;GRUB（或者LILO）加载内核的时候，会把&lt;code&gt;vmlinuz-linux&lt;/code&gt;映射到内存并会把它的一个初始根目录的文件镜像（&lt;code&gt;initramfs-linux.img&lt;/code&gt;）作为文件系统加载到内存，系统会从这个迷你的初始化文件系统来启动，在这个迷你的文件系统里面又会加载真正的磁盘文件系统，带有这种&lt;code&gt;initramfs&lt;/code&gt;的都是这种加载流程，但是，对于那种没有&lt;code&gt;initramfs&lt;/code&gt;的（例如：Slackware发行版本），它是加载内核后，内核直接从磁盘加载文件系统，这种区分跟内核配置有关。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统启动流程</title>
    <link href="https://hchen90.github.io/2018/06/16/systemstartup/"/>
    <id>https://hchen90.github.io/2018/06/16/systemstartup/</id>
    <published>2018-06-16T12:40:10.000Z</published>
    <updated>2018-06-16T12:40:10.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;远古时代&quot;&gt;&lt;a href=&quot;#远古时代&quot; class=&quot;headerlink&quot; title=&quot;远古时代&quot;&gt;&lt;/a&gt;远古时代&lt;/h1&gt;&lt;p&gt; 这个时期，计算机是处于电气化高度相关的环境下，几乎没有软件的概念（这里有点瑕疵，稍后补充）。&lt;/p&gt;
&lt;p&gt;计算机这个时候会进行一系列针对硬件的自测试，尤其检测一些必要硬件是否可用，这个过程成为POST自检，如果检测通过就会进行下一个步骤：BIOS模式，或者UEFI模式。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="GRUB" scheme="https://hchen90.github.io/tags/GRUB/"/>
    
    <category term="UEFI" scheme="https://hchen90.github.io/tags/UEFI/"/>
    
    <category term="BIOS" scheme="https://hchen90.github.io/tags/BIOS/"/>
    
  </entry>
  
  <entry>
    <title>LZSS压缩算法</title>
    <link href="https://hchen90.github.io/2018/04/01/lzsscompalgo/"/>
    <id>https://hchen90.github.io/2018/04/01/lzsscompalgo/</id>
    <published>2018-04-01T13:12:32.000Z</published>
    <updated>2018-04-01T13:12:32.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;LZSS算法简介&quot;&gt;&lt;a href=&quot;#LZSS算法简介&quot; class=&quot;headerlink&quot; title=&quot;LZSS算法简介&quot;&gt;&lt;/a&gt;LZSS算法简介&lt;/h1&gt;&lt;p&gt;LZSS算法是LZ77算法的改良版，由James A. Storer和Thomas Szymacski于1982年发表在ACM杂志上。LZSS算法充分地利用了位的标记，从而使得压缩效率相比较于LZ77而言，有了显著提高。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://hchen90.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="lzss" scheme="https://hchen90.github.io/tags/lzss/"/>
    
    <category term="algorithm" scheme="https://hchen90.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>LZ77压缩算法</title>
    <link href="https://hchen90.github.io/2018/03/31/lz77compalgo/"/>
    <id>https://hchen90.github.io/2018/03/31/lz77compalgo/</id>
    <published>2018-03-31T12:38:24.000Z</published>
    <updated>2018-03-31T12:38:24.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;LZ77算法简介&quot;&gt;&lt;a href=&quot;#LZ77算法简介&quot; class=&quot;headerlink&quot; title=&quot;LZ77算法简介&quot;&gt;&lt;/a&gt;LZ77算法简介&lt;/h1&gt;&lt;p&gt;LZ77算法是一种无损压缩算法，最早由两位以色列人于1977发表，它是一种典型的字典型压缩算法，目前几乎大多数的无损压缩算法都是基于这个LZ77算法，也就是在其基础上优化修改，此算法可以称得上是无损压缩算法界的鼻祖了。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://hchen90.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="algorithm" scheme="https://hchen90.github.io/tags/algorithm/"/>
    
    <category term="lz77" scheme="https://hchen90.github.io/tags/lz77/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux 系统启用 UEFI 的 Secure Boot</title>
    <link href="https://hchen90.github.io/2017/09/02/enablesbonlinux/"/>
    <id>https://hchen90.github.io/2017/09/02/enablesbonlinux/</id>
    <published>2017-09-01T16:17:02.000Z</published>
    <updated>2017-09-01T16:17:02.000Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Secure Boot 作为 UEFI 的一个选项，它可以被设置为开启或关闭 ( 有少数的计算机里面， Secure Boot 被设置为开启，却不存在关闭它的选项，但系统主板内置有 Windows 系统的公钥证书签名，使其只能加载 Windows ，其他系统一律不以加载，用户没有选项，不能关闭，还没法换系统，无法适用本博客介绍内容）。 Secure Boot 所需要的公钥证书被保存在计算机的主板的 FLASH 里面（注意不是磁盘里面哦），在主板的一小块 FLASH 里面保存着 PK ， KEK， db， dbx 的证书链，所以， &lt;strong&gt;在操作开始前请确保你的计算机 UEFI-BIOS 的 Secure Boot 能够被关闭，否则，发生操作失误，将导致证书不能匹配任何程序代码文件，而使主板拒绝加载任何程序代码文件，就会导致主板变砖&lt;/strong&gt; (虽然它不是 BIOS ，但是许多人都这么称呼它为 UEFI-BIOS ，所以，这里也这么称呼其为 UEFI-BIOS) 。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
    <category term="uefi" scheme="https://hchen90.github.io/tags/uefi/"/>
    
    <category term="openssl" scheme="https://hchen90.github.io/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>如何将处于虚拟机中的MINIX系统中的文件复制到实体机的LINUX系统中来</title>
    <link href="https://hchen90.github.io/2016/10/03/minix/"/>
    <id>https://hchen90.github.io/2016/10/03/minix/</id>
    <published>2016-10-02T16:16:13.000Z</published>
    <updated>2016-10-02T16:16:13.000Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;问题来源&quot;&gt;&lt;a href=&quot;#问题来源&quot; class=&quot;headerlink&quot; title=&quot;问题来源&quot;&gt;&lt;/a&gt;问题来源&lt;/h2&gt;&lt;p&gt;直接在虚拟机MINIX中阅读它的源代码，十分不便，修改调试做移植也非常困难，如果将MINIX系统中的部分源代码拷贝到实体机LINUX中，在LINUX系统中进行修改调试将会非常方便。&lt;/p&gt;
&lt;p&gt;然而，MINIX系统是一种比较基本的系统，不能像vmware中使用Windows类系统那样，直接给它装VMTools（因为缺失XWindows，虽然理论上可以给MINIX装个XWindows，但是，太麻烦，而且仅仅为了几个源代码，有点大途小用）。因为vmware的磁盘文件（&lt;code&gt;.vmdk&lt;/code&gt;）不是原始的磁盘数据文件，而且，vmware对据如MINIX这些生僻系统的文件系统的识别性不是太理想，造成用vmware无法挂载MINIX系统到实体主机上，仍然复制不到虚拟机中的MINIX的文件。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="minix" scheme="https://hchen90.github.io/tags/minix/"/>
    
    <category term="qemu" scheme="https://hchen90.github.io/tags/qemu/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境搭建中文LaTeX排版系统</title>
    <link href="https://hchen90.github.io/2016/05/03/linuxlatex/"/>
    <id>https://hchen90.github.io/2016/05/03/linuxlatex/</id>
    <published>2016-05-02T20:12:20.000Z</published>
    <updated>2016-05-02T20:12:20.000Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;TeX系统简介&quot;&gt;&lt;a href=&quot;#TeX系统简介&quot; class=&quot;headerlink&quot; title=&quot;TeX系统简介&quot;&gt;&lt;/a&gt;TeX系统简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;TeX&lt;/strong&gt;系统最早由Stanford大学教授Donald E. Kunth制成的计算机排版软件系统，大家对他的《The Art of Computer Programming》应该不会陌生。&lt;/p&gt;
&lt;p&gt;实际上，TeX的制成正是由于上述的书出版样本，令他不满意，所以激发了他创制了TeX排版系统。正所谓：一个确定性的需求比十所大学更能把握前进的方向。&lt;/p&gt;
&lt;p&gt;大家可能经常以据如MS Word等这类简单排版的所见即所得的软件，或者在Linux中以LibreOffice中的Word这样的软件，来完成文字排版等操作，但是对于论文，书籍这样的文档，和TeX相比，MS Word这些软件就成了小儿科了。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
    <category term="latex" scheme="https://hchen90.github.io/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>如何在Visual Studio 2010中使用SQL Server 2008</title>
    <link href="https://hchen90.github.io/2014/08/02/vssqlserver2008/"/>
    <id>https://hchen90.github.io/2014/08/02/vssqlserver2008/</id>
    <published>2014-08-02T04:54:52.000Z</published>
    <updated>2014-08-02T04:54:52.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;SQL Server是微软的数据库产品，也是一个较为众所周知的数据库产品，其中SQL Server 2000深受广大的用户的青睐，知名度较高，SQL Server 2008是其的后继产品之一，废话不多说了（本文不讨论VS或SQL Server的安装，假设预制环境就绪）。&lt;/p&gt;
&lt;p&gt;首先在菜单的&lt;code&gt;视图&lt;/code&gt;-&amp;gt;&lt;code&gt;其他窗口&lt;/code&gt;-&amp;gt;&lt;code&gt;服务器资源管理器&lt;/code&gt;，打开一个小的浮动窗口，就像这个样：&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="SQL" scheme="https://hchen90.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>PE文件壳的设计过程</title>
    <link href="https://hchen90.github.io/2013/10/26/mspeshell/"/>
    <id>https://hchen90.github.io/2013/10/26/mspeshell/</id>
    <published>2013-10-26T15:44:15.000Z</published>
    <updated>2013-10-26T15:44:15.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;今天来讨论一下PE文件的壳，壳主要用于PE文件的商业保护，以此达到软件不被暴掉的可能性，随着破解知识的普及，软件的壳也愈加复杂才可勉强不被暴。&lt;/p&gt;
&lt;p&gt;壳的一个加载过程在许多书上都将过，这里就以图来复习一次：&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="Windows" scheme="https://hchen90.github.io/tags/Windows/"/>
    
    <category term="EXE" scheme="https://hchen90.github.io/tags/EXE/"/>
    
  </entry>
  
</feed>
