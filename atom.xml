<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人站点</title>
  
  <subtitle>陈祥的个人站点</subtitle>
  <link href="https://hchen90.github.io/atom.xml" rel="self"/>
  
  <link href="https://hchen90.github.io/"/>
  <updated>2024-07-03T17:50:33.321Z</updated>
  <id>https://hchen90.github.io/</id>
  
  <author>
    <name>陈祥</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>人工智能笔记 - 机器学习</title>
    <link href="https://hchen90.github.io/2024/07/02/ai2-studylog-ml/"/>
    <id>https://hchen90.github.io/2024/07/02/ai2-studylog-ml/</id>
    <published>2024-07-02T03:36:12.000Z</published>
    <updated>2024-07-03T17:50:33.321Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;人工智能---机器学习&quot;&gt;人工智能 - 机器学习&lt;/h1&gt;
&lt;p&gt;人工智能的基础是机器学习，顾名思义就是让机器能够处理数据，并在处理的数据中进行学习，从而能够自主地做出决策。简单来说，机器学习是让机器能够在不需要特别编程的情况下进行学习和改进。&lt;/p&gt;
&lt;p&gt;而机器学习，大体上分为三种，分别为：监督式学习，无监督式学习，和深度学习。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="人工智能" scheme="https://hchen90.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="AI" scheme="https://hchen90.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>人工智能笔记 - 数据分析和决策</title>
    <link href="https://hchen90.github.io/2024/06/12/ai1-studylog-dataanalysis/"/>
    <id>https://hchen90.github.io/2024/06/12/ai1-studylog-dataanalysis/</id>
    <published>2024-06-12T13:36:12.000Z</published>
    <updated>2024-06-12T15:14:08.159Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;人工智能---数据分析和决策&quot;&gt;人工智能 - 数据分析和决策&lt;/h1&gt;
&lt;p&gt;这部分主要分为四个层次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据收集&lt;/li&gt;
&lt;li&gt;数据清理&lt;/li&gt;
&lt;li&gt;数据分析&lt;/li&gt;
&lt;li&gt;决策&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="人工智能" scheme="https://hchen90.github.io/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="AI" scheme="https://hchen90.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>OpenAI之OpenAPI初探</title>
    <link href="https://hchen90.github.io/2023/03/28/openaiapirsh/"/>
    <id>https://hchen90.github.io/2023/03/28/openaiapirsh/</id>
    <published>2023-03-28T14:11:08.000Z</published>
    <updated>2023-03-28T14:11:08.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;简介&lt;/h1&gt;
&lt;p&gt;人工智能并非是一个新鲜事物，早在多年前就就已有
TensorFlow，配合一套数值，矩阵，图形，和相关算法库，就可以实现一个简单的人工智能。&lt;/p&gt;
&lt;p&gt;其实人工智能经历了许多年的发展，目前逐渐成熟，平时大众与其在生活的交叉并不多，所以难以引人注目，不过这次的
ChatGPT
展现出它强大的语言功能，配合逐渐的人工智能算法，让它大火了一把。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="AI" scheme="https://hchen90.github.io/tags/AI/"/>
    
    <category term="OpenAI" scheme="https://hchen90.github.io/tags/OpenAI/"/>
    
    <category term="ChatGPT" scheme="https://hchen90.github.io/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>玩转自搭建 GitLab 社区版</title>
    <link href="https://hchen90.github.io/2022/07/02/deploygitlabcerunner/"/>
    <id>https://hchen90.github.io/2022/07/02/deploygitlabcerunner/</id>
    <published>2022-07-02T02:03:12.000Z</published>
    <updated>2022-07-02T02:03:12.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;玩转自搭建-gitlab-社区版&quot;&gt;玩转自搭建 GitLab 社区版&lt;/h1&gt;
&lt;p&gt;本文的自搭建是基于docker容器技术而实现的，其中包括&lt;code&gt;gitlab-ce&lt;/code&gt;和&lt;code&gt;gitlab-runner&lt;/code&gt;两个部分。&lt;/p&gt;
&lt;h2 id=&quot;什么是-gitlab&quot;&gt;什么是 GitLab&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GitLab&lt;/strong&gt;是一个代码仓库管理系统（它是一套开源项目），使用
Git 作为代码管理工具，集成 Web
管理的服务，&lt;strong&gt;GitLab&lt;/strong&gt;被广泛用于基于 Git
代码管理平台，在很多一些结构不是复杂的组织结构中都会优先使用它。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="git" scheme="https://hchen90.github.io/tags/git/"/>
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>程序的代码修改问题</title>
    <link href="https://hchen90.github.io/2022/06/11/codemodification/"/>
    <id>https://hchen90.github.io/2022/06/11/codemodification/</id>
    <published>2022-06-11T00:53:02.000Z</published>
    <updated>2022-06-11T00:53:02.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是代码改动&quot;&gt;什么是代码改动&lt;/h1&gt;
&lt;p&gt;在软件项目中都存在一个生命周期，无论周期长短，都会涉及到代码改动，不管是对以前缺陷的修复，还是在敏捷开发中（每一个故事的迭代），都会或多或少地产生代码修改。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="expr" scheme="https://hchen90.github.io/tags/expr/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB Cloud云平台简单使用简介</title>
    <link href="https://hchen90.github.io/2022/04/03/mongodbcloudcluster/"/>
    <id>https://hchen90.github.io/2022/04/03/mongodbcloudcluster/</id>
    <published>2022-04-03T06:22:06.000Z</published>
    <updated>2022-04-03T09:44:02.894Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是mongodb-cloud&quot;&gt;什么是MongoDB Cloud&lt;/h1&gt;
&lt;p&gt;MongoDB Cloud 的核心是 &lt;a href=&quot;https://www.mongodb.com/zh-cn/cloud/atlas&quot;&gt;MongoDB Atlas&lt;/a&gt;
，这是一个适用于现代应用程序的完全托管的云数据库。Atlas
是运行领先的现代数据库 MongoDB 的最佳方式。&lt;a href=&quot;https://www.mongodb.com/zh-cn/what-is-mongodb&quot;&gt;MongoDB&lt;/a&gt;
的文档模型是一种更快的创新方式，可为数据库带来灵活性和易用性。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="MongoDB" scheme="https://hchen90.github.io/tags/MongoDB/"/>
    
    <category term="SQL" scheme="https://hchen90.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>JNI函数调用之线程安全问题</title>
    <link href="https://hchen90.github.io/2021/11/29/jnithreadsafe/"/>
    <id>https://hchen90.github.io/2021/11/29/jnithreadsafe/</id>
    <published>2021-11-29T15:03:02.000Z</published>
    <updated>2021-11-29T16:48:12.290Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;jni-开发是什么&quot;&gt;JNI 开发是什么&lt;/h1&gt;
&lt;p&gt;因本人以前工作中做过此类工作，再加上老同事的疑问，所以，今天抽出时间来探讨一下JNI的开发问题和特定细节（调用的线程安全问题），其实这种JNI层调用和任何其他语言调用C/C++层结构都差不多，比如说CGO，其涉及到Golang和C/C++层的调用，很多方面都存在类似之处。&lt;/p&gt;
&lt;p&gt;JNI开发是使用Java提供的本地化接口，比如C/C++（也可以是其他语言），允许Java虚拟机里面的已经编译的代码和外界的本地化代码进行交互。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="jni" scheme="https://hchen90.github.io/tags/jni/"/>
    
    <category term="java" scheme="https://hchen90.github.io/tags/java/"/>
    
    <category term="cpp" scheme="https://hchen90.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>分布式服务系统概述</title>
    <link href="https://hchen90.github.io/2020/12/20/redistributedservicesystem/"/>
    <id>https://hchen90.github.io/2020/12/20/redistributedservicesystem/</id>
    <published>2020-12-20T02:05:12.000Z</published>
    <updated>2021-11-14T13:16:34.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是分布式系统&quot;&gt;什么是分布式系统&lt;/h1&gt;
&lt;p&gt;关于分布式系统的定义，应该都不会陌生，它就是一些独立的计算机集合，这些计算机也称为节点，为了完成一项事务，由这一组计算节点协作完成。&lt;/p&gt;
&lt;p&gt;而分布式还有另外一个特点，就是用户几乎感知不到它是很多节点来完成一项事务的，甚至可以说，站在用户的角度，它和集中式系统几乎雷同，用户不会觉得他/她在请求的是集中式系统，亦或分布式系统，这是分布式系统的透明性。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="MongoDB" scheme="https://hchen90.github.io/tags/MongoDB/"/>
    
    <category term="SQL" scheme="https://hchen90.github.io/tags/SQL/"/>
    
    <category term="Actor" scheme="https://hchen90.github.io/tags/Actor/"/>
    
    <category term="Redis" scheme="https://hchen90.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>GitHub的OAuth App的使用</title>
    <link href="https://hchen90.github.io/2020/04/15/githuboauthappintro/"/>
    <id>https://hchen90.github.io/2020/04/15/githuboauthappintro/</id>
    <published>2020-04-15T06:23:07.000Z</published>
    <updated>2020-04-15T06:23:07.000Z</updated>
    
    
    <summary type="html">&lt;p&gt;Github的App有两种，一种是普通的App，一般用以制作自动化机器人，另一种是利用用户登录的App，它可以操作登录用户的Github里面的API定义的操作，包括：用户信息获取，仓库信息修改，用户信息修改，等等。&lt;/p&gt;
&lt;h1 id=&quot;oauth2的定义&quot;&gt;OAuth2的定义&lt;/h1&gt;
&lt;p&gt;OAuth（开放授权）是一个开放标准，允许用户授权第三方移动应用访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容，OAuth2.0
是 OAuth 协议的延续版本，但不向后兼容 OAuth 1.0，即完全废止了
OAuth1.0。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="github" scheme="https://hchen90.github.io/tags/github/"/>
    
    <category term="oauth" scheme="https://hchen90.github.io/tags/oauth/"/>
    
  </entry>
  
  <entry>
    <title>利用Linux的coredump机制快速定位程序BUG</title>
    <link href="https://hchen90.github.io/2019/11/12/linuxcoredumptofindbug/"/>
    <id>https://hchen90.github.io/2019/11/12/linuxcoredumptofindbug/</id>
    <published>2019-11-12T01:12:29.000Z</published>
    <updated>2019-11-12T01:12:29.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是coredump&quot;&gt;什么是coredump？&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Coredump&lt;/strong&gt;是继承于UNIX系统的机制，它用于保存程序出错而崩溃时的栈，内存，PID，UID，GID，时间等等信息的快照，通常用于程序诊断和调试，&lt;strong&gt;Coredump&lt;/strong&gt;的信息在计算机中一般保存三天左右（依系统设定而定），如果出错的程序BUG不及时查找，超过三天系统会吧这些&lt;strong&gt;Coredump&lt;/strong&gt;删除。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
    <category term="debug" scheme="https://hchen90.github.io/tags/debug/"/>
    
    <category term="coredump" scheme="https://hchen90.github.io/tags/coredump/"/>
    
    <category term="gdb" scheme="https://hchen90.github.io/tags/gdb/"/>
    
    <category term="objdump" scheme="https://hchen90.github.io/tags/objdump/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统启动流程</title>
    <link href="https://hchen90.github.io/2018/06/24/linuxstartup/"/>
    <id>https://hchen90.github.io/2018/06/24/linuxstartup/</id>
    <published>2018-06-24T03:50:03.000Z</published>
    <updated>2018-06-24T03:50:03.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;内核加载&quot;&gt;内核加载&lt;/h1&gt;
&lt;p&gt;在&lt;a href=&quot;/2018/06/16/systemstartup&quot;&gt;上篇博文&lt;/a&gt;里面我说明过计算机如何从远古到近代的启动流程，然后，走到操作系统一层的时候就没有深入阐述了，在这篇博文我将以Linux系统为例来叙述操作系统是如何启动的。&lt;/p&gt;
&lt;p&gt;通常在系统&lt;code&gt;/boot&lt;/code&gt;目录下放着内核文件，如下：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;initramfs-linux.img&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vmlinuz-linux&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;GRUB（或者LILO）加载内核的时候，会把&lt;code&gt;vmlinuz-linux&lt;/code&gt;映射到内存并会把它的一个初始根目录的文件镜像（&lt;code&gt;initramfs-linux.img&lt;/code&gt;）作为文件系统加载到内存，系统会从这个迷你的初始化文件系统来启动，在这个迷你的文件系统里面又会加载真正的磁盘文件系统，带有这种&lt;code&gt;initramfs&lt;/code&gt;的都是这种加载流程，但是，对于那种没有&lt;code&gt;initramfs&lt;/code&gt;的（例如：Slackware发行版本），它是加载内核后，内核直接从磁盘加载文件系统，这种区分跟内核配置有关。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机系统启动流程</title>
    <link href="https://hchen90.github.io/2018/06/16/systemstartup/"/>
    <id>https://hchen90.github.io/2018/06/16/systemstartup/</id>
    <published>2018-06-16T12:40:10.000Z</published>
    <updated>2018-06-16T12:40:10.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;远古时代&quot;&gt;远古时代&lt;/h1&gt;
&lt;p&gt;这个时期，计算机是处于电气化高度相关的环境下，几乎没有软件的概念（这里有点瑕疵，稍后补充）。&lt;/p&gt;
&lt;p&gt;计算机这个时候会进行一系列针对硬件的自测试，尤其检测一些必要硬件是否可用，这个过程成为POST自检，如果检测通过就会进行下一个步骤：BIOS模式，或者UEFI模式。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="GRUB" scheme="https://hchen90.github.io/tags/GRUB/"/>
    
    <category term="UEFI" scheme="https://hchen90.github.io/tags/UEFI/"/>
    
    <category term="BIOS" scheme="https://hchen90.github.io/tags/BIOS/"/>
    
  </entry>
  
  <entry>
    <title>LZSS压缩算法</title>
    <link href="https://hchen90.github.io/2018/04/01/lzsscompalgo/"/>
    <id>https://hchen90.github.io/2018/04/01/lzsscompalgo/</id>
    <published>2018-04-01T13:12:32.000Z</published>
    <updated>2018-04-01T13:12:32.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;lzss算法简介&quot;&gt;LZSS算法简介&lt;/h1&gt;
&lt;p&gt;LZSS算法是LZ77算法的改良版，由James A. Storer和Thomas
Szymacski于1982年发表在ACM杂志上。LZSS算法充分地利用了位的标记，从而使得压缩效率相比较于LZ77而言，有了显著提高。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://hchen90.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="algorithm" scheme="https://hchen90.github.io/tags/algorithm/"/>
    
    <category term="lzss" scheme="https://hchen90.github.io/tags/lzss/"/>
    
  </entry>
  
  <entry>
    <title>LZ77压缩算法</title>
    <link href="https://hchen90.github.io/2018/03/31/lz77compalgo/"/>
    <id>https://hchen90.github.io/2018/03/31/lz77compalgo/</id>
    <published>2018-03-31T12:38:24.000Z</published>
    <updated>2018-03-31T12:38:24.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;lz77算法简介&quot;&gt;LZ77算法简介&lt;/h1&gt;
&lt;p&gt;LZ77算法是一种无损压缩算法，最早由两位以色列人于1977发表，它是一种典型的字典型压缩算法，目前几乎大多数的无损压缩算法都是基于这个LZ77算法，也就是在其基础上优化修改，此算法可以称得上是无损压缩算法界的鼻祖了。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://hchen90.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="lz77" scheme="https://hchen90.github.io/tags/lz77/"/>
    
    <category term="algorithm" scheme="https://hchen90.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Linux 系统启用 UEFI 的 Secure Boot</title>
    <link href="https://hchen90.github.io/2017/09/02/enablesbonlinux/"/>
    <id>https://hchen90.github.io/2017/09/02/enablesbonlinux/</id>
    <published>2017-09-01T16:17:02.000Z</published>
    <updated>2017-09-01T16:17:02.000Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;Secure Boot 作为 UEFI 的一个选项，它可以被设置为开启或关闭 (
有少数的计算机里面， Secure Boot
被设置为开启，却不存在关闭它的选项，但系统主板内置有 Windows
系统的公钥证书签名，使其只能加载 Windows
，其他系统一律不以加载，用户没有选项，不能关闭，还没法换系统，无法适用本博客介绍内容）。
Secure Boot 所需要的公钥证书被保存在计算机的主板的 FLASH
里面（注意不是磁盘里面哦），在主板的一小块 FLASH 里面保存着 PK ， KEK，
db， dbx 的证书链，所以， &lt;strong&gt;在操作开始前请确保你的计算机 UEFI-BIOS
的 Secure Boot
能够被关闭，否则，发生操作失误，将导致证书不能匹配任何程序代码文件，而使主板拒绝加载任何程序代码文件，就会导致主板变砖&lt;/strong&gt;
(虽然它不是 BIOS ，但是许多人都这么称呼它为 UEFI-BIOS
，所以，这里也这么称呼其为 UEFI-BIOS) 。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="linux" scheme="https://hchen90.github.io/tags/linux/"/>
    
    <category term="uefi" scheme="https://hchen90.github.io/tags/uefi/"/>
    
    <category term="openssl" scheme="https://hchen90.github.io/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>软件设计模式 - 行为模式</title>
    <link href="https://hchen90.github.io/2017/06/08/softwaredesignpattern4/"/>
    <id>https://hchen90.github.io/2017/06/08/softwaredesignpattern4/</id>
    <published>2017-06-08T14:01:03.000Z</published>
    <updated>2024-10-08T12:15:08.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;软件设计模式---行为模式&quot;&gt;软件设计模式 - 行为模式&lt;/h1&gt;
&lt;p&gt;行为模式负责对象之间的高效沟通和职责委派。&lt;/p&gt;
&lt;p&gt;行为模式包括：责任链，命令，迭代器，中介者，备忘录，观察者，状态，策略，模版方法，访问者。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="设计模式" scheme="https://hchen90.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>软件设计模式 - 结构型模式</title>
    <link href="https://hchen90.github.io/2017/06/05/softwaredesignpattern3/"/>
    <id>https://hchen90.github.io/2017/06/05/softwaredesignpattern3/</id>
    <published>2017-06-05T13:11:12.000Z</published>
    <updated>2017-06-05T13:11:12.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;软件设计模式---结构型模式&quot;&gt;软件设计模式 - 结构型模式&lt;/h1&gt;
&lt;p&gt;结构型模式介绍类和对象的组装方式，同时保持较大的灵活性和高效性。&lt;/p&gt;
&lt;p&gt;结构型模式包括：适配器，桥接，组合，装饰，外观，享元，代理。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="设计模式" scheme="https://hchen90.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>软件设计模式 - 创建型模式</title>
    <link href="https://hchen90.github.io/2017/06/04/softwaredesignpattern2/"/>
    <id>https://hchen90.github.io/2017/06/04/softwaredesignpattern2/</id>
    <published>2017-06-04T11:04:11.000Z</published>
    <updated>2017-06-04T11:04:11.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;软件设计模式---创建型模式&quot;&gt;软件设计模式 - 创建型模式&lt;/h1&gt;
&lt;p&gt;创建型模式分为：工厂方法，抽象工厂，生成器，原型，单例。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="设计模式" scheme="https://hchen90.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>软件设计模式简介</title>
    <link href="https://hchen90.github.io/2017/06/02/softwaredesignpattern1/"/>
    <id>https://hchen90.github.io/2017/06/02/softwaredesignpattern1/</id>
    <published>2017-06-02T12:12:01.000Z</published>
    <updated>2017-06-02T12:12:01.000Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;软件设计模式简介&quot;&gt;软件设计模式简介&lt;/h1&gt;
&lt;p&gt;软件设计模式属于软件工程领域的解决问题的基本方法，它提供了一种合理地达成目标的处理步骤。本文主要简单提出为何需要它，它的作用，以及它的主要组成元素。&lt;/p&gt;</summary>
    
    
    
    <category term="总结" scheme="https://hchen90.github.io/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="设计模式" scheme="https://hchen90.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何将处于虚拟机中的MINIX系统中的文件复制到实体机的LINUX系统中来</title>
    <link href="https://hchen90.github.io/2016/10/03/minix/"/>
    <id>https://hchen90.github.io/2016/10/03/minix/</id>
    <published>2016-10-02T16:16:13.000Z</published>
    <updated>2016-10-02T16:16:13.000Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;问题来源&quot;&gt;问题来源&lt;/h2&gt;
&lt;p&gt;直接在虚拟机MINIX中阅读它的源代码，十分不便，修改调试做移植也非常困难，如果将MINIX系统中的部分源代码拷贝到实体机LINUX中，在LINUX系统中进行修改调试将会非常方便。&lt;/p&gt;
&lt;p&gt;然而，MINIX系统是一种比较基本的系统，不能像vmware中使用Windows类系统那样，直接给它装VMTools（因为缺失XWindows，虽然理论上可以给MINIX装个XWindows，但是，太麻烦，而且仅仅为了几个源代码，有点大途小用）。因为vmware的磁盘文件（&lt;code&gt;.vmdk&lt;/code&gt;）不是原始的磁盘数据文件，而且，vmware对据如MINIX这些生僻系统的文件系统的识别性不是太理想，造成用vmware无法挂载MINIX系统到实体主机上，仍然复制不到虚拟机中的MINIX的文件。&lt;/p&gt;</summary>
    
    
    
    <category term="随笔" scheme="https://hchen90.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="minix" scheme="https://hchen90.github.io/tags/minix/"/>
    
    <category term="qemu" scheme="https://hchen90.github.io/tags/qemu/"/>
    
  </entry>
  
</feed>
